---
title: 面试题整理
date: 2020-02-15 23:13:15
tags: [java,面试 ]
type: "categories"
categories: java面试
---

# java基础

## 基本概念

### private的问题

private修饰的方法属性可以通过反射访问，那么private的意义是什么？

简单来说，private并不是解决“安全”问题的。 安全是指不让代码被非法看到/访问。但是只要人能拿到代码，总会有办法去查看和改变代码。可以用SecurityManager来防止private被访问，但是任然有其他各种方式拿到java的bytecode，并做任意修改。比如有asm这样的lib，也有instrument api这种东西。c++这种语言还能通过指针跳过private

回答：1：private并不是保证安全性的关键字。 是对开发的一种约束，强调的是OOP的封装概念，

​			2：从外部对对象进行常规调用时，不能够看到清晰的类结构和属性。

### 类初始化顺序

类的初始化顺序，我以前只知道先初始化基类在初始化派生类，忽略了代码块儿的问题，正确的顺序应该是

基类的静态：正确的顺序是

基类静态代码块，基类静态成员字段（并列优先级，按照代码中出现的先后顺序执行，且只有第一次加载时执行）——>派生类静态代码块，派生类静态成员字段（并列优先级，按照代码中出现的先后顺序执行，且只有第一次加载时执行）——>基类普通代码块，基类普通成员字段（并列优点级，按代码中出现先后顺序执行）——>基类构造函数——>派生类普通代码块，派生类普通成员字段（并列优点级，按代码中出现先后顺序执行）——>派生类构造函数

基本上写个例子就可以测试出结果

### clone方法

基本数据类型(char ,short,int,long,float,double,byte,boolean)在传递的时候是按值传递，对象类型是按引用传递，（java在new 语句之后返回的是对象的指引用）,实际过程中经常会遇见复制一个已有的对象A到另一个具有相同状态的对象B,而且对B的修改不影响A。实现clone方法的实体需要继承Cloneable接口。深拷贝和浅拷贝最根本的区别在于是否真正获取一个对象的复制实体，而不是引用。假设B复制了A，修改A的时候，看B是否发生变化：

如果B跟着也变了，说明是浅拷贝，拿人手短！（修改堆内存中的同一个值）

如果B没有改变，说明是深拷贝，自食其力！（修改堆内存中的不同的值）

### 反射机制

反射及智能在运行时对类进行装载，能够增加程序的灵活性，反射主要用来得到一个对象所属的类，获取类的成员方法和变量，在运行时创建对象，调用对象的方法。java创建对象的方法  new,反射，clone,反序列化

### 函数指针

在C++中有一个概念-函数指针，其中最重要的功能是函数回调，利用函数的回调函数来编写程序，传递一个函数的指针参数来调用下一个函数，java中没有指针的概念，但是可以通过接口和类实现相同 的功能。在接口参数接受一个interface参数，来执行回调方法。

## 面向对象

面向对象是将数据和对数据的操作方法集中放在一起，作为一个相互依赖的整体，即对象，对象通过接口与外部发生交流。

面向对象主要有三个特征，继承、封装、多态

封装是将数据和方法抽象成 类，在对自身的数据方法进行保护，可以把自己的数据和方法让可信的类或对象进行操作，对不可信的数据方法进行隐藏。

继承是一种联结类的层次模型，允许和鼓励类的重用，提供了明确的表达共性的方法。派生类可以从基类中获取继承的方法和变量 

多态 允许不同类的对象对统一消息做出响应，包含参数化多态和包含多态。

### 多态的实现机制

编译时多态和运行时多态。编译时通过方法的重载实现，运行时多态是通过方法的覆盖，继承方法是重写







# 多线程

## 什么是线程

线程是指程序在运行过程中，能够执行代码的一个执行单元。进程是一段正在执行程序的抽象。 java中线程的状态：*就绪、运行、挂起、结束*

## java 实现线程的方式

1：类继承Thread  2：实现Runnable接口  3.继承Callable<T>接口

```java
public class ThreadTest3 implements Callable<String>{
    @Override
    public String call() throws Exception {
        return "有返回值的线程";
    }

    public static void main(String[] args) {
        try {
            ExecutorService threadPool = Executors.newSingleThreadExecutor();
            Future<String> future = threadPool.submit(new ThreadTest3());
            System.out.println(future.get());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```



## run()与start()方法的区别

一般系统通过调用start()方法来启用一个线程，此时该线程处于就绪的状态，而非运行状态，此时这个线程可以被JVM调用，调用的时候在通过run()方法来完成实际的操作。方法结束后该线程终止。

如果直接调用run()方法，这会被当成普通函数调用，程序中仍然只有主线程。程序是同步的，达不到多线程的目的。

## 多线程同步的方法

在多线程环境中，访问数据是一个很危险的事情，很容易出现数据的安全问题。因此java提供了几种实现同步机制的方法。

### 1synchronzied关键字

主要有两种用法 synchronzied方法和synchronzied代码块

java中synchronzied的实现与Monitor相关，java中的所有对象都拥有一个私有线程锁或则成为Monitor锁，Monitor中的Owner字段表明该对象是否被线程拥有Monitor record。

### notify()与wait()方法

synchronzied锁住某个对象或者资源的时候，线程A1在执行synchronzied代码，线程A2也在执行synchronzied代码，线程A2要等待A1执行完成之后才能执行，这种情况下就可以使用wait()和notif()。synchronzied在执行期间，可以使用wait()方法释放对象锁，进入等待状态，并可以调用notif()提醒其他等待的线程。fei

### 2重入锁ReentrantLock

jdk 5添加了Lock接口和她的实现类，Lock也可以用来实现同步。

Lock()方法。以阻塞的方式获取锁，如果获取到锁，立刻返回，没有获取锁则继续等待。

tryLock()非阻塞的方式获取锁，获取到锁立刻返回true,未获取到锁返回false

lockInterruptibly() 如果获取到了锁，立刻返回，没有获取到锁，当前线程处于休眠状态，直到获取到锁，或者当前线程被别的线程中断。



### sleep()和wait()方法的区别

sleep()方法是Thread类的静态方法，是线程用来控制自身的，他会使线程暂停一段时间，等时间一到，该线程会自动苏醒。而wwait()方法是Object类的方法，这个方法会使拥有该对象锁的进程等待，知道其他线程调用notify()方法来唤醒

对锁的处理机制不同：sleep()方法的主要作用是线程暂停一段时间，时间到了会自动恢复，所以sleep()不会释放锁，而wait()主要应用于线程间的通信，当线程调用wait()方法后，线程会释放掉他拥有的锁。

## 终止线程的方法

java语言中可以使用stop()和suspend()方法来终止线程的执行。stop()方法会释放已经锁定的所有监视资源。

而suspend()方法不会释放锁，这就会导致，如果使用suspend()挂起一个线程，那么在锁恢复之前不会被释放，这就很容易导致死锁。所以Java语言不建议上述两种方法来终止线程。一般建议是让线程自行结束进入Dead，即执行完Run()方法。提供某种方式能使线程跑完run()方法。例如可以通过interrupt()等异常

## synchronized和lock

用法不同：在需要同步的对象中加入synchronized控制，既可以加在方法上，也可以加在代码块儿中,而Lock需要显示的指定起始位置和结束位置。

性能不同：synchronized在资源竞争不激烈的时候，性能优于ReetrantLock,竞争激烈的时候，synchronized的性能下降的非常快，而ReetrantLock的性能基本保持不变

锁机制不同：synchronized获取锁和释放都在块结构中。获取多个锁时，必须以相反的顺序释放，而且是自动释放，而Lock需要开发人员手动释放，一般在finally里卖弄释放，否则可能会引起死锁 的问题。

当一个线程进入了synchronized方法里面，其他线程能否访问其他方法取决于这个方法。如果访问的其他方法是非synchronized的，其他线程可以访问。如果其他方法是静态的synchronized方法，静态synchronized方法仍然可以被调用。

## join()方法的作用

join()方法是让调用该方法的线程在执行完run()方法滞后，再执行join()方法，主要用于线程同步。或者使用该线程的join(2000)方法来等待该线程，设置等待时间。



# 消息队列



# 虚拟机（JVM）

## 方法区和永久区的理解





# spring IOC和AOP

先解释一下IOC和AOP, 

## IOC 

许多应用都是通过彼此间的相互合作来实现业务逻辑的，如类A要调用类B的方法，以前我们都是在类A中，通过自身***new***一个类B，然后在调用类B的方法，现在我们把new类B的事情交给spring来做，在我们调用的时候，容器会为我们实例化。 IOC容器的初始化过程资源定位，即定义bean的xml-------》载入--------》IOC容器注册，注册beanDefinition,现在的常用方式是基于注解，bean的创建方式是通过**工厂模式**，数据通过**反射**的方式注入

## AOP 

 面向切面编程，在我们的应用中，经常需要做一些事情，但是这些事情与核心业务无关，比如，要记录所有update*方法的执行时间时间，操作人等等信息。AOP的实现原理就代理方式 有两只，动态代理和静态代理

