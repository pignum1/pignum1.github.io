<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>spring-cloud zuul集成管理swagger</title>
    <url>/2020/06/13/spring-cloud-zuul%E9%9B%86%E6%88%90%E7%AE%A1%E7%90%86swagger/</url>
    <content><![CDATA[<h1 id="spring-cloud-zuul-监听多个swagger2"><a href="#spring-cloud-zuul-监听多个swagger2" class="headerlink" title="spring cloud zuul 监听多个swagger2"></a>spring cloud zuul 监听多个swagger2</h1><h2 id="swagger服务"><a href="#swagger服务" class="headerlink" title="swagger服务"></a>swagger服务</h2><p>创建一个项目添加了swagger的项目，我这里使用的是已有一个项目schedule</p>
<p>引入swagger依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile <span class="string">group:</span> <span class="string">'io.springfox'</span>, <span class="string">name:</span> <span class="string">'springfox-swagger-ui'</span>, <span class="string">version:</span> <span class="string">'2.7.0'</span></span><br><span class="line">compile <span class="string">group:</span> <span class="string">'io.springfox'</span>, <span class="string">name:</span> <span class="string">'springfox-swagger2'</span>, <span class="string">version:</span> <span class="string">'2.7.0'</span></span><br></pre></td></tr></table></figure>
<p>添加swagger的配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.panghu"</span>))</span><br><span class="line">                .apis(RequestHandlerSelectors.withClassAnnotation(Api<span class="class">.<span class="keyword">class</span>))</span></span><br><span class="line"><span class="class">                .<span class="title">apis</span>(<span class="title">RequestHandlerSelectors</span>.<span class="title">withMethodAnnotation</span>(<span class="title">ApiOperation</span>.<span class="title">class</span>))</span></span><br><span class="line"><span class="class">                .<span class="title">paths</span>(<span class="title">PathSelectors</span>.<span class="title">any</span>())</span></span><br><span class="line"><span class="class">                .<span class="title">build</span>()</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">"schedule系统接口文档"</span>)</span><br><span class="line">                .description(<span class="string">"这是系统接口文档说明"</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> Contact(<span class="string">"panghu"</span>, <span class="string">"panghu的博客URL"</span>, <span class="string">"XXXX@qq.com"</span>))</span><br><span class="line">                .version(<span class="string">"1.0"</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">UiConfiguration <span class="title">uiConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UiConfiguration(<span class="keyword">null</span>, <span class="string">"list"</span>, <span class="string">"alpha"</span>, <span class="string">"schema"</span>,</span><br><span class="line">                UiConfiguration.Constants.DEFAULT_SUBMIT_METHODS, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="number">60000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个方法来测试swagger的文档</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api</span>(tags = <span class="string">"swagger测试"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/users"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"simpleTest"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"简单接口测试"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"简单接口测试"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/bodyTest"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"body参数测试"</span>, notes = <span class="string">"接收body参数测试"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bodyTest</span><span class="params">(@RequestBody ManualVo manualVo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"paramsDescTest"</span>)</span><br><span class="line">    <span class="meta">@ApiImplicitParam</span>(paramType = <span class="string">"path"</span>, dataType = <span class="string">"Long"</span>, name = <span class="string">"id"</span>, value = <span class="string">"这是id的描述"</span>, required = <span class="keyword">true</span>, example = <span class="string">"1"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"更新用户详细信息"</span>, notes = <span class="string">"根据url的id来指定更新对象，并根据传过来的user信息来更新用户详细信息"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">putUser</span><span class="params">(@PathVariable Long id, @RequestBody ManualVo manualVo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//api的model</span></span><br><span class="line"><span class="meta">@ApiModel</span>(description = <span class="string">"参数VO"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManualVo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"id参数"</span>)</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"参数字符串"</span>)</span><br><span class="line">    <span class="keyword">private</span> String param;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在启动类上添加swagger注解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableSwagger2</span><br><span class="line">@SpringCloudApplication</span><br><span class="line">@EnableJpaAuditing</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建网关服务-zuul"><a href="#创建网关服务-zuul" class="headerlink" title="创建网关服务 zuul"></a>创建网关服务 zuul</h2><p>前两部与其他服务相同，引入swagger和网关依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile <span class="string">group:</span> <span class="string">'io.springfox'</span>, <span class="string">name:</span> <span class="string">'springfox-swagger-ui'</span>, <span class="string">version:</span> <span class="string">'2.7.0'</span></span><br><span class="line">compile <span class="string">group:</span> <span class="string">'io.springfox'</span>, <span class="string">name:</span> <span class="string">'springfox-swagger2'</span>, <span class="string">version:</span> <span class="string">'2.7.0'</span></span><br><span class="line">implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-zuul'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class Swagger2Config &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi() &#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;系统集成api&quot;)</span><br><span class="line">                .description(&quot;系统接口集成文档说明&quot;)</span><br><span class="line">                .contact(new Contact(&quot;panghu&quot;, &quot;xxxx&quot;, &quot;xxx@qq.com&quot;))</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加读取的swagger配置"><a href="#添加读取的swagger配置" class="headerlink" title="添加读取的swagger配置"></a>添加读取的swagger配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Primary</span><br><span class="line">public class DocumentationConfig implements SwaggerResourcesProvider &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;SwaggerResource&gt; get() &#123;</span><br><span class="line">        List&lt;SwaggerResource&gt; resources = new ArrayList&lt;&gt;();</span><br><span class="line">        //这一步添加需要监听的swagger</span><br><span class="line">        resources.add(swaggerResource(&quot;schedule 服务&quot;, &quot;/schedule/v2/api-docs&quot;, &quot;1.0&quot;));</span><br><span class="line">        return resources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private SwaggerResource swaggerResource(String name, String location, String version) &#123;</span><br><span class="line">        SwaggerResource swaggerResource = new SwaggerResource();</span><br><span class="line">        swaggerResource.setName(name);</span><br><span class="line">        swaggerResource.setLocation(location);</span><br><span class="line">        swaggerResource.setSwaggerVersion(version);</span><br><span class="line">        return swaggerResource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在网关的bootstrap.properties中配置路径转发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#服务名路径转发</span><br><span class="line">zuul.routes.schedule=/schedule/**</span><br></pre></td></tr></table></figure>
<p>启动两个服务之后，打开网关的swagger地址 <a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a></p>
<p><img src="/2020/06/13/spring-cloud-zuul集成管理swagger/swagger.png" alt></p>
]]></content>
      <categories>
        <category>spring cloud alibaba</category>
      </categories>
      <tags>
        <tag>spring cloud alibaba</tag>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud 集成shiro</title>
    <url>/2020/05/25/spring-cloud-%E9%9B%86%E6%88%90shiro/</url>
    <content><![CDATA[<h1 id="Spring-cloud-集成shiro"><a href="#Spring-cloud-集成shiro" class="headerlink" title="Spring cloud 集成shiro"></a>Spring cloud 集成shiro</h1><p>使用的redis作为缓存,不多逼逼，直接上代码</p>
<h3 id="自定义序列化类SerializeUtils"><a href="#自定义序列化类SerializeUtils" class="headerlink" title="自定义序列化类SerializeUtils"></a>自定义序列化类SerializeUtils</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SerializeUtils implements RedisSerializer &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(SerializeUtils.class);</span><br><span class="line"></span><br><span class="line">    public static boolean isEmpty(byte[] data) &#123;</span><br><span class="line">        return (data == null || data.length == 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 序列化</span><br><span class="line">     * @param object</span><br><span class="line">     * @return</span><br><span class="line">     * @throws SerializationException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public byte[] serialize(Object object) throws SerializationException &#123;</span><br><span class="line">        byte[] result = null;</span><br><span class="line"></span><br><span class="line">        if (object == null) &#123;</span><br><span class="line">            return new byte[0];</span><br><span class="line">        &#125;</span><br><span class="line">        try (</span><br><span class="line">                ByteArrayOutputStream byteStream = new ByteArrayOutputStream(128);</span><br><span class="line">                ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteStream)</span><br><span class="line">        )&#123;</span><br><span class="line"></span><br><span class="line">            if (!(object instanceof Serializable)) &#123;</span><br><span class="line">                throw new IllegalArgumentException(SerializeUtils.class.getSimpleName() + &quot; requires a Serializable payload &quot; +</span><br><span class="line">                        &quot;but received an object of type [&quot; + object.getClass().getName() + &quot;]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            objectOutputStream.writeObject(object);</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">            result =  byteStream.toByteArray();</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            logger.error(&quot;Failed to serialize&quot;,ex);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 反序列化</span><br><span class="line">     * @param bytes</span><br><span class="line">     * @return</span><br><span class="line">     * @throws SerializationException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Object deserialize(byte[] bytes) throws SerializationException &#123;</span><br><span class="line"></span><br><span class="line">        Object result = null;</span><br><span class="line"></span><br><span class="line">        if (isEmpty(bytes)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try (</span><br><span class="line">                ByteArrayInputStream byteStream = new ByteArrayInputStream(bytes);</span><br><span class="line">                ObjectInputStream objectInputStream = new ObjectInputStream(byteStream)</span><br><span class="line">        )&#123;</span><br><span class="line">            result = objectInputStream.readObject();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;Failed to deserialize&quot;,e);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RedisConfig"><a href="#RedisConfig" class="headerlink" title="RedisConfig"></a>RedisConfig</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.panghu.config;</span><br><span class="line"></span><br><span class="line">import com.panghu.global.MyByteSource;</span><br><span class="line">import com.panghu.global.SerializeUtils;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line">import org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line">import org.springframework.cache.annotation.EnableCaching;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line">import org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line">import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line">import org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line">import redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: nacos_base4j</span><br><span class="line"> * @Package: com.panghu.config</span><br><span class="line"> * @ClassName: RedisConfig</span><br><span class="line"> * @Author: wxy</span><br><span class="line"> * @Description: redis配置类</span><br><span class="line"> * @Date: 2020/5/18 10:35</span><br><span class="line"> * @Version: 1.0</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableCaching</span><br><span class="line">@Data</span><br><span class="line">public class RedisConfig extends CachingConfigurerSupport &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * spring管理自动注入  redisTemplate &lt;String ,Object&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param factory</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">        // 1.创建 redisTemplate 模版</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();</span><br><span class="line">        // 2.关联 redisConnectionFactory</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        // 3.创建 自定义序列化类</span><br><span class="line"></span><br><span class="line">//        FastJsonRedisSerializer myRedisSerializer = new FastJsonRedisSerializer(Object.class);</span><br><span class="line">        // 7.设置 value 的转化格式和 key 的转化格式 默认使用的是JdkSerializationRedisSerializer</span><br><span class="line">//        template.setValueSerializer(myRedisSerializer);</span><br><span class="line">//        template.setHashValueSerializer(myRedisSerializer);</span><br><span class="line">//        template.setDefaultSerializer(myRedisSerializer);</span><br><span class="line">        GenericJackson2JsonRedisSerializer jackson2JsonRedisSerializer = new GenericJackson2JsonRedisSerializer();</span><br><span class="line">        template.setValueSerializer(new SerializeUtils());</span><br><span class="line">        template.setHashValueSerializer(new SerializeUtils());</span><br><span class="line">        // 设置键（key）的序列化采用StringRedisSerializer。</span><br><span class="line">        template.setKeySerializer(new StringRedisSerializer());</span><br><span class="line">        template.setHashKeySerializer(new StringRedisSerializer());</span><br><span class="line"></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * spring管理自动注入  redisTemplate &lt;String ,String&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param factory</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(StringRedisTemplate.class)</span><br><span class="line">    public RedisTemplate&lt;String, String&gt; stringRedisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">        return new StringRedisTemplate(factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// ################################jedis连接池配置###################################</span><br><span class="line">    /**</span><br><span class="line">     * redis地址</span><br><span class="line">     */</span><br><span class="line">    @Value(&quot;$&#123;spring.redis.host&#125;&quot;)</span><br><span class="line">    private String host;</span><br><span class="line">    /**</span><br><span class="line">     * redis端口号</span><br><span class="line">     */</span><br><span class="line">    @Value(&quot;$&#123;spring.redis.port&#125;&quot;)</span><br><span class="line">    private Integer port;</span><br><span class="line">//    /**</span><br><span class="line">//     * redis密码</span><br><span class="line">//     */</span><br><span class="line">//    @Value(&quot;$&#123;spring.redis.password&#125;&quot;)</span><br><span class="line">//    private String password;</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * JedisPoolConfig 连接池</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public JedisPoolConfig jedisPoolConfig() &#123;</span><br><span class="line">        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();</span><br><span class="line">        //最大空闲数</span><br><span class="line">        jedisPoolConfig.setMaxIdle(300);</span><br><span class="line">        //连接池的最大数据库连接数</span><br><span class="line">        jedisPoolConfig.setMaxTotal(1000);</span><br><span class="line">        //最大建立连接等待时间</span><br><span class="line">        jedisPoolConfig.setMaxWaitMillis(1000);</span><br><span class="line">        //逐出连接的最小空闲时间 默认1800000毫秒(30分钟)</span><br><span class="line">        jedisPoolConfig.setMinEvictableIdleTimeMillis(300000);</span><br><span class="line">        //每次逐出检查时 逐出的最大数目 如果为负数就是 : 1/abs(n), 默认3</span><br><span class="line">        jedisPoolConfig.setNumTestsPerEvictionRun(10);</span><br><span class="line">        //逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1</span><br><span class="line">        jedisPoolConfig.setTimeBetweenEvictionRunsMillis(30000);</span><br><span class="line">        //是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个</span><br><span class="line">        jedisPoolConfig.setTestOnBorrow(true);</span><br><span class="line">        //在空闲时检查有效性, 默认false</span><br><span class="line">        jedisPoolConfig.setTestWhileIdle(true);</span><br><span class="line">        return jedisPoolConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//    /**</span><br><span class="line">//     * 配置工厂</span><br><span class="line">//     *</span><br><span class="line">//     * @param jedisPoolConfig</span><br><span class="line">//     * @return</span><br><span class="line">//     */</span><br><span class="line">//    @Bean</span><br><span class="line">//    public JedisConnectionFactory jedisConnectionFactory(JedisPoolConfig jedisPoolConfig) &#123;</span><br><span class="line">//        JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory();</span><br><span class="line">//        //连接池</span><br><span class="line">//        jedisConnectionFactory.setPoolConfig(jedisPoolConfig);</span><br><span class="line">//        //IP地址</span><br><span class="line">//        jedisConnectionFactory.setHostName(host);</span><br><span class="line">//        //端口号</span><br><span class="line">//        jedisConnectionFactory.setPort(port);</span><br><span class="line">//        //如果Redis设置有密码</span><br><span class="line">////        jedisConnectionFactory.setPassword(password);</span><br><span class="line">//        //客户端超时时间单位是毫秒</span><br><span class="line">//        jedisConnectionFactory.setTimeout(5000);</span><br><span class="line">//        return jedisConnectionFactory;</span><br><span class="line">//    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="RedisManager"><a href="#RedisManager" class="headerlink" title="RedisManager"></a>RedisManager</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RedisManager &#123;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    //=============================common============================</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 指定缓存失效时间</span><br><span class="line">     *</span><br><span class="line">     * @param key  键</span><br><span class="line">     * @param time 时间(秒)</span><br><span class="line">     */</span><br><span class="line">    public void expire(String key, long time) &#123;</span><br><span class="line">        redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断key是否存在</span><br><span class="line">     *</span><br><span class="line">     * @param key 键</span><br><span class="line">     * @return true 存在 false不存在</span><br><span class="line">     */</span><br><span class="line">    public Boolean hasKey(String key) &#123;</span><br><span class="line">        return redisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除缓存</span><br><span class="line">     *</span><br><span class="line">     * @param key 可以传一个值 或多个</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public void del(String... key) &#123;</span><br><span class="line">        if (key != null &amp;&amp; key.length &gt; 0) &#123;</span><br><span class="line">            if (key.length == 1) &#123;</span><br><span class="line">                redisTemplate.delete(key[0]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                redisTemplate.delete(CollectionUtils.arrayToList(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量删除key</span><br><span class="line">     *</span><br><span class="line">     * @param keys</span><br><span class="line">     */</span><br><span class="line">    public void del(Collection keys) &#123;</span><br><span class="line">        redisTemplate.delete(keys);</span><br><span class="line">    &#125;</span><br><span class="line">    //============================String=============================</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 普通缓存获取</span><br><span class="line">     *</span><br><span class="line">     * @param key 键</span><br><span class="line">     * @return 值</span><br><span class="line">     */</span><br><span class="line">    public Object get(String key) &#123;</span><br><span class="line">        return redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 普通缓存放入</span><br><span class="line">     *</span><br><span class="line">     * @param key   键</span><br><span class="line">     * @param value 值</span><br><span class="line">     */</span><br><span class="line">    public void set(String key, Object value) &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 普通缓存放入并设置时间</span><br><span class="line">     *</span><br><span class="line">     * @param key   键</span><br><span class="line">     * @param value 值</span><br><span class="line">     * @param time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span><br><span class="line">     */</span><br><span class="line">    public void set(String key, Object value, long time) &#123;</span><br><span class="line">        if (time &gt; 0) &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            set(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用scan命令 查询某些前缀的key</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; scan(String key) &#123;</span><br><span class="line">        Set&lt;String&gt; execute = this.redisTemplate.execute(new RedisCallback&lt;Set&lt;String&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Set&lt;String&gt; doInRedis(RedisConnection connection) throws DataAccessException &#123;</span><br><span class="line">                Set&lt;String&gt; binaryKeys = new HashSet&lt;&gt;();</span><br><span class="line">                Cursor&lt;byte[]&gt; cursor = connection.scan(new ScanOptions.ScanOptionsBuilder().match(key).count(1000).build());</span><br><span class="line">                while (cursor.hasNext()) &#123;</span><br><span class="line">                    binaryKeys.add(new String(cursor.next()));</span><br><span class="line">                &#125;</span><br><span class="line">                return binaryKeys;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return execute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用scan命令 查询某些前缀的key 有多少个</span><br><span class="line">     * 用来获取当前session数量,也就是在线用户</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long scanSize(String key) &#123;</span><br><span class="line">        long dbSize = this.redisTemplate.execute(new RedisCallback&lt;Long&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Long doInRedis(RedisConnection connection) throws DataAccessException &#123;</span><br><span class="line">                long count = 0L;</span><br><span class="line">                Cursor&lt;byte[]&gt; cursor = connection.scan(ScanOptions.scanOptions().match(key).count(1000).build());</span><br><span class="line">                while (cursor.hasNext()) &#123;</span><br><span class="line">                    cursor.next();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                return count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return dbSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="redis-作为缓存管理shiro"><a href="#redis-作为缓存管理shiro" class="headerlink" title="redis 作为缓存管理shiro"></a>redis 作为缓存管理shiro</h2><p>使用Redis作为缓存需要shiro重写RedisCache、RedisCacheManager、SessionDAO</p>
<h3 id="RedisCache"><a href="#RedisCache" class="headerlink" title="RedisCache"></a>RedisCache</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RedisCache&lt;K,V&gt; implements Cache&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(RedisCache.class);</span><br><span class="line">    private RedisManager redisManager;</span><br><span class="line">    private String keyPrefix = &quot;&quot;;</span><br><span class="line">    private int expire = 0;</span><br><span class="line">    private String principalIdFieldName =  RedisCacheManager.DEFAULT_PRINCIPAL_ID_FIELD_NAME;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造方法</span><br><span class="line">     * @param redisManager</span><br><span class="line">     */</span><br><span class="line">    public RedisCache(RedisManager redisManager, String prefix, int expire, String principalIdFieldName) &#123;</span><br><span class="line">        if (redisManager == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;redisManager cannot be null.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.redisManager = redisManager;</span><br><span class="line">        if (prefix != null &amp;&amp; !&quot;&quot;.equals(prefix)) &#123;</span><br><span class="line">            this.keyPrefix = prefix;</span><br><span class="line">        &#125;</span><br><span class="line">        if (expire != -1) &#123;</span><br><span class="line">            this.expire = expire;</span><br><span class="line">        &#125;</span><br><span class="line">        if (principalIdFieldName != null &amp;&amp; !&quot;&quot;.equals(principalIdFieldName)) &#123;</span><br><span class="line">            this.principalIdFieldName = principalIdFieldName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据key 获取value</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     * @throws CacheException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public V get(K key) throws CacheException &#123;</span><br><span class="line">        logger.debug(&quot;get key [&#123;&#125;]&quot;,key);</span><br><span class="line">        if (key == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            String redisCacheKey = getRedisCacheKey(key);</span><br><span class="line">            Object rawValue = redisManager.get(redisCacheKey);</span><br><span class="line">            if (rawValue == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            V value = (V) rawValue;</span><br><span class="line">            return value;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new CacheException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 存放key -value到缓存中</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     * @throws CacheException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public V put(K key, V value) throws CacheException &#123;</span><br><span class="line">        logger.debug(&quot;put key [&#123;&#125;]&quot;,key);</span><br><span class="line">        if (key == null) &#123;</span><br><span class="line">            logger.warn(&quot;Saving a null key is meaningless, return value directly without call Redis.&quot;);</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            String redisCacheKey = getRedisCacheKey(key);</span><br><span class="line">            redisManager.set(redisCacheKey, value != null ? value : null, expire);</span><br><span class="line">            return value;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new CacheException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除一个缓存数据源</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     * @throws CacheException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public V remove(K key) throws CacheException &#123;</span><br><span class="line">        logger.debug(&quot;remove key [&#123;&#125;]&quot;,key);</span><br><span class="line">        if (key == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            String redisCacheKey = getRedisCacheKey(key);</span><br><span class="line">            Object rawValue = redisManager.get(redisCacheKey);</span><br><span class="line">            V previous = (V) rawValue;</span><br><span class="line">            redisManager.del(redisCacheKey);</span><br><span class="line">            return previous;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new CacheException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private String getRedisCacheKey(K key) &#123;</span><br><span class="line">        if (key == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return this.keyPrefix + getStringRedisKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">    private String getStringRedisKey(K key) &#123;</span><br><span class="line">        String redisKey;</span><br><span class="line">        if (key instanceof PrincipalCollection) &#123;</span><br><span class="line">            redisKey = getRedisKeyFromPrincipalIdField((PrincipalCollection) key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            redisKey = key.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        return redisKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getRedisKeyFromPrincipalIdField(PrincipalCollection key) &#123;</span><br><span class="line">        String redisKey;</span><br><span class="line">        Object principalObject = key.getPrimaryPrincipal();</span><br><span class="line">        Method pincipalIdGetter = null;</span><br><span class="line">        Method[] methods = principalObject.getClass().getDeclaredMethods();</span><br><span class="line">        for (Method m:methods) &#123;</span><br><span class="line">            if (RedisCacheManager.DEFAULT_PRINCIPAL_ID_FIELD_NAME.equals(this.principalIdFieldName)</span><br><span class="line">                    &amp;&amp; (&quot;getAuthCacheKey&quot;.equals(m.getName()) || &quot;getId&quot;.equals(m.getName()))) &#123;</span><br><span class="line">                pincipalIdGetter = m;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (m.getName().equals(&quot;get&quot; + this.principalIdFieldName.substring(0, 1).toUpperCase() + this.principalIdFieldName.substring(1))) &#123;</span><br><span class="line">                pincipalIdGetter = m;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pincipalIdGetter == null) &#123;</span><br><span class="line">            throw new PrincipalInstanceException(principalObject.getClass(), this.principalIdFieldName);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            Object idObj = pincipalIdGetter.invoke(principalObject);</span><br><span class="line">            if (idObj == null) &#123;</span><br><span class="line">                throw new PrincipalIdNullException(principalObject.getClass(), this.principalIdFieldName);</span><br><span class="line">            &#125;</span><br><span class="line">            redisKey = idObj.toString();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            throw new PrincipalInstanceException(principalObject.getClass(), this.principalIdFieldName, e);</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            throw new PrincipalInstanceException(principalObject.getClass(), this.principalIdFieldName, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return redisKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clear() throws CacheException &#123;</span><br><span class="line">        logger.debug(&quot;clear cache&quot;);</span><br><span class="line">        Set&lt;String&gt; keys = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            keys = redisManager.scan(this.keyPrefix + &quot;*&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;get keys error&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        if (keys == null || keys.size() == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (String key: keys) &#123;</span><br><span class="line">            redisManager.del(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        Long longSize = 0L;</span><br><span class="line">        try &#123;</span><br><span class="line">            longSize = new Long(redisManager.scanSize(this.keyPrefix + &quot;*&quot;));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;get keys error&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return longSize.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;K&gt; keys() &#123;</span><br><span class="line">        Set&lt;String&gt; keys = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            keys = redisManager.scan(this.keyPrefix + &quot;*&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;get keys error&quot;, e);</span><br><span class="line">            return Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line">        if (CollectionUtils.isEmpty(keys)) &#123;</span><br><span class="line">            return Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;K&gt; convertedKeys = new HashSet&lt;K&gt;();</span><br><span class="line">        for (String key:keys) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                convertedKeys.add((K) key);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logger.error(&quot;deserialize keys error&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return convertedKeys;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Collection&lt;V&gt; values() &#123;</span><br><span class="line">        Set&lt;String&gt; keys = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            keys = redisManager.scan(this.keyPrefix + &quot;*&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;get values error&quot;, e);</span><br><span class="line">            return Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line">        if (CollectionUtils.isEmpty(keys)) &#123;</span><br><span class="line">            return Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;V&gt; values = new ArrayList&lt;V&gt;(keys.size());</span><br><span class="line">        for (String key : keys) &#123;</span><br><span class="line">            V value = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                value = (V) redisManager.get(key);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logger.error(&quot;deserialize values= error&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">            if (value != null) &#123;</span><br><span class="line">                values.add(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Collections.unmodifiableList(values);</span><br><span class="line">    &#125;</span><br><span class="line">    public String getKeyPrefix() &#123;</span><br><span class="line">        return keyPrefix;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setKeyPrefix(String keyPrefix) &#123;</span><br><span class="line">        this.keyPrefix = keyPrefix;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getPrincipalIdFieldName() &#123;</span><br><span class="line">        return principalIdFieldName;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setPrincipalIdFieldName(String principalIdFieldName) &#123;</span><br><span class="line">        this.principalIdFieldName = principalIdFieldName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RedisCacheManager"><a href="#RedisCacheManager" class="headerlink" title="RedisCacheManager"></a>RedisCacheManager</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RedisCacheManager implements CacheManager &#123;</span><br><span class="line"></span><br><span class="line">    private final Logger logger = LoggerFactory.getLogger(RedisCacheManager.class);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * fast lookup by name map</span><br><span class="line">     */</span><br><span class="line">    private final ConcurrentMap&lt;String, Cache&gt; caches = new ConcurrentHashMap&lt;String, Cache&gt;();</span><br><span class="line">    private RedisManager redisManager;</span><br><span class="line">    /**</span><br><span class="line">     * expire time in seconds</span><br><span class="line">     */</span><br><span class="line">    private static final int DEFAULT_EXPIRE = 1800;</span><br><span class="line">    private int expire = DEFAULT_EXPIRE;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The Redis key prefix for caches</span><br><span class="line">     */</span><br><span class="line">    public static final String DEFAULT_CACHE_KEY_PREFIX = &quot;shiro:cache:&quot;;</span><br><span class="line">    private String keyPrefix = DEFAULT_CACHE_KEY_PREFIX;</span><br><span class="line">    public static final String DEFAULT_PRINCIPAL_ID_FIELD_NAME = &quot;authCacheKey or id&quot;;</span><br><span class="line">    private String principalIdFieldName = DEFAULT_PRINCIPAL_ID_FIELD_NAME;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;K, V&gt; Cache&lt;K, V&gt; getCache(String name) throws CacheException &#123;</span><br><span class="line">        logger.debug(&quot;get cache, name=&#123;&#125;&quot;,name);</span><br><span class="line">        Cache cache = caches.get(name);</span><br><span class="line">        if (cache == null) &#123;</span><br><span class="line">            cache = new RedisCache&lt;K, V&gt;(redisManager,keyPrefix + name + &quot;:&quot;, expire, principalIdFieldName);</span><br><span class="line">            caches.put(name, cache);</span><br><span class="line">        &#125;</span><br><span class="line">        return cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Logger getLogger() &#123;</span><br><span class="line">        return logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ConcurrentMap&lt;String, Cache&gt; getCaches() &#123;</span><br><span class="line">        return caches;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RedisManager getRedisManager() &#123;</span><br><span class="line">        return redisManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRedisManager(RedisManager redisManager) &#123;</span><br><span class="line">        this.redisManager = redisManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int getDefaultExpire() &#123;</span><br><span class="line">        return DEFAULT_EXPIRE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getExpire() &#123;</span><br><span class="line">        return expire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setExpire(int expire) &#123;</span><br><span class="line">        this.expire = expire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getDefaultCacheKeyPrefix() &#123;</span><br><span class="line">        return DEFAULT_CACHE_KEY_PREFIX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getKeyPrefix() &#123;</span><br><span class="line">        return keyPrefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setKeyPrefix(String keyPrefix) &#123;</span><br><span class="line">        this.keyPrefix = keyPrefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getDefaultPrincipalIdFieldName() &#123;</span><br><span class="line">        return DEFAULT_PRINCIPAL_ID_FIELD_NAME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPrincipalIdFieldName() &#123;</span><br><span class="line">        return principalIdFieldName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrincipalIdFieldName(String principalIdFieldName) &#123;</span><br><span class="line">        this.principalIdFieldName = principalIdFieldName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RedisSessionDAO"><a href="#RedisSessionDAO" class="headerlink" title="RedisSessionDAO"></a>RedisSessionDAO</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RedisSessionDAO extends AbstractSessionDAO &#123;</span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(RedisSessionDAO.class);</span><br><span class="line">    private static final String DEFAULT_SESSION_KEY_PREFIX = &quot;shiro:session:&quot;;</span><br><span class="line">    private String keyPrefix = DEFAULT_SESSION_KEY_PREFIX;</span><br><span class="line">    private static final long DEFAULT_SESSION_IN_MEMORY_TIMEOUT = 1000L;</span><br><span class="line">    /**</span><br><span class="line">     * doReadSession be called about 10 times when login.</span><br><span class="line">     * Save Session in ThreadLocal to resolve this problem. sessionInMemoryTimeout is expiration of Session in ThreadLocal.</span><br><span class="line">     * The default value is 1000 milliseconds (1s).</span><br><span class="line">     * Most of time, you don&apos;t need to change it.</span><br><span class="line">     */</span><br><span class="line">    private long sessionInMemoryTimeout = DEFAULT_SESSION_IN_MEMORY_TIMEOUT;</span><br><span class="line">    /**</span><br><span class="line">     * expire time in seconds</span><br><span class="line">     */</span><br><span class="line">    private static final int DEFAULT_EXPIRE = -2;</span><br><span class="line">    private static final int NO_EXPIRE = -1;</span><br><span class="line">    /**</span><br><span class="line">     * Please make sure expire is longer than sesion.getTimeout()</span><br><span class="line">     */</span><br><span class="line">    private int expire = DEFAULT_EXPIRE;</span><br><span class="line">    private static final int MILLISECONDS_IN_A_SECOND = 1000;</span><br><span class="line">    private RedisManager redisManager;</span><br><span class="line">    private static ThreadLocal sessionsInThread = new ThreadLocal();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update(Session session) throws UnknownSessionException &#123;</span><br><span class="line">        //如果会话过期/停止 没必要再更新了</span><br><span class="line">        try &#123;</span><br><span class="line">            if (session instanceof ValidatingSession &amp;&amp; !((ValidatingSession) session).isValid()) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (session instanceof ShiroSession) &#123;</span><br><span class="line">                // 如果没有主要字段(除lastAccessTime以外其他字段)发生改变</span><br><span class="line">                ShiroSession ss = (ShiroSession) session;</span><br><span class="line">                if (!ss.isChanged()) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                //如果没有返回 证明有调用 setAttribute往redis 放的时候永远设置为false</span><br><span class="line">                ss.setChanged(false);</span><br><span class="line">            &#125;</span><br><span class="line">            this.saveSession(session);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.warn(&quot;update Session is failed&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * save session</span><br><span class="line">     *</span><br><span class="line">     * @param session</span><br><span class="line">     * @throws UnknownSessionException</span><br><span class="line">     */</span><br><span class="line">    private void saveSession(Session session) throws UnknownSessionException &#123;</span><br><span class="line">        if (session == null || session.getId() == null) &#123;</span><br><span class="line">            logger.error(&quot;session or session id is null&quot;);</span><br><span class="line">            throw new UnknownSessionException(&quot;session or session id is null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        String key = getRedisSessionKey(session.getId());</span><br><span class="line">        if (expire == DEFAULT_EXPIRE) &#123;</span><br><span class="line">            this.redisManager.set(key, session, (int) (session.getTimeout() / MILLISECONDS_IN_A_SECOND));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (expire != NO_EXPIRE &amp;&amp; expire * MILLISECONDS_IN_A_SECOND &lt; session.getTimeout()) &#123;</span><br><span class="line">            logger.warn(&quot;Redis session expire time: &quot;</span><br><span class="line">                    + (expire * MILLISECONDS_IN_A_SECOND)</span><br><span class="line">                    + &quot; is less than Session timeout: &quot;</span><br><span class="line">                    + session.getTimeout()</span><br><span class="line">                    + &quot; . It may cause some problems.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.redisManager.set(key, session, expire);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void delete(Session session) &#123;</span><br><span class="line">        if (session == null || session.getId() == null) &#123;</span><br><span class="line">            logger.error(&quot;session or session id is null&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            redisManager.del(getRedisSessionKey(session.getId()));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;delete session error. session id= &#123;&#125;&quot;, session.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Collection&lt;Session&gt; getActiveSessions() &#123;</span><br><span class="line">        Set&lt;Session&gt; sessions = new HashSet&lt;Session&gt;();</span><br><span class="line">        try &#123;</span><br><span class="line">            Set&lt;String&gt; keys = redisManager.scan(this.keyPrefix + &quot;*&quot;);</span><br><span class="line">            if (keys != null &amp;&amp; keys.size() &gt; 0) &#123;</span><br><span class="line">                for (String key : keys) &#123;</span><br><span class="line">                    Session s = (Session) redisManager.get(key);</span><br><span class="line">                    sessions.add(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;get active sessions error.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return sessions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long getActiveSessionsSize() &#123;</span><br><span class="line">        Long size = 0L;</span><br><span class="line">        try &#123;</span><br><span class="line">            size = redisManager.scanSize(this.keyPrefix + &quot;*&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;get active sessions error.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Serializable doCreate(Session session) &#123;</span><br><span class="line">        if (session == null) &#123;</span><br><span class="line">            logger.error(&quot;session is null&quot;);</span><br><span class="line">            throw new UnknownSessionException(&quot;session is null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Serializable sessionId = this.generateSessionId(session);</span><br><span class="line">        this.assignSessionId(session, sessionId);</span><br><span class="line">        this.saveSession(session);</span><br><span class="line">        return sessionId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Session doReadSession(Serializable sessionId) &#123;</span><br><span class="line">        if (sessionId == null) &#123;</span><br><span class="line">            logger.warn(&quot;session id is null&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //线程缓存中获取sessionId</span><br><span class="line">        Session s = getSessionFromThreadLocal(sessionId);</span><br><span class="line">        if (s != null) &#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        logger.debug(&quot;read session from redis&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            s = (Session) redisManager.get(getRedisSessionKey(sessionId));</span><br><span class="line">            setSessionToThreadLocal(sessionId, s);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;read session error. settionId= &#123;&#125;&quot;, sessionId);</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setSessionToThreadLocal(Serializable sessionId, Session s) &#123;</span><br><span class="line">        Map&lt;Serializable, SessionInMemory&gt; sessionMap = (Map&lt;Serializable, SessionInMemory&gt;) sessionsInThread.get();</span><br><span class="line">        if (sessionMap == null) &#123;</span><br><span class="line">            sessionMap = new HashMap&lt;Serializable, SessionInMemory&gt;();</span><br><span class="line">            sessionsInThread.set(sessionMap);</span><br><span class="line">        &#125;</span><br><span class="line">        SessionInMemory sessionInMemory = new SessionInMemory();</span><br><span class="line">        sessionInMemory.setCreateTime(new Date());</span><br><span class="line">        sessionInMemory.setSession(s);</span><br><span class="line">        sessionMap.put(sessionId, sessionInMemory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Session getSessionFromThreadLocal(Serializable sessionId) &#123;</span><br><span class="line">        Session s = null;</span><br><span class="line">        if (sessionsInThread.get() == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Serializable, SessionInMemory&gt; sessionMap = (Map&lt;Serializable, SessionInMemory&gt;) sessionsInThread.get();</span><br><span class="line">        SessionInMemory sessionInMemory = sessionMap.get(sessionId);</span><br><span class="line">        if (sessionInMemory == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Date now = new Date();</span><br><span class="line">        long duration = now.getTime() - sessionInMemory.getCreateTime().getTime();</span><br><span class="line">        if (duration &lt; sessionInMemoryTimeout) &#123;</span><br><span class="line">            s = sessionInMemory.getSession();</span><br><span class="line">            logger.debug(&quot;read session from memory&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sessionMap.remove(sessionId);</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private String getRedisSessionKey(Serializable sessionId) &#123;</span><br><span class="line">        return this.keyPrefix + sessionId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RedisManager getRedisManager() &#123;</span><br><span class="line">        return redisManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRedisManager(RedisManager redisManager) &#123;</span><br><span class="line">        this.redisManager = redisManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getKeyPrefix() &#123;</span><br><span class="line">        return keyPrefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setKeyPrefix(String keyPrefix) &#123;</span><br><span class="line">        this.keyPrefix = keyPrefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getSessionInMemoryTimeout() &#123;</span><br><span class="line">        return sessionInMemoryTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSessionInMemoryTimeout(long sessionInMemoryTimeout) &#123;</span><br><span class="line">        this.sessionInMemoryTimeout = sessionInMemoryTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getExpire() &#123;</span><br><span class="line">        return expire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setExpire(int expire) &#123;</span><br><span class="line">        this.expire = expire;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="shiro配置"><a href="#shiro配置" class="headerlink" title="shiro配置"></a>shiro配置</h2><h3 id="ShiroConfig"><a href="#ShiroConfig" class="headerlink" title="ShiroConfig"></a>ShiroConfig</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.panghu.config;</span><br><span class="line"></span><br><span class="line">import com.panghu.reids.RedisCacheManager;</span><br><span class="line">import com.panghu.reids.RedisManager;</span><br><span class="line">import com.panghu.reids.RedisSessionDAO;</span><br><span class="line">import com.panghu.shiro.*;</span><br><span class="line">import org.apache.shiro.mgt.SecurityManager;</span><br><span class="line">import org.apache.shiro.session.SessionListener;</span><br><span class="line">import org.apache.shiro.session.mgt.SessionManager;</span><br><span class="line">import org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator;</span><br><span class="line">import org.apache.shiro.session.mgt.eis.SessionDAO;</span><br><span class="line">import org.apache.shiro.session.mgt.eis.SessionIdGenerator;</span><br><span class="line">import org.apache.shiro.spring.LifecycleBeanPostProcessor;</span><br><span class="line">import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;</span><br><span class="line">import org.apache.shiro.spring.web.ShiroFilterFactoryBean;</span><br><span class="line">import org.apache.shiro.web.filter.authc.FormAuthenticationFilter;</span><br><span class="line">import org.apache.shiro.web.mgt.DefaultWebSecurityManager;</span><br><span class="line">import org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line">import org.springframework.beans.factory.config.MethodInvokingFactoryBean;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.handler.SimpleMappingExceptionResolver;</span><br><span class="line"></span><br><span class="line">import javax.servlet.Filter;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.LinkedHashMap;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: nacos_base4j</span><br><span class="line"> * @Package: com.panghu.config</span><br><span class="line"> * @ClassName: ShiroConfig</span><br><span class="line"> * @Author: wxy</span><br><span class="line"> * @Description: shiro配置</span><br><span class="line"> * @Date: 2020/5/5 14:19</span><br><span class="line"> * @Version: 1.0</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class ShiroConfig &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @Description: 过滤器配置</span><br><span class="line">     * @Param: [securityManager]</span><br><span class="line">     * @return: org.apache.shiro.spring.web.ShiroFilterFactoryBean</span><br><span class="line">     * @Author: Mr.Wei</span><br><span class="line">     * @Date: 2020/5/19</span><br><span class="line">     */</span><br><span class="line">    @Bean(name = &quot;shirFilter&quot;)</span><br><span class="line">    public ShiroFilterFactoryBean shirFilter(@Qualifier(&quot;securityManager&quot;) SecurityManager securityManager) &#123;</span><br><span class="line">        System.out.println(&quot;ShiroConfiguration.shirFilter()&quot;);</span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();</span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        // 如果不设置默认会自动寻找Web工程根目录下的&quot;/login.jsp&quot;页面,设置的话没经过验证会发送test请求到控制器，由控制器决定转到对应视图</span><br><span class="line">//        shiroFilterFactoryBean.setLoginUrl(&quot;/login&quot;);</span><br><span class="line">        // 登录成功后要跳转的链接url</span><br><span class="line">//        shiroFilterFactoryBean.setSuccessUrl(&quot;/index&quot;);</span><br><span class="line">        //未授权界面,该配置无效，并不会进行页面跳转</span><br><span class="line">        shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/unauthorized&quot;);</span><br><span class="line"></span><br><span class="line">        //自定义拦截器限制并发人数,参考博客：</span><br><span class="line">        LinkedHashMap&lt;String, Filter&gt; filtersMap = new LinkedHashMap&lt;&gt;();</span><br><span class="line">        //限制同一帐号同时在线的个数</span><br><span class="line">//        filtersMap.put(&quot;kickout&quot;, kickoutSessionControlFilter());</span><br><span class="line">        //统计登录人数</span><br><span class="line">        shiroFilterFactoryBean.setFilters(filtersMap);</span><br><span class="line"></span><br><span class="line">        // 配置访问权限 必须是LinkedHashMap，因为它必须保证有序</span><br><span class="line">        // 过滤链定义，从上向下顺序执行，一般将 /**放在最为下边 --&gt; : 这是一个坑，一不小心代码就不好使了</span><br><span class="line">        LinkedHashMap&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;();</span><br><span class="line">        //配置不登录可以访问的资源，anon 表示资源都可以匿名访问</span><br><span class="line">        //配置记住我或认证通过可以访问的地址</span><br><span class="line">//        filterChainDefinitionMap.put(&quot;/login&quot;, &quot;anon&quot;);</span><br><span class="line">        filterChainDefinitionMap.put(&quot;/&quot;, &quot;anon&quot;);</span><br><span class="line">        filterChainDefinitionMap.put(&quot;/druid/**&quot;, &quot;anon&quot;);</span><br><span class="line">        //解锁用户专用 测试用的</span><br><span class="line">        filterChainDefinitionMap.put(&quot;/unlockAccount&quot;, &quot;anon&quot;);</span><br><span class="line">        filterChainDefinitionMap.put(&quot;/Captcha.jpg&quot;, &quot;anon&quot;);</span><br><span class="line">        //logout是shiro提供的过滤器</span><br><span class="line">        filterChainDefinitionMap.put(&quot;/logout&quot;, &quot;logout&quot;);</span><br><span class="line">        //此时访问/user/delete需要delete权限,在自定义Realm中为用户授权。</span><br><span class="line">        //filterChainDefinitionMap.put(&quot;/user/delete&quot;, &quot;perms[\&quot;user:delete\&quot;]&quot;);</span><br><span class="line">        //其他资源都需要认证  authc 表示需要认证才能进行访问 user表示配置记住我或认证通过可以访问的地址</span><br><span class="line">        //如果开启限制同一账号登录,改为 .put(&quot;/**&quot;, &quot;kickout,user&quot;);</span><br><span class="line">//        filterChainDefinitionMap.put(&quot;/**&quot;, &quot;kickout,user&quot;);</span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">        return shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @Description: 配置核心安全事务管理器</span><br><span class="line">     * @Param: []</span><br><span class="line">     * @return: org.apache.shiro.mgt.SecurityMasnager</span><br><span class="line">     * @Author: Mr.Wei</span><br><span class="line">     * @Date: 2020/5/17</span><br><span class="line">     */</span><br><span class="line">    @Bean(name = &quot;securityManager&quot;)</span><br><span class="line">    public SecurityManager securityManager() &#123;</span><br><span class="line">        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();</span><br><span class="line">        //自定义权限方法和权限方法</span><br><span class="line">        securityManager.setRealm(shiroRealm());</span><br><span class="line">        // 自定义session管理 使用redis</span><br><span class="line">        securityManager.setSessionManager(sessionManager());</span><br><span class="line">        // 自定义缓存实现 使用redis</span><br><span class="line">        securityManager.setCacheManager(redisCacheManager());</span><br><span class="line">        return securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @Description: 自定义权限/密码验证方式</span><br><span class="line">     * @Param: []</span><br><span class="line">     * @return: com.panghu.shiro.MyShiroRealm</span><br><span class="line">     * @Author: Mr.Wei</span><br><span class="line">     * @Date: 2020/5/17</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public ShiroRealm shiroRealm() &#123;</span><br><span class="line">        ShiroRealm shiroRealm = new ShiroRealm();</span><br><span class="line">        //启用全局缓存</span><br><span class="line">        shiroRealm.setCachingEnabled(true);</span><br><span class="line">        //启用身份验证缓存，即缓存AuthenticationInfo信息，默认false</span><br><span class="line">        shiroRealm.setAuthenticationCachingEnabled(true);</span><br><span class="line">        //缓存AuthenticationInfo信息的缓存名称 在ehcache-shiro.xml中有对应缓存的配置</span><br><span class="line">        shiroRealm.setAuthenticationCacheName(&quot;authenticationCache&quot;);</span><br><span class="line">        //启用授权缓存，即缓存AuthorizationInfo信息，默认false</span><br><span class="line">        shiroRealm.setAuthorizationCachingEnabled(true);</span><br><span class="line">        //缓存AuthorizationInfo信息的缓存名称  在ehcache-shiro.xml中有对应缓存的配置</span><br><span class="line">        shiroRealm.setAuthorizationCacheName(&quot;authorizationCache&quot;);</span><br><span class="line">        //设置自定义密码匹配</span><br><span class="line">        shiroRealm.setCredentialsMatcher(retryLimitHashedCredentialsMatcher());</span><br><span class="line">        return shiroRealm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置Shiro生命周期处理器</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean(name = &quot;lifecycleBeanPostProcessor&quot;)</span><br><span class="line">    public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() &#123;</span><br><span class="line">        return new LifecycleBeanPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 开启shiro aop注解支持.</span><br><span class="line">     * 使用代理方式;所以需要开启代码支持;</span><br><span class="line">     *</span><br><span class="line">     * @param securityManager</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) &#123;</span><br><span class="line">        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor();</span><br><span class="line">        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line">        return authorizationAttributeSourceAdvisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解决： 无权限页面不跳转 shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/unauthorized&quot;) 无效</span><br><span class="line">     * shiro的源代码ShiroFilterFactoryBean.Java定义的filter必须满足filter instanceof AuthorizationFilter，</span><br><span class="line">     * 只有perms，roles，ssl，rest，port才是属于AuthorizationFilter，而anon，authcBasic，auchc，user是AuthenticationFilter，</span><br><span class="line">     * 所以unauthorizedUrl设置后页面不跳转 Shiro注解模式下，登录失败与没有权限都是通过抛出异常。</span><br><span class="line">     * 并且默认并没有去处理或者捕获这些异常。在SpringMVC下需要配置捕获相应异常来通知用户信息</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public SimpleMappingExceptionResolver simpleMappingExceptionResolver() &#123;</span><br><span class="line">        SimpleMappingExceptionResolver simpleMappingExceptionResolver = new SimpleMappingExceptionResolver();</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        //这里的 /unauthorized 是页面，不是访问的路径</span><br><span class="line">        properties.setProperty(&quot;org.apache.shiro.authz.UnauthorizedException&quot;, &quot;/unauthorized&quot;);</span><br><span class="line">        properties.setProperty(&quot;org.apache.shiro.authz.UnauthenticatedException&quot;, &quot;/unauthorized&quot;);</span><br><span class="line">        simpleMappingExceptionResolver.setExceptionMappings(properties);</span><br><span class="line">        return simpleMappingExceptionResolver;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * FormAuthenticationFilter 过滤器 过滤记住我</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public FormAuthenticationFilter formAuthenticationFilter() &#123;</span><br><span class="line">        FormAuthenticationFilter formAuthenticationFilter = new FormAuthenticationFilter();</span><br><span class="line">        //对应前端的checkbox的name = rememberMe</span><br><span class="line">        formAuthenticationFilter.setRememberMeParam(&quot;rememberMe&quot;);</span><br><span class="line">        return formAuthenticationFilter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * shiro缓存管理器;</span><br><span class="line">     * 需要添加到securityManager中</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public RedisCacheManager redisCacheManager() &#123;</span><br><span class="line">        RedisCacheManager redisCacheManager = new RedisCacheManager();</span><br><span class="line">        redisCacheManager.setRedisManager(redisManager());</span><br><span class="line">        //redis中针对不同用户缓存</span><br><span class="line">        redisCacheManager.setPrincipalIdFieldName(&quot;username&quot;);</span><br><span class="line">        //用户权限信息缓存时间</span><br><span class="line">        redisCacheManager.setExpire(200000);</span><br><span class="line">        return redisCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 让某个实例的某个方法的返回值注入为Bean的实例</span><br><span class="line">     * Spring静态注入</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public MethodInvokingFactoryBean getMethodInvokingFactoryBean() &#123;</span><br><span class="line">        MethodInvokingFactoryBean factoryBean = new MethodInvokingFactoryBean();</span><br><span class="line">        factoryBean.setStaticMethod(&quot;org.apache.shiro.SecurityUtils.setSecurityManager&quot;);</span><br><span class="line">        factoryBean.setArguments(new Object[]&#123;securityManager()&#125;);</span><br><span class="line">        return factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置session监听</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean(&quot;sessionListener&quot;)</span><br><span class="line">    public ShiroSessionListener sessionListener() &#123;</span><br><span class="line">        ShiroSessionListener sessionListener = new ShiroSessionListener();</span><br><span class="line">        return sessionListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置会话ID生成器</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public SessionIdGenerator sessionIdGenerator() &#123;</span><br><span class="line">        return new JavaUuidSessionIdGenerator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisManager redisManager() &#123;</span><br><span class="line">        RedisManager redisManager = new RedisManager();</span><br><span class="line">        return redisManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;sessionFactory&quot;)</span><br><span class="line">    public ShiroSessionFactory sessionFactory() &#123;</span><br><span class="line">        ShiroSessionFactory sessionFactory = new ShiroSessionFactory();</span><br><span class="line">        return sessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * SessionDAO的作用是为Session提供CRUD并进行持久化的一个shiro组件</span><br><span class="line">     * MemorySessionDAO 直接在内存中进行会话维护</span><br><span class="line">     * EnterpriseCacheSessionDAO  提供了缓存功能的会话维护，默认情况下使用MapCache实现，内部使用ConcurrentHashMap保存缓存的会话。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public SessionDAO sessionDAO() &#123;</span><br><span class="line">        RedisSessionDAO redisSessionDAO = new RedisSessionDAO();</span><br><span class="line">        redisSessionDAO.setRedisManager(redisManager());</span><br><span class="line">        redisSessionDAO.setSessionIdGenerator(sessionIdGenerator());</span><br><span class="line">        //session在redis中的保存时间,最好大于session会话超时时间</span><br><span class="line">        redisSessionDAO.setExpire(12000);</span><br><span class="line">        return redisSessionDAO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置会话管理器，设定会话超时及保存</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean(&quot;sessionManager&quot;)</span><br><span class="line">    public SessionManager sessionManager() &#123;</span><br><span class="line">        ShiroSessionManager sessionManager = new ShiroSessionManager();</span><br><span class="line">        Collection&lt;SessionListener&gt; listeners = new ArrayList&lt;SessionListener&gt;();</span><br><span class="line">        //配置监听</span><br><span class="line">        listeners.add(sessionListener());</span><br><span class="line">        sessionManager.setSessionListeners(listeners);</span><br><span class="line">//        sessionManager.setSessionIdCookie(sessionIdCookie());</span><br><span class="line">        sessionManager.setSessionDAO(sessionDAO());</span><br><span class="line">        sessionManager.setCacheManager(redisCacheManager());</span><br><span class="line">        sessionManager.setSessionFactory(sessionFactory());</span><br><span class="line">        //全局会话超时时间（单位毫秒），默认30分钟  暂时设置为10秒钟 用来测试</span><br><span class="line">        sessionManager.setGlobalSessionTimeout(1800000);</span><br><span class="line">        //是否开启删除无效的session对象  默认为true</span><br><span class="line">        sessionManager.setDeleteInvalidSessions(true);</span><br><span class="line">        //是否开启定时调度器进行检测过期session 默认为true</span><br><span class="line">        sessionManager.setSessionValidationSchedulerEnabled(true);</span><br><span class="line">        //设置session失效的扫描时间, 清理用户直接关闭浏览器造成的孤立会话 默认为 1个小时</span><br><span class="line">        //设置该属性 就不需要设置 ExecutorServiceSessionValidationScheduler 底层也是默认自动调用ExecutorServiceSessionValidationScheduler</span><br><span class="line">        //暂时设置为 5秒 用来测试</span><br><span class="line">        sessionManager.setSessionValidationInterval(3600000);</span><br><span class="line">        //取消url 后面的 JSESSIONID</span><br><span class="line">        sessionManager.setSessionIdUrlRewritingEnabled(false);</span><br><span class="line">        return sessionManager;</span><br><span class="line">    &#125;</span><br><span class="line">//    /**</span><br><span class="line">//     * 并发登录控制</span><br><span class="line">//     * @return</span><br><span class="line">//     */</span><br><span class="line">//    @Bean</span><br><span class="line">//    public KickoutSessionControlFilter kickoutSessionControlFilter()&#123;</span><br><span class="line">//        KickoutSessionControlFilter kickoutSessionControlFilter = new KickoutSessionControlFilter();</span><br><span class="line">//        //用于根据会话ID，获取会话进行踢出操作的；</span><br><span class="line">//        kickoutSessionControlFilter.setSessionManager(sessionManager());</span><br><span class="line">//        //使用cacheManager获取相应的cache来缓存用户登录的会话；用于保存用户—会话之间的关系的；</span><br><span class="line">//        kickoutSessionControlFilter.setRedisManager(redisManager());</span><br><span class="line">//        //是否踢出后来登录的，默认是false；即后者登录的用户踢出前者登录的用户；</span><br><span class="line">//        kickoutSessionControlFilter.setKickoutAfter(false);</span><br><span class="line">//        //同一个用户最大的会话数，默认1；比如2的意思是同一个用户允许最多同时两个人登录；</span><br><span class="line">//        kickoutSessionControlFilter.setMaxSession(1);</span><br><span class="line">//        //被踢出后重定向到的地址；</span><br><span class="line">////        kickoutSessionControlFilter.setKickoutUrl(&quot;/login?kickout=1&quot;);</span><br><span class="line">//        return kickoutSessionControlFilter;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置密码比较器</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean(&quot;credentialsMatcher&quot;)</span><br><span class="line">    public RetryLimitHashedCredentialsMatcher retryLimitHashedCredentialsMatcher()&#123;</span><br><span class="line">        RetryLimitHashedCredentialsMatcher retryLimitHashedCredentialsMatcher = new RetryLimitHashedCredentialsMatcher();</span><br><span class="line">        retryLimitHashedCredentialsMatcher.setRedisManager(redisManager());</span><br><span class="line">        //如果密码加密,可以打开下面配置</span><br><span class="line">        //加密算法的名称</span><br><span class="line">        //retryLimitHashedCredentialsMatcher.setHashAlgorithmName(&quot;MD5&quot;);</span><br><span class="line">        //配置加密的次数</span><br><span class="line">        //retryLimitHashedCredentialsMatcher.setHashIterations(1024);</span><br><span class="line">        //是否存储为16进制</span><br><span class="line">        //retryLimitHashedCredentialsMatcher.setStoredCredentialsHexEncoded(true);</span><br><span class="line">        return retryLimitHashedCredentialsMatcher;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ShiroRealm"><a href="#ShiroRealm" class="headerlink" title="ShiroRealm"></a><strong>ShiroRealm</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.panghu.shiro;</span><br><span class="line"></span><br><span class="line">import com.panghu.dao.SysUserDao;</span><br><span class="line">import com.panghu.entity.SysRole;</span><br><span class="line">import com.panghu.entity.SysUser;</span><br><span class="line">import com.panghu.global.MyByteSource;</span><br><span class="line">import org.apache.shiro.authc.AuthenticationInfo;</span><br><span class="line">import org.apache.shiro.authc.AuthenticationToken;</span><br><span class="line">import org.apache.shiro.authc.SimpleAuthenticationInfo;</span><br><span class="line">import org.apache.shiro.authz.AuthorizationInfo;</span><br><span class="line">import org.apache.shiro.authz.SimpleAuthorizationInfo;</span><br><span class="line">import org.apache.shiro.realm.AuthorizingRealm;</span><br><span class="line">import org.apache.shiro.subject.PrincipalCollection;</span><br><span class="line">import org.apache.shiro.util.ByteSource;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: nacos_base4j</span><br><span class="line"> * @Package: com.panghu</span><br><span class="line"> * @ClassName: MyShiroRealm</span><br><span class="line"> * @Author: wxy</span><br><span class="line"> * @Description: 拦截实现</span><br><span class="line"> * @Date: 2020/5/5 14:23</span><br><span class="line"> * @Version: 1.0</span><br><span class="line"> */</span><br><span class="line">public class ShiroRealm extends AuthorizingRealm &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SysUserDao userDao;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @Description: 用户权限配置</span><br><span class="line">     * @Param: [principals]</span><br><span class="line">     * @return: org.apache.shiro.authz.AuthorizationInfo</span><br><span class="line">     * @Author: Mr.Wei</span><br><span class="line">     * @Date: 2020/5/19</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;</span><br><span class="line">        System.out.println(&quot;权限调用方法开始&quot;);</span><br><span class="line">        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();</span><br><span class="line">        SysUser userInfo = (SysUser) principals.getPrimaryPrincipal();</span><br><span class="line">        for (SysRole role : userInfo.getRoles()) &#123;</span><br><span class="line">            authorizationInfo.addRoles(new ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">            authorizationInfo.addStringPermission(&quot;321&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return authorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @Description: 身份验证</span><br><span class="line">     * @Param: [token]</span><br><span class="line">     * @return: org.apache.shiro.authc.AuthenticationInfo</span><br><span class="line">     * @Author: Mr.Wei</span><br><span class="line">     * @Date: 2020/5/5</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) &#123;</span><br><span class="line">        System.out.println(&quot;MyShiroRealm.doGetAuthenticationInfo()&quot;);</span><br><span class="line"></span><br><span class="line">        // 获取用户的输入的账号.</span><br><span class="line">        String name = (String) token.getPrincipal();</span><br><span class="line">        System.out.println(token.getCredentials());</span><br><span class="line"></span><br><span class="line">        // 通过name和password从数据库中查找 User对象，</span><br><span class="line">        SysUser userInfo = userDao.findByAccount(name);</span><br><span class="line">        if (userInfo == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String uid = userInfo.getId();</span><br><span class="line">//        List&lt;Role&gt; roles = userService.getRoles(uid);</span><br><span class="line">//        int roleId = roles.get(0).getId();</span><br><span class="line">//        List&lt;Permission&gt; permissions = userService.getPermissions(roleId);</span><br><span class="line">//        roles.get(0).setPermissions(permissions);</span><br><span class="line">//        userInfo.setRoleList(roles);</span><br><span class="line">        // 加密方式;</span><br><span class="line">        // 交给AuthenticatingRealm使用CredentialsMatcher进行密码匹配</span><br><span class="line">        String password = userInfo.getPassword();</span><br><span class="line">        // 秘钥</span><br><span class="line">        ByteSource salt = ByteSource.Util.bytes(userInfo.getAccount());</span><br><span class="line">        // 当前域的名称（MyShiroRealm）</span><br><span class="line">        String realmName = getName();</span><br><span class="line">        // 认证信息</span><br><span class="line">//        SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(userInfo.getAccount(), password, salt, realmName);</span><br><span class="line">        SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(userInfo, userInfo.getPassword(), new MyByteSource(userInfo.getUserName()), getName());</span><br><span class="line"></span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ShiroSession"><a href="#ShiroSession" class="headerlink" title="ShiroSession"></a>ShiroSession</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.panghu.shiro;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.session.InvalidSessionException;</span><br><span class="line">import org.apache.shiro.session.mgt.SimpleSession;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: nacos_base4j</span><br><span class="line"> * @Package: com.panghu.shiro</span><br><span class="line"> * @ClassName: ShiroSession</span><br><span class="line"> * @Author: wxy</span><br><span class="line"> * @Description: session 由于SimpleSession lastAccessTime更改后也会调用SessionDao update方法，</span><br><span class="line"> * 增加标识位，如果只是更新lastAccessTime SessionDao update方法直接返回</span><br><span class="line"> * @Date: 2020/5/19 10:39</span><br><span class="line"> * @Version: 1.0</span><br><span class="line"> */</span><br><span class="line">public class ShiroSession extends SimpleSession implements Serializable &#123;</span><br><span class="line">    // 除lastAccessTime以外其他字段发生改变时为true</span><br><span class="line">    private boolean isChanged = false;</span><br><span class="line"></span><br><span class="line">//    private String id = &quot;init&quot;;</span><br><span class="line"></span><br><span class="line">    public ShiroSession() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.setChanged(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ShiroSession(String host) &#123;</span><br><span class="line">        super(host);</span><br><span class="line">        this.setChanged(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setId(Serializable id) &#123;</span><br><span class="line">        super.setId(id);</span><br><span class="line">        this.setChanged(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setStopTimestamp(Date stopTimestamp) &#123;</span><br><span class="line">        super.setStopTimestamp(stopTimestamp);</span><br><span class="line">        this.setChanged(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setExpired(boolean expired) &#123;</span><br><span class="line">        super.setExpired(expired);</span><br><span class="line">        this.setChanged(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setTimeout(long timeout) &#123;</span><br><span class="line">        super.setTimeout(timeout);</span><br><span class="line">        this.setChanged(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setHost(String host) &#123;</span><br><span class="line">        super.setHost(host);</span><br><span class="line">        this.setChanged(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setAttributes(Map&lt;Object, Object&gt; attributes) &#123;</span><br><span class="line">        super.setAttributes(attributes);</span><br><span class="line">        this.setChanged(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setAttribute(Object key, Object value) &#123;</span><br><span class="line">        super.setAttribute(key, value);</span><br><span class="line">        this.setChanged(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object removeAttribute(Object key) &#123;</span><br><span class="line">        this.setChanged(true);</span><br><span class="line">        return super.removeAttribute(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 停止</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        super.stop();</span><br><span class="line">        this.setChanged(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置过期</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void expire() &#123;</span><br><span class="line">        this.stop();</span><br><span class="line">        this.setExpired(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isChanged() &#123;</span><br><span class="line">        return isChanged;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setChanged(boolean isChanged) &#123;</span><br><span class="line">        this.isChanged = isChanged;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object obj) &#123;</span><br><span class="line">        return super.equals(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean onEquals(SimpleSession ss) &#123;</span><br><span class="line">        return super.onEquals(ss);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return super.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return super.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Serializable getId() &#123;</span><br><span class="line">        return super.getId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Date getStartTimestamp() &#123;</span><br><span class="line">        return super.getStartTimestamp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setStartTimestamp(Date startTimestamp) &#123;</span><br><span class="line">        super.setStartTimestamp(startTimestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Date getStopTimestamp() &#123;</span><br><span class="line">        return super.getStopTimestamp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Date getLastAccessTime() &#123;</span><br><span class="line">        return super.getLastAccessTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setLastAccessTime(Date lastAccessTime) &#123;</span><br><span class="line">        super.setLastAccessTime(lastAccessTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isExpired() &#123;</span><br><span class="line">        return super.isExpired();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long getTimeout() &#123;</span><br><span class="line">        return super.getTimeout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getHost() &#123;</span><br><span class="line">        return super.getHost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Map&lt;Object, Object&gt; getAttributes() &#123;</span><br><span class="line">        return super.getAttributes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void touch() &#123;</span><br><span class="line">        super.touch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean isStopped() &#123;</span><br><span class="line">        return super.isStopped();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isValid() &#123;</span><br><span class="line">        return super.isValid();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean isTimedOut() &#123;</span><br><span class="line">        return super.isTimedOut();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void validate() throws InvalidSessionException &#123;</span><br><span class="line">        super.validate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Collection&lt;Object&gt; getAttributeKeys() throws InvalidSessionException &#123;</span><br><span class="line">        return super.getAttributeKeys();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object getAttribute(Object key) &#123;</span><br><span class="line">        return super.getAttribute(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ShiroSessionFactory"><a href="#ShiroSessionFactory" class="headerlink" title="ShiroSessionFactory"></a>ShiroSessionFactory</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.panghu.shiro;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.lang3.StringUtils;</span><br><span class="line">import org.apache.shiro.session.Session;</span><br><span class="line">import org.apache.shiro.session.mgt.SessionContext;</span><br><span class="line">import org.apache.shiro.session.mgt.SessionFactory;</span><br><span class="line">import org.apache.shiro.web.session.mgt.DefaultWebSessionContext;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: nacos_base4j</span><br><span class="line"> * @Package: com.panghu.shiro</span><br><span class="line"> * @ClassName: ShiroSessionFactory</span><br><span class="line"> * @Author: wxy</span><br><span class="line"> * @Description: sessionFactory</span><br><span class="line"> * @Date: 2020/5/19 17:03</span><br><span class="line"> * @Version: 1.0</span><br><span class="line"> */</span><br><span class="line">public class ShiroSessionFactory implements SessionFactory &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(ShiroSessionFactory.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Session createSession(SessionContext initData) &#123;</span><br><span class="line">        ShiroSession session = new ShiroSession();</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest)initData.get(DefaultWebSessionContext.class.getName() + &quot;.SERVLET_REQUEST&quot;);</span><br><span class="line">        session.setHost(getIpAddress(request));</span><br><span class="line">        return session;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getIpAddress(HttpServletRequest request) &#123;</span><br><span class="line">        String localIP = &quot;127.0.0.1&quot;;</span><br><span class="line">        String ip = request.getHeader(&quot;x-forwarded-for&quot;);</span><br><span class="line">        if (StringUtils.isBlank(ip) || (ip.equalsIgnoreCase(localIP)) || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (StringUtils.isBlank(ip) || (ip.equalsIgnoreCase(localIP)) || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (StringUtils.isBlank(ip) || (ip.equalsIgnoreCase(localIP)) || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line">        return ip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ShiroSessionListener"><a href="#ShiroSessionListener" class="headerlink" title="ShiroSessionListener"></a>ShiroSessionListener</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: nacos_base4j</span><br><span class="line"> * @Package: com.panghu.shiro</span><br><span class="line"> * @ClassName: ShiroSessionListener</span><br><span class="line"> * @Author: wxy</span><br><span class="line"> * @Description: 在线人数监听</span><br><span class="line"> * @Date: 2020/5/19 16:57</span><br><span class="line"> * @Version: 1.0</span><br><span class="line"> */</span><br><span class="line">public class ShiroSessionListener implements SessionListener &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 统计在线人数</span><br><span class="line">     * juc包下线程安全自增</span><br><span class="line">     */</span><br><span class="line">    private final AtomicInteger sessionCount = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 会话创建时触发</span><br><span class="line">     *</span><br><span class="line">     * @param session</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void onStart(Session session) &#123;</span><br><span class="line">        //会话创建，在线人数加一</span><br><span class="line">        sessionCount.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 退出会话时触发</span><br><span class="line">     *</span><br><span class="line">     * @param session</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void onStop(Session session) &#123;</span><br><span class="line">        //会话退出,在线人数减一</span><br><span class="line">        sessionCount.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 会话过期时触发</span><br><span class="line">     *</span><br><span class="line">     * @param session</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void onExpiration(Session session) &#123;</span><br><span class="line">        //会话过期,在线人数减一</span><br><span class="line">        sessionCount.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取在线人数使用</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public AtomicInteger getSessionCount() &#123;</span><br><span class="line">        return sessionCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ShiroSessionManager"><a href="#ShiroSessionManager" class="headerlink" title="ShiroSessionManager"></a>ShiroSessionManager</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.panghu.shiro;</span><br><span class="line"></span><br><span class="line">import com.panghu.reids.RedisSessionDAO;</span><br><span class="line">import org.apache.shiro.session.Session;</span><br><span class="line">import org.apache.shiro.session.UnknownSessionException;</span><br><span class="line">import org.apache.shiro.session.mgt.SessionKey;</span><br><span class="line">import org.apache.shiro.session.mgt.eis.SessionDAO;</span><br><span class="line">import org.apache.shiro.web.session.mgt.DefaultWebSessionManager;</span><br><span class="line">import org.apache.shiro.web.session.mgt.WebSessionKey;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: nacos_base4j</span><br><span class="line"> * @Package: com.panghu.shiro</span><br><span class="line"> * @ClassName: ShiroSessionManager</span><br><span class="line"> * @Author: wxy</span><br><span class="line"> * @Description: session管理</span><br><span class="line"> * @Date: 2020/5/19 17:01</span><br><span class="line"> * @Version: 1.0</span><br><span class="line"> */</span><br><span class="line">public class ShiroSessionManager extends DefaultWebSessionManager &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(DefaultWebSessionManager.class);</span><br><span class="line">    /**</span><br><span class="line">     * 获取session</span><br><span class="line">     * 优化单次请求需要多次访问redis的问题</span><br><span class="line">     * @param sessionKey</span><br><span class="line">     * @return</span><br><span class="line">             * @throws UnknownSessionException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected Session retrieveSession(SessionKey sessionKey) throws UnknownSessionException &#123;</span><br><span class="line">        Serializable sessionId = getSessionId(sessionKey);</span><br><span class="line"></span><br><span class="line">        ServletRequest request = null;</span><br><span class="line">        if (sessionKey instanceof WebSessionKey) &#123;</span><br><span class="line">            request = ((WebSessionKey) sessionKey).getServletRequest();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (request != null &amp;&amp; null != sessionId) &#123;</span><br><span class="line">            Object sessionObj = request.getAttribute(sessionId.toString());</span><br><span class="line">            if (sessionObj != null) &#123;</span><br><span class="line">                logger.debug(&quot;read session from request&quot;);</span><br><span class="line">                return (Session) sessionObj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Session session = super.retrieveSession(sessionKey);</span><br><span class="line">        if (request != null &amp;&amp; null != sessionId) &#123;</span><br><span class="line">            request.setAttribute(sessionId.toString(), session);</span><br><span class="line">        &#125;</span><br><span class="line">        return session;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring cloud alibaba</category>
      </categories>
      <tags>
        <tag>spring cloud alibaba</tag>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/04/15/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉树简介"><a href="#二叉树简介" class="headerlink" title="二叉树简介"></a><strong>二叉树简介</strong></h1><p>　二叉树是由n（n&gt;=0）个结点组成的有序集合，集合或者为空，或者是由一个根节点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。</p>
<h3 id="二叉树的特性"><a href="#二叉树的特性" class="headerlink" title="二叉树的特性"></a>二叉树的特性</h3><p>A、在二叉树的第i层上最多有2^(i-1)个结点（i&gt;=1）。<br>B、高度为k的二叉树，最多有2^k-1个结点（k&gt;=0）。<br>C、对任何一棵二叉树，如果其叶结点有n个，度为2的非叶子结点有m个，则<br>n = m + 1。<br>D、具有n个结点的完全二叉树的高度为logn + 1<br>E、对于有n个结点的完全二叉树，按层次对结点进行编号（从上到下，从左到右）</p>
<h1 id="二叉树遍历方法"><a href="#二叉树遍历方法" class="headerlink" title="二叉树遍历方法"></a>二叉树遍历方法</h1><p>java中二叉树的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left, right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的构造方法"><a href="#二叉树的构造方法" class="headerlink" title="二叉树的构造方法"></a>二叉树的构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">constructTree</span><span class="params">(LinkedList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode rootNode = <span class="keyword">new</span> TreeNode(list.get(<span class="number">0</span>));<span class="comment">//根节点</span></span><br><span class="line">    LinkedList&lt;TreeNode&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">// 遍历节点</span></span><br><span class="line">    linkedList.add(rootNode);</span><br><span class="line">    list.removeFirst();</span><br><span class="line">    Boolean nodeFlag = <span class="keyword">false</span>; <span class="comment">//该节点是否完成</span></span><br><span class="line">    TreeNode tempNode = rootNode;</span><br><span class="line">    <span class="keyword">while</span> (!CollectionUtils.isEmpty(linkedList) &amp;&amp; !CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">"#"</span>.equals(list.get(<span class="number">0</span>))) &#123;</span><br><span class="line">            TreeNode node = <span class="keyword">new</span> TreeNode(list.get(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span> (!nodeFlag) &#123;</span><br><span class="line">                tempNode.left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tempNode.right = node;</span><br><span class="line">            &#125;</span><br><span class="line">            linkedList.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        list.removeFirst();</span><br><span class="line">        <span class="keyword">if</span> (nodeFlag) &#123;</span><br><span class="line">            linkedList.removeFirst();</span><br><span class="line">            tempNode = linkedList.getFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        nodeFlag = !nodeFlag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rootNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">path</span><span class="params">(TreeNode rootNode, List&lt;String&gt; beforePath)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!ObjectUtils.isEmpty(rootNode)) &#123;</span><br><span class="line">          beforePath.add(rootNode.val);</span><br><span class="line">          path(rootNode.left, beforePath);</span><br><span class="line">          path(rootNode.right, beforePath);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">beforePath</span><span class="params">(TreeNode rootNode)</span> </span>&#123;</span><br><span class="line">       LinkedList&lt;TreeNode&gt; nodeLinkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (ObjectUtils.isEmpty(rootNode)) &#123;</span><br><span class="line">           <span class="keyword">return</span> path;</span><br><span class="line">       &#125;</span><br><span class="line">       TreeNode temp = rootNode;</span><br><span class="line">       <span class="keyword">while</span> (temp != <span class="keyword">null</span> || !CollectionUtils.isEmpty(nodeLinkedList)) &#123;</span><br><span class="line">           path.add(temp.val);</span><br><span class="line">           nodeLinkedList.add(temp);</span><br><span class="line">           temp=temp.left;</span><br><span class="line">           <span class="keyword">while</span>(temp==<span class="keyword">null</span>&amp;&amp; !CollectionUtils.isEmpty(nodeLinkedList))&#123;</span><br><span class="line">               temp=nodeLinkedList.removeLast().right;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> path;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">midPath</span><span class="params">(TreeNode rootNode, List&lt;String&gt; path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(rootNode)) &#123;</span><br><span class="line">        midPath(rootNode.left, path);</span><br><span class="line">        path.add(rootNode.val);</span><br><span class="line">        midPath(rootNode.right, path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归-1"><a href="#非递归-1" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">middlePath</span><span class="params">(TreeNode rootNode)</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;TreeNode&gt; nodeList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(rootNode!=<span class="keyword">null</span> || !CollectionUtils.isEmpty(nodeList))&#123;</span><br><span class="line">        nodeList.add(rootNode);</span><br><span class="line">        rootNode=rootNode.left;</span><br><span class="line">        <span class="keyword">while</span>(rootNode==<span class="keyword">null</span> &amp;&amp; !CollectionUtils.isEmpty(nodeList))&#123;</span><br><span class="line">            rootNode=nodeList.removeLast();</span><br><span class="line">            path.add(rootNode.val);</span><br><span class="line">            rootNode=rootNode.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void afterPath(TreeNode root, List&lt;String&gt; path) &#123;</span><br><span class="line">    if (root != null) &#123;</span><br><span class="line">        afterPath(root.left, path);</span><br><span class="line">        afterPath(root.right, path);</span><br><span class="line">        path.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归-2"><a href="#非递归-2" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">afterPath2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       LinkedList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       TreeNode flag = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">           nodes.add(root);</span><br><span class="line">           root = root.left;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (!CollectionUtils.isEmpty(nodes)) &#123;</span><br><span class="line">           root = nodes.removeLast();</span><br><span class="line">           <span class="keyword">if</span> (root.right == <span class="keyword">null</span> || root.right == flag) &#123;</span><br><span class="line">               path.add(root.val);</span><br><span class="line">               flag = root;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               nodes.add(root);</span><br><span class="line">               root = root.right;</span><br><span class="line">               <span class="comment">//左节点获取</span></span><br><span class="line">               <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   nodes.add(root);</span><br><span class="line">                   root = root.left;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> path;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; levelPath(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//层级点数</span></span><br><span class="line">    nodes.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!CollectionUtils.isEmpty(nodes)) &#123;</span><br><span class="line">        List&lt;String&gt; p = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        i = nodes.size();</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           root = nodes.removeFirst();</span><br><span class="line">           p.add(root.val);</span><br><span class="line">           i--;</span><br><span class="line">           <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               nodes.add(root.left);</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                nodes.add(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树的最大深度"><a href="#树的最大深度" class="headerlink" title="树的最大深度"></a>树的最大深度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(depth(root.left)+<span class="number">1</span>,depth(root.right)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">     <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> right = minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">    right = right == <span class="number">1</span> ? Integer.MAX_VALUE : right;</span><br><span class="line">    left = left == <span class="number">1</span> ? Integer.MAX_VALUE : left;</span><br><span class="line">    <span class="keyword">return</span> Math.min(right, left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><h3 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode temp = root.left;</span><br><span class="line">    root.left=root.right;</span><br><span class="line">    root.right=temp;</span><br><span class="line">    swap(root.left);</span><br><span class="line">    swap(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归-3"><a href="#非递归-3" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap2</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">      LinkedList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//层级点数</span></span><br><span class="line">      nodes.add(root);</span><br><span class="line">      <span class="keyword">while</span> (!CollectionUtils.isEmpty(nodes)) &#123;</span><br><span class="line">          i = nodes.size();</span><br><span class="line">          <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              root = nodes.removeFirst();</span><br><span class="line">              TreeNode temp = root.left;</span><br><span class="line">              root.left=root.right;</span><br><span class="line">              root.right=temp;</span><br><span class="line">              i--;</span><br><span class="line">              <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  nodes.add(root.left);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  nodes.add(root.right);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>给一个排序数组（从小到大），将其转换为一棵高度最小的二叉搜索树。  分别寻找左右的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">if</span>(A.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = A.length - <span class="number">1</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(A[(len / <span class="number">2</span>)]);</span><br><span class="line">    root.left = searchChild(<span class="number">0</span>, len / <span class="number">2</span>-<span class="number">1</span> , A);</span><br><span class="line">    root.right = searchChild(len / <span class="number">2</span> +<span class="number">1</span>, len, A);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchChild</span><span class="params">(Integer left, Integer right, <span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(A[(right + left) / <span class="number">2</span>]);</span><br><span class="line">    node.left = searchChild(left, (right + left) / <span class="number">2</span> - <span class="number">1</span>, A);</span><br><span class="line">    node.right = searchChild((right + left) / <span class="number">2</span> + <span class="number">1</span>, right, A);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将二叉树按照层级转化为链表"><a href="#将二叉树按照层级转化为链表" class="headerlink" title="将二叉树按照层级转化为链表"></a>将二叉树按照层级转化为链表</h2><p>类似于层级遍历，再构造新的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ListNode&gt; <span class="title">binaryTreeToLists</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    List&lt;ListNode&gt; nodes = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nodes ;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode p = root;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; temp = <span class="keyword">new</span> LinkedList &lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            p=queue.poll();</span><br><span class="line">            temp.add(p);</span><br><span class="line">            <span class="keyword">if</span>(p.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(p.left);</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">if</span>(p.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(p.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(!temp.isEmpty())&#123;</span><br><span class="line">           TreeNode tn = temp.poll();</span><br><span class="line">           <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">               head = <span class="keyword">new</span> ListNode(tn.val);</span><br><span class="line">               next = head;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               ListNode curNode = <span class="keyword">new</span> ListNode(tn.val);</span><br><span class="line">               next.next=curNode;</span><br><span class="line">               next=next.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       nodes.add(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树转换成链表"><a href="#二叉树转换成链表" class="headerlink" title="二叉树转换成链表"></a>二叉树转换成链表</h2><p>先把右节点放入栈，再放左节点，然后该节点的左节点为空，再一次按节点的顺序设置右节点为栈头</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&#123;1,2,5,3,4,#,6&#125;</span><br><span class="line">输出：&#123;1,#,2,#,3,#,4,#,5,#,6&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="comment">// 先压右结点，后压左结点</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// connect</span></span><br><span class="line">            node.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 此处是 if else</span></span><br><span class="line">            <span class="comment">// node.right 在此处等同于 next</span></span><br><span class="line">            <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">                node.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.right = stack.peek();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断是否为等价二叉树"><a href="#判断是否为等价二叉树" class="headerlink" title="判断是否为等价二叉树"></a>判断是否为等价二叉树</h2><p>节点值相同，且儿子的值也相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEqual</span><span class="params">(TreeNode node1, TreeNode node2)</span> </span>&#123;</span><br><span class="line">    Boolean flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="keyword">null</span> &amp;&amp; node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node1 != <span class="keyword">null</span> &amp;&amp; node2 != <span class="keyword">null</span> &amp;&amp; node1.val == node2.val) &#123;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag &amp; isEqual(node1.left, node2.left) &amp; isEqual(node1.right, node2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h2><p>给一棵二叉树和二叉树中的两个节点，找到这两个节点的最近公共祖先<code>LCA</code>。</p>
<p>两个节点的最近公共祖先，是指两个节点的所有父亲节点中（包括这两个节点），离这两个节点最近的公共的节点。</p>
<p>每个节点除了左右儿子指针以外，还包含一个父亲指针<code>parent</code>，指向自己的父亲。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;ParentTreeNode&gt; path1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      List&lt;ParentTreeNode&gt; path2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(A!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          path1.add(A);</span><br><span class="line">          A=A.parent;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(B!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          path2.add(B);</span><br><span class="line">          B=B.parent;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;path1.size();i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(path2.contains(path1.get(i)))&#123;</span><br><span class="line">              <span class="keyword">return</span> path1.get(i);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<h2 id="所有叶子节点和"><a href="#所有叶子节点和" class="headerlink" title="所有叶子节点和"></a>所有叶子节点和</h2><p>需要处理下list的结果和，基本类型传值，除了新写一个类包一下，暂时没别的想法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">allLeaf</span><span class="params">(TreeNode root, List&lt;Integer&gt; leaf)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">          leaf.add(root.val);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      allLeaf(root.left, leaf);</span><br><span class="line">      allLeaf(root.right, leaf);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小子树"><a href="#最小子树" class="headerlink" title="最小子树"></a>最小子树</h2><p>给一棵二叉树, 找到和为最小的子树, 返回其根节点。输入输出数据范围都在int内。有个坑就是节点的左右子节点都要取，不是只招一条分支，例如”1,-5,-2,1,2,-4,-5”。输出的是-12</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root: the root of binary tree</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: the root of the minimum subtree</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TreeNode temp=<span class="keyword">null</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer sum = Integer.MAX_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">findSubtree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        sum=Integer.MAX_VALUE;</span><br><span class="line">        sum=minTree(root);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = minTree(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = minTree(root.right);</span><br><span class="line">        <span class="keyword">if</span>(left+right+root.val&lt;sum)&#123;</span><br><span class="line">            sum = left+right+root.val;</span><br><span class="line">            temp = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left+right+root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm内存模型</title>
    <url>/2020/03/31/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="java虚拟机内存区域"><a href="#java虚拟机内存区域" class="headerlink" title="java虚拟机内存区域"></a>java虚拟机内存区域</h1><p><img src="/2020/03/31/jvm内存模型/jvm内存模型.png" width="500" height="500" alt="栈帧模型" align="center"></p>
<h2 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h2><p>​    程序计数器是一块很小的内存空间，它是线程私有的，可以认作为当前线程的行号指示器。我们知道对于一个处理器(如果是多核cpu那就是一核)，在一个确定的时刻都只会执行一条线程中的指令，一条线程中有多个指令，为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器，不同线程之间的程序计数器互不影响，独立存储。</p>
<p>如果线程执行的是个java方法，那么计数器记录虚拟机字节码指令的地址。如果为native【底层方法】，那么计数器为空。这块内存区域是虚拟机规范中唯一没有OutOfMemoryError的区域。</p>
<h2 id="2、java栈（虚拟机栈）"><a href="#2、java栈（虚拟机栈）" class="headerlink" title="2、java栈（虚拟机栈）"></a>2、java栈（虚拟机栈）</h2><p>同计数器也为线程私有，生命周期与相同，就是我们平时说的栈，<strong>栈描述的是Java方法执行的内存模型</strong>。</p>
<p><strong>每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。【栈先进后出】</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">栈帧: 是用来存储数据和部分过程结果的数据结构。</span><br><span class="line">栈帧的位置:  内存 -&gt; 运行时数据区 -&gt; 某个线程对应的虚拟机栈 -&gt; here[在这里]</span><br><span class="line">栈帧大小确定时间: 编译期确定，不受运行期数据影响。</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/31/jvm内存模型/栈帧模型.png" width="300" height="300" alt="栈帧模型" align="center"></p>
<p><strong>平时说的栈一般指局部变量表部分。</strong></p>
<p>局部变量表:一片连续的内存空间，用来存放方法参数，以及方法内定义的局部变量，存放着编译期间已知的数据类型(八大基本类型和对象引用(reference类型),returnAddress类型。它的最小的局部变量表空间单位为Slot，虚拟机没有指明Slot的大小.</p>
<h2 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h2><p>本地方法栈是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务，可能底层调用的c或者c++，</p>
<h2 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h2><p>对于大多数应用来说，堆是java虚拟机管理内存最大的一块内存区域，因为堆存放的对象是线程共享的，所以多线程的时候也需要同步机制。</p>
<p>java虚拟机规范对这块的描述是:所有对象实例及数组都要在堆上分配内存，但随着JIT编译器的发展和逃逸分析技术的成熟，这个说法也不是那么绝对，但是大多数情况都是这样的。</p>
<p>即时编译器:可以把把Java的字节码，包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的程序)</p>
<p>逃逸分析:通过逃逸分析来决定某些实例或者变量是否要在堆中进行分配，如果开启了逃逸分析，即可将这些变量直接在栈上进行分配，而非堆上进行分配。这些变量的指针可以被全局所引用，或者其其它线程所引用。</p>
<p>它是所有线程共享的，它的目的是存放对象实例。同时它也是GC所管理的主要区域，因此常被称为GC堆，又由于现在收集器常使用分代算法，Java堆中还可以细分为新生代和老年代。</p>
<h2 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h2><p>方法区同堆一样，是所有线程共享的内存区域，为了区分堆，又被称为非堆。</p>
<p>主要是存储已被虚拟机加载的<strong>类信息、常量、静态变量</strong>，如static修饰的变量加载类的时候就被加载到方法区中。</p>
<p>运行时常量池也是方法区的一部分，class文件除了有类的字段、接口、方法等描述信息之外，还有常量池用于存放编译期间生成的各种字面量和符号引用。</p>
<p>在老版jdk，方法区也被称为永久代，因为没有强制要求必须实现垃圾回收，HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。</p>
<p><strong>jdk8真正开始废弃永久代，而使用元空间(Metaspace)</strong></p>
<p>java虚拟机对方法区比较宽松，除了跟堆一样可以不存在连续的内存空间，定义空间和可扩展空间，还可以选择不实现垃圾收集。</p>
<h1 id="Java对象的内存布局"><a href="#Java对象的内存布局" class="headerlink" title="Java对象的内存布局"></a>Java对象的内存布局</h1><p>在HotSpot虚拟机中。对象在内存中存储的布局分为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.对象头</span><br><span class="line">2.实例数据</span><br><span class="line">3.对齐填充</span><br></pre></td></tr></table></figure>
<h2 id="对象头【markword】"><a href="#对象头【markword】" class="headerlink" title="对象头【markword】"></a>对象头【markword】</h2><p><img src="/2020/03/31/jvm内存模型/对象锁.png" width="500" height="500" alt="锁类型" align="center"></p>
<p>这其中锁标识位需要特别关注下。<strong>锁标志位与是否为偏向锁对应到唯一的锁状态</strong>。</p>
<p>锁的状态分为四种<code>无锁状态</code>、<code>偏向锁</code>、<code>轻量级锁</code>和<code>重量级锁</code></p>
<p>不同状态时对象头的区间含义，如图所示。</p>
<p>在32位系统下，对象头8字节，64位则是16个字节</p>
<p><img src="/2020/03/31/jvm内存模型/对象锁.png" width="500" height="500" alt="锁类型" align="center"></p>
<p>关于对象头和锁之间的转换，我盗图了</p>
<p><img src="/2020/03/31/jvm内存模型/锁流程.png" width="500" height="500" alt="锁流程" align="center"></p>
<h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">存放对象程序中各种类型的字段类型，不管是从父类中继承下来的还是在子类中定义的。</span><br><span class="line">分配策略:相同宽度的字段总是放在一起，比如<span class="keyword">double</span>和<span class="keyword">long</span></span><br></pre></td></tr></table></figure>
<h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>这部分没有特殊的含义，仅仅起到占位符的作用满足JVM要求。由于HotSpot规定对象的大小必须是8的整数倍，对象头刚好是整数倍，如果实例数据不是的话，就需要占位符对齐填充</p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>java程序需要通过引用(ref)数据来操作堆上面的对象，那么如何通过引用定位、访问到对象的具体位置。</p>
<p>对象的访问方式由虚拟机决定，java虚拟机提供两种主流的方式<br>1.句柄访问对象<br>2.直接指针访问对象。(Sun HotSpot使用这种方式)</p>
<h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p>简单来说就是java堆划出一块内存作为句柄池,引用中存储对象的句柄地址,句柄中包含对象实例数据、类型数据的地址信息。</p>
<p>优点:引用中存储的是稳定的句柄地址,在对象被移动【垃圾收集时移动对象是常态】只需改变句柄中实例数据的指针，不需要改动引用【ref】本身。</p>
<p><img src="/2020/03/31/jvm内存模型/句柄访问.png" width="500" height="500" alt="句柄访问" align="center"></p>
<h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3><p>与句柄访问不同的是，ref中直接存储的就是对象的实例数据,但是类型数据跟句柄访问方式一样。</p>
<p>优点:优势很明显，就是速度快，<strong>相比于句柄访问少了一次指针定位的开销时间</strong>。【可能是出于Java中对象的访问时十分频繁的,平时我们常用的JVM HotSpot采用此种方式】</p>
<p><img src="/2020/03/31/jvm内存模型/直接指针.png" width="500" height="500" alt="直接指针" align="center"></p>
<h1 id="GC简介"><a href="#GC简介" class="headerlink" title="GC简介"></a>GC简介</h1><p>java GC泛指java的垃圾回收机制，该机制是java与C/C++的主要区别之一，我们在日常写java代码的时候，一般都不需要编写内存回收或者垃圾清理的代码，也不需要像C/C++那样做类似delete/free的操作。</p>
<p>没必要深入到GC的底层实现，但是要学会看懂gc及定位一些内存泄漏问题。</p>
<h2 id="那些内存需要回收"><a href="#那些内存需要回收" class="headerlink" title="那些内存需要回收"></a>那些内存需要回收</h2><p>上面中JVM中程序计数器、虚拟机栈、本地方法栈都是线程私有，随线程存活死亡，而其中的栈帧随着方法的执行顺序执行入栈和出栈操作，一个栈帧需要多少内存取决于具体的虚拟机实现并且在编译期间确定，当方法执行完，内存就会回收。</p>
<p>而<code>Java堆</code>、<code>方法区</code>则不一样。方法区存放着类加载信息，但是一个接口中多个实现类需要的内存可能不太一样，一个方法中多个分支需要的内存也可能不一样【只有在运行期间才可知道这个方法创建了哪些对象没需要多少内存】，这部分内存的分配和回收都是动态的，gc关注的也正是这部分的内存。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Java</span>堆是<span class="selector-tag">GC</span>回收的“重点区域”。堆中基本存放着所有对象实例，<span class="selector-tag">gc</span>进行回收前，第一件事就是确认哪些对象存活，哪些死去</span><br></pre></td></tr></table></figure>
<h2 id="堆的回收区域"><a href="#堆的回收区域" class="headerlink" title="堆的回收区域"></a>堆的回收区域</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">为了高效的回收，<span class="selector-tag">jvm</span>将堆分为三个区域</span><br><span class="line">1.新生代（<span class="selector-tag">Young</span> <span class="selector-tag">Generation</span>）<span class="selector-tag">NewSize</span>和<span class="selector-tag">MaxNewSize</span>分别可以控制年轻代的初始大小和最大的大小</span><br><span class="line">2.老年代（<span class="selector-tag">Old</span> <span class="selector-tag">Generation</span>）</span><br><span class="line">3.永久代（<span class="selector-tag">Permanent</span> <span class="selector-tag">Generation</span>）【1<span class="selector-class">.8</span>以后采用元空间，就不在堆中了】</span><br></pre></td></tr></table></figure>
<h2 id="判断对象是否存活算法"><a href="#判断对象是否存活算法" class="headerlink" title="判断对象是否存活算法"></a>判断对象是否存活算法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.引用计数算法</span><br><span class="line">早期判断对象是否存活大多都是以这种算法，这种算法判断很简单，简单来说就是给对象添加一个引用计数器，每当对象被引用一次就加1，引用失效时就减1。当为0的时候就判断对象不会再被引用。</span><br><span class="line">优点:实现简单效率高，被广泛使用与如python何游戏脚本语言上。</span><br><span class="line">缺点:难以解决循环引用的问题，就是假如两个对象互相引用已经不会再被其它其它引用，导致一直不会为0就无法进行回收。</span><br><span class="line"></span><br><span class="line">2.可达性分析算法</span><br><span class="line">目前主流的商用语言[如java、c<span class="comment">#]采用的是可达性分析算法判断对象是否存活。这个算法有效解决了循环利用的弊端。</span></span><br><span class="line">它的基本思路是通过一个称为“GC Roots”的对象为起始点，搜索所经过的路径称为引用链，当一个对象到GC Roots没有任何引用跟它连接则证明对象是不可用的。</span><br></pre></td></tr></table></figure>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>jvm中，可达性分析算法帮我们解决了哪些对象可以回收的问题，垃圾收集算法则关心怎么回收。</p>
<h3 id="三大垃圾收集算法"><a href="#三大垃圾收集算法" class="headerlink" title="三大垃圾收集算法"></a>三大垃圾收集算法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>标记/清除算法【最基础】</span><br><span class="line"><span class="number">2.</span>复制算法</span><br><span class="line"><span class="number">3.</span>标记/整理算法</span><br><span class="line">jvm采用<span class="string">`分代收集算法`</span>对不同区域采用不同的回收算法。</span><br></pre></td></tr></table></figure>
<p><strong>新生代采用复制算法</strong></p>
<p>新生代中因为对象都是”朝生夕死的”，【深入理解JVM虚拟机上说98%的对象,不知道是不是这么多，总之就是存活率很低】，适用于复制算法【复制算法比较适合用于存活率低的内存区域】。它优化了标记/清除算法的效率和内存碎片问题，且JVM不以5:5分配内存【由于存活率低，不需要复制保留那么大的区域造成空间上的浪费，因此不需要按1:1【原有区域:保留空间】划分内存区域，而是将内存分为一块Eden空间和From Survivor、To Survivor【保留空间】，三者默认比例为8:1:1，优先使用Eden区，若Eden区满，则将对象复制到第二块内存区上。但是不能保证每次回收都只有不多于10%的对象存货，所以Survivor区不够的话，则会依赖老年代年存进行分配】</p>
<p>GC开始时，对象只会存于Eden和From Survivor区域，To Survivor【保留空间】为空。</p>
<p>GC进行时，Eden区所有存活的对象都被复制到To Survivor区，而From Survivor区中，仍存活的对象会根据它们的年龄值决定去向，年龄值达到年龄阈值(默认15是因为对象头中年龄战4bit，新生代每熬过一次垃圾回收，年龄+1)，则移到老年代，没有达到则复制到To Survivor。</p>
<p><strong>老年代采用<code>标记/清除算法</code>或<code>标记/整理算法</code></strong></p>
<p>由于老年代存活率高，没有额外空间给他做担保，必须使用这两种算法。</p>
<h3 id="枚举根节点算法"><a href="#枚举根节点算法" class="headerlink" title="枚举根节点算法"></a>枚举根节点算法</h3><p>可作为GC Roos的节点主要是在一些全局引用【如常量或静态属性】、执行上下文【如栈帧中本地变量表】中。那么如何在这么多全局变量和本地变量表找到【枚举】根节点将是个问题。</p>
<p>可达性分析算法需考虑</p>
<p>1.如果方法区几百兆，一个个检查里面的引用，将耗费大量资源。</p>
<p>2.在分析时，需保证这个对象引用关系不再变化，否则结果将不准确。【因此GC进行时需停掉其它所有java执行线程(Sun把这种行为称为‘Stop the World’)，即使是号称几乎不会停顿的CMS收集器，枚举根节点时也需停掉线程】</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">年轻代收集器</span><br><span class="line"><span class="selector-tag">Serial</span>、<span class="selector-tag">ParNew</span>、<span class="selector-tag">Parallel</span> <span class="selector-tag">Scavenge</span></span><br><span class="line">老年代收集器</span><br><span class="line"><span class="selector-tag">Serial</span> <span class="selector-tag">Old</span>、<span class="selector-tag">Parallel</span> <span class="selector-tag">Old</span>、<span class="selector-tag">CMS</span>收集器</span><br><span class="line">特殊收集器</span><br><span class="line"><span class="selector-tag">G1</span>收集器<span class="selector-attr">[新型，不在年轻、老年代范畴内]</span></span><br></pre></td></tr></table></figure>
<h2 id="Minor-GC、Major-GC、FULL-GC、mixed-gc"><a href="#Minor-GC、Major-GC、FULL-GC、mixed-gc" class="headerlink" title="Minor GC、Major GC、FULL GC、mixed gc"></a>Minor GC、Major GC、FULL GC、mixed gc</h2><h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><blockquote>
<p>在年轻代<code>Young space</code>(包括Eden区和Survivor区)中的垃圾回收称之为 Minor GC,Minor GC只会清理年轻代.</p>
</blockquote>
<h3 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h3><blockquote>
<p>Major GC清理老年代(old GC)，但是通常也可以指和Full GC是等价，因为收集老年代的时候往往也会伴随着升级年轻代，收集整个Java堆。所以有人问的时候需问清楚它指的是full GC还是old GC。</p>
</blockquote>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><blockquote>
<p>full gc是对新生代、老年代、永久代【jdk1.8后没有这个概念了】统一的回收。</p>
<p>【知乎R大的回答:收集整个堆，包括young gen、old gen、perm gen（如果存在的话)、元空间(1.8及以上)等所有部分的模式】</p>
</blockquote>
<h3 id="mixed-GC【g1特有】"><a href="#mixed-GC【g1特有】" class="headerlink" title="mixed GC【g1特有】"></a>mixed GC【g1特有】</h3><blockquote>
<p>混合GC</p>
<p>收集整个young gen以及部分old gen的GC。只有G1有这个模式</p>
</blockquote>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>自动装箱和拆箱</title>
    <url>/2020/03/30/%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/</url>
    <content><![CDATA[<h1 id="自动拆箱装箱"><a href="#自动拆箱装箱" class="headerlink" title="自动拆箱装箱"></a>自动拆箱装箱</h1><h2 id="1、基本的数据类型"><a href="#1、基本的数据类型" class="headerlink" title="1、基本的数据类型"></a>1、基本的数据类型</h2><p>基本类型，或者叫做内置类型，是Java中不同于类(Class)的特殊类型。它们是我们编程中使用最频繁的类型。</p>
<p>Java是一种强类型语言，第一次申明变量必须说明数据类型，第一次变量赋值称为变量的初始化。</p>
<p>字符类型<code>char</code></p>
<p>布尔类型<code>boolean</code></p>
<p>整数类型<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></p>
<p>浮点数类型<code>float</code>、<code>double</code>。</p>
<p>Java中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者操作系统的改变而改变。</p>
<p>我们都知道在Java语言中，new一个对象是存储在堆里的，我们通过栈中的引用来使用这些对象；所以，对象本身来说是比较消耗资源的。</p>
<p>对于经常用到的类型，如int等，如果我们每次使用这种变量的时候都需要new一个Java对象的话，就会比较笨重。</p>
<p>所以，和C++一样，Java提供了基本数据类型，这种数据的变量不需要使用new创建，他们不会在堆上创建，而是直接在栈内存中存储，因此会更加高效。</p>
<h2 id="2、包装类型"><a href="#2、包装类型" class="headerlink" title="2、包装类型"></a>2、包装类型</h2><p>Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。</p>
<p>包装类均位于java.lang包，因为Java是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型。比如，在集合类中，我们是无法将int 、double等类型放进去的。因为集合的容器要求元素是Object类型。</p>
<p>为了让基本类型也具有对象的特征，就出现了包装类型，它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p>
<h2 id="3、自动包装与拆箱"><a href="#3、自动包装与拆箱" class="headerlink" title="3、自动包装与拆箱"></a>3、自动包装与拆箱</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i =<span class="number">10</span>;  <span class="comment">//自动装箱</span></span><br><span class="line"><span class="keyword">int</span> b= i;     <span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure>
<p>对以上代码进行反编译后可以得到以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer integer=Integer.valueOf(<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">int</span> i=integer.intValue();</span><br></pre></td></tr></table></figure>
<h2 id="4、哪些地方会自动拆装箱"><a href="#4、哪些地方会自动拆装箱" class="headerlink" title="4、哪些地方会自动拆装箱"></a>4、哪些地方会自动拆装箱</h2><h3 id="1、将基本数据类型放入集合类"><a href="#1、将基本数据类型放入集合类" class="headerlink" title="1、将基本数据类型放入集合类"></a>1、将基本数据类型放入集合类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">50</span>; i ++)&#123;</span><br><span class="line">    li.add(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、包装类型和基本类型的比较"><a href="#2、包装类型和基本类型的比较" class="headerlink" title="2、包装类型和基本类型的比较"></a>2、包装类型和基本类型的比较</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Integer a=<span class="number">1</span>;</span><br><span class="line">System.out.println(a==<span class="number">1</span>?<span class="string">"等于"</span>:<span class="string">"不等于"</span>);</span><br><span class="line">Boolean bool=<span class="keyword">false</span>;</span><br><span class="line">System.out.println(bool?<span class="string">"真"</span>:<span class="string">"假"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3、包装类型的运算"><a href="#3、包装类型的运算" class="headerlink" title="3、包装类型的运算"></a>3、包装类型的运算</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;</span><br><span class="line">Integer j = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">System.out.println(i+j);</span><br></pre></td></tr></table></figure>
<h3 id="4、三目运算符的使用"><a href="#4、三目运算符的使用" class="headerlink" title="4、三目运算符的使用"></a>4、三目运算符的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">Integer i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k = flag ? i : j;</span><br></pre></td></tr></table></figure>
<p>这其实是三目运算符的语法规范：当第二，第三位操作数分别为基本类型和对象时，其中的对象就会拆箱为基本类型进行操作。</p>
<p>因为例子中，flag ? i : j;片段中，第二段的i是一个包装类型的对象，而第三段的j是一个基本类型，所以会对包装类进行自动拆箱。如果这个时候i的值为null，那么久会发生NPE。（自动拆箱导致空指针异常）</p>
<h3 id="5、函数参数与返回值"><a href="#5、函数参数与返回值" class="headerlink" title="5、函数参数与返回值"></a>5、函数参数与返回值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum1</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getNum2</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自动拆装箱与缓存"><a href="#自动拆装箱与缓存" class="headerlink" title="自动拆装箱与缓存"></a>自动拆装箱与缓存</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer integer1 = <span class="number">3</span>;s</span><br><span class="line">    Integer integer2 = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (integer1 == integer2)</span><br><span class="line">        System.out.println(<span class="string">"integer1 == integer2"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">"integer1 != integer2"</span>);</span><br><span class="line"> </span><br><span class="line">    Integer integer3 = <span class="number">300</span>;</span><br><span class="line">    Integer integer4 = <span class="number">300</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (integer3 == integer4)</span><br><span class="line">        System.out.println(<span class="string">"integer3 == integer4"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">"integer3 != integer4"</span>);</span><br></pre></td></tr></table></figure>
<p>在Java中，==比较的是对象应用，而equals比较的是值。</p>
<p>所以，在这个例子中，不同的对象有不同的引用，所以在进行比较的时候都将返回false。奇怪的是，这里两个类似的if条件判断返回不同的布尔值。</p>
<p>上面这段代码真正的输出结果：</p>
<p>integer1 == integer2<br>integer3 != integer4<br>原因就和Integer中的缓存机制有关。在Java 5中，在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。适用于整数值区间-128 至 +127。</p>
<p>只适用于自动装箱。使用构造函数创建对象不适用。</p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h1><p>开闭原则（Open Closed Principle，OCP）由勃兰特·梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向对象软件构造》（Object Oriented Software Construction）中提出：软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义。</p>
<p>这里的软件实体包括以下几个部分：</p>
<ol>
<li>项目中划分出的模块</li>
<li>类与接口</li>
<li>方法</li>
</ol>
<p>开闭原则的含义是：<em>当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</em></p>
<h1 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h1><p>迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p>
<p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p>
<h1 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式是<a href="http://c.biancheng.net/design_pattern/" target="_blank" rel="noopener">设计模式</a>中最简单的模式之一。通常，普通类的构造函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。主要用于保证一个类只有一个实例，并且提供一个全局访问点</p>
<p>1、懒汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SinglenStyle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SinglenStyle singlenStyle = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//private 避免在类外部被实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SinglenStyle</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="comment">//提供静态的公有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SinglenStyle <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//getInstance 方法前加同步</span></span><br><span class="line">        <span class="keyword">if</span>(singlenStyle==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            singlenStyle=<span class="keyword">new</span> SinglenStyle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singlenStyle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、饿汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SinglenStyle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SinglenStyle singlenStyle = <span class="keyword">new</span> SinglenStyle();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SinglenStyle</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SinglenStyle <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//getInstance 方法前加同步</span></span><br><span class="line">        <span class="keyword">return</span> singlenStyle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。在生活中复制的例子非常多，这里不一一列举了。</p>
<p>由于 <a href="http://c.biancheng.net/java/" target="_blank" rel="noopener">Java</a> 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。利用clone的方法获取一个类似的对象。</p>
<p>原型模式包含以下主要角色。</p>
<ol>
<li>抽象原型类：规定了具体原型对象必须实现的接口。</li>
<li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li>
<li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Realizetype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String val=<span class="string">"0"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVal</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Realizetype()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"具体原型创建成功！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体原型复制成功！"</span>);</span><br><span class="line">       <span class="keyword">return</span>(Realizetype)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Realizetype obj1=<span class="keyword">new</span> Realizetype();</span><br><span class="line">        Realizetype obj2=(Realizetype)obj1.clone();</span><br><span class="line">        obj1.setVal(<span class="string">"1"</span>);</span><br><span class="line">        obj2.setVal(<span class="string">"2"</span>);</span><br><span class="line">        System.out.println(<span class="string">"obj1==obj2?"</span>+(obj1==obj2));</span><br><span class="line">        System.out.println(obj1.getVal());</span><br><span class="line">        System.out.println(obj2.getVal());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<p>工厂方法模式的主要角色如下。</p>
<ol>
<li><p>抽象工厂：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 来创建产品。</p>
</li>
<li><p>具体工厂：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</p>
</li>
<li><p>抽象产品：定义了产品的规范，描述了产品的主要特性和功能。</p>
</li>
<li><p>具体产品：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</p>
</li>
</ol>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际工厂1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体工厂1生成--&gt;具体产品1..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体工厂2生成--&gt;具体产品1..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品一</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体产品1显示..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///产品二</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体产品2显示..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Product a;</span><br><span class="line">            AbstractFactory af;</span><br><span class="line">            Class&lt;?&gt; c = Class.forName(<span class="string">"com.example.design_style.ConcreteFactory1"</span>);</span><br><span class="line">            Object obj = c.newInstance();</span><br><span class="line">            af = (AbstractFactory) obj;</span><br><span class="line">            a = af.newProduct();</span><br><span class="line">            a.show();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"eror msg"</span>+e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的<a href="http://c.biancheng.net/design_pattern/" target="_blank" rel="noopener">设计模式</a>被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p>
<p>该模式的主要优点如下：</p>
<ol>
<li>各个具体的建造者相互独立，有利于系统的扩展。</li>
<li>客户端不必知道产品内部组成的细节，便于控制细节风险。</li>
</ol>
<p>其缺点如下：</p>
<ol>
<li>产品的组成部分必须相同，这限制了其使用范围。</li>
<li>如果产品的内部变化复杂，该模式会增加很多的建造者类。</li>
</ol>
<p>建造者（Builder）模式由产品、抽象建造者、具体建造者、指挥者等 4 个要素构成，现在我们来分析其基本结构和实现方法。</p>
<ol>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实际产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String partA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String partB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String partC;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPartA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> partA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartA</span><span class="params">(String partA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partA = partA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPartB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> partB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartB</span><span class="params">(String partB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partB = partB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPartC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> partC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartC</span><span class="params">(String partC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partC = partC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//显示产品的特性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认构建产品实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Product product=<span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  构建方法A</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  构建方法B</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  构建方法C</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//属性构造方法 具体建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">BaseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">"建造 PartA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">"建造 PartB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">"建造 PartC"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指挥者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BaseBuilder builder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(BaseBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        builder.buildPartA();</span><br><span class="line">        builder.buildPartB();</span><br><span class="line">        builder.buildPartC();</span><br><span class="line">        <span class="keyword">return</span> builder.getResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        BaseBuilder builder=<span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director=<span class="keyword">new</span> Director(builder);</span><br><span class="line">        Product product=director.construct();</span><br><span class="line">        product.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p>
<p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<p>类适配器模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要调用的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"适配者中的业务代码被调用！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//包装过后，调用目标接口来调用需要调用的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAdapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类适配器模式测试："</span>);</span><br><span class="line">        Target target = <span class="keyword">new</span> ClassAdapter();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象适配模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectAdapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对象适配器模式测试："</span>);</span><br><span class="line">        Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line">        Target target = <span class="keyword">new</span> ObjectAdapter(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<p>桥接（Bridge）模式的优点是：</p>
<ul>
<li>由于抽象与实现分离，所以扩展能力强；</li>
<li>其实现细节对客户透明。</li>
</ul>
<p>缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现话角色接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口实现方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体实现化(Concrete Implementor)角色被访问"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象类接口，内部适配角色接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Implementor imple;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Abstraction</span><span class="params">(Implementor imple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.imple = imple;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展角色实现，继承类调用角色接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor imple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(imple);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"扩展抽象化(Refined Abstraction)角色被访问"</span>);</span><br><span class="line">        imple.operationImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Implementor imple=<span class="keyword">new</span> ConcreteImplementorA();</span><br><span class="line">        Abstraction abs=<span class="keyword">new</span> RefinedAbstraction(imple);</span><br><span class="line">        abs.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式的结构不是很复杂，下面对它的结构和实现进行分析。</p>
<ol>
<li>模式的结构</li>
</ol>
<p>组合模式包含以下主要角色。</p>
<ol>
<li>抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。</li>
<li>树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。</li>
<li>树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。</li>
</ol>
<p>组合模式分为透明式的组合模式和安全式的组合模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象构建  通用方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span>  <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树叶</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"树叶"</span> + name + <span class="string">"：被访问！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树枝</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; children = <span class="keyword">new</span> ArrayList&lt;Component&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span> </span>&#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span> </span>&#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj : children) &#123;</span><br><span class="line">            ((Component) obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Component c0=<span class="keyword">new</span> Composite();</span><br><span class="line">        Component c1=<span class="keyword">new</span> Composite();</span><br><span class="line">        Component leaf1=<span class="keyword">new</span> Leaf(<span class="string">"1"</span>);</span><br><span class="line">        Component leaf2=<span class="keyword">new</span> Leaf(<span class="string">"2"</span>);</span><br><span class="line">        Component leaf3=<span class="keyword">new</span> Leaf(<span class="string">"3"</span>);</span><br><span class="line">        c0.add(leaf1);</span><br><span class="line">        c0.add(c1);</span><br><span class="line">        c1.add(leaf2);</span><br><span class="line">        c1.add(leaf3);</span><br><span class="line">        c0.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>装饰（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p>
<p>装饰（Decorator）模式的主要优点有：</p>
<ul>
<li>采用装饰模式扩展对象的功能比采用继承方式更加灵活。</li>
<li>可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。</li>
</ul>
<p>其主要缺点是：装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Component p=<span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        p.operation();</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">        Component d=<span class="keyword">new</span> ConcreteDecorator(p);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span>  <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteComponent</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建具体构件角色"</span>);       </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用具体构件角色的方法operation()"</span>);           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component=component;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator</span><span class="params">(Component component)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addedFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"为具体构件角色增加额外的功能addedFunction()"</span>);           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法。</p>
<ol>
<li>模式的结构</li>
</ol>
<p>代理模式的主要角色如下。</p>
<ol>
<li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Proxy proxy=<span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题方法..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            realSubject=<span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.Request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题之前的预处理。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题之后的后续处理。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观（Facade）模式的定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FacadePattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Facade f=new Facade();</span><br><span class="line">        f.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//外观角色</span><br><span class="line">class Facade</span><br><span class="line">&#123;</span><br><span class="line">    private SubSystem01 obj1=new SubSystem01();</span><br><span class="line">    private SubSystem02 obj2=new SubSystem02();</span><br><span class="line">    private SubSystem03 obj3=new SubSystem03();</span><br><span class="line">    public void method()</span><br><span class="line">    &#123;</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">        obj3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem01</span><br><span class="line">&#123;</span><br><span class="line">    public  void method1()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;子系统01的method1()被调用！&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem02</span><br><span class="line">&#123;</span><br><span class="line">    public  void method2()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;子系统02的method2()被调用！&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem03</span><br><span class="line">&#123;</span><br><span class="line">    public  void method3()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;子系统03的method3()被调用！&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="亨元模式"><a href="#亨元模式" class="headerlink" title="亨元模式"></a>亨元模式</h2><p>享元（Flyweight）模式的定义：运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FlyweightFactory factory=<span class="keyword">new</span> FlyweightFactory();</span><br><span class="line">        Flyweight f01=factory.getFlyweight(<span class="string">"a"</span>);</span><br><span class="line">        Flyweight f02=factory.getFlyweight(<span class="string">"a"</span>);</span><br><span class="line">        Flyweight f03=factory.getFlyweight(<span class="string">"a"</span>);</span><br><span class="line">        Flyweight f11=factory.getFlyweight(<span class="string">"b"</span>);</span><br><span class="line">        Flyweight f12=factory.getFlyweight(<span class="string">"b"</span>);       </span><br><span class="line">        f01.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第1次调用a。"</span>));       </span><br><span class="line">        f02.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第2次调用a。"</span>));       </span><br><span class="line">        f03.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第3次调用a。"</span>));       </span><br><span class="line">        f11.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第1次调用b。"</span>));       </span><br><span class="line">        f12.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第2次调用b。"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非享元角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsharedConcreteFlyweight</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line">    UnsharedConcreteFlyweight(String info)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.info=info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(String info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info=info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象享元角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyweight</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(UnsharedConcreteFlyweight state)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体享元角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">implements</span> <span class="title">Flyweight</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    ConcreteFlyweight(String key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.key=key;</span><br><span class="line">        System.out.println(<span class="string">"具体享元"</span>+key+<span class="string">"被创建！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(UnsharedConcreteFlyweight outState)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"具体享元"</span>+key+<span class="string">"被调用，"</span>);</span><br><span class="line">        System.out.println(<span class="string">"非享元信息是:"</span>+outState.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//享元工厂角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Flyweight&gt; flyweights=<span class="keyword">new</span> HashMap&lt;String, Flyweight&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Flyweight flyweight=(Flyweight)flyweights.get(key);</span><br><span class="line">        <span class="keyword">if</span>(flyweight!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"具体享元"</span>+key+<span class="string">"已经存在，被成功获取！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            flyweight=<span class="keyword">new</span> ConcreteFlyweight(key);</span><br><span class="line">            flyweights.put(key, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ObserverPattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Subject subject=new ConcreteSubject();</span><br><span class="line">        Observer obs1=new ConcreteObserver1();</span><br><span class="line">        Observer obs2=new ConcreteObserver2();</span><br><span class="line">        subject.add(obs1);</span><br><span class="line">        subject.add(obs2);</span><br><span class="line">        subject.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象目标</span><br><span class="line">abstract class Subject</span><br><span class="line">&#123;</span><br><span class="line">    protected List&lt;Observer&gt; observers=new ArrayList&lt;Observer&gt;();   </span><br><span class="line">    //增加观察者方法</span><br><span class="line">    public void add(Observer observer)</span><br><span class="line">    &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;    </span><br><span class="line">    //删除观察者方法</span><br><span class="line">    public void remove(Observer observer)</span><br><span class="line">    &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;   </span><br><span class="line">    public abstract void notifyObserver(); //通知观察者方法</span><br><span class="line">&#125;</span><br><span class="line">//具体目标</span><br><span class="line">class ConcreteSubject extends Subject</span><br><span class="line">&#123;</span><br><span class="line">    public void notifyObserver()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体目标发生改变...&quot;);</span><br><span class="line">        System.out.println(&quot;--------------&quot;);       </span><br><span class="line">       </span><br><span class="line">        for(Object obs:observers)</span><br><span class="line">        &#123;</span><br><span class="line">            ((Observer)obs).response();</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;          </span><br><span class="line">&#125;</span><br><span class="line">//抽象观察者</span><br><span class="line">interface Observer</span><br><span class="line">&#123;</span><br><span class="line">    void response(); //反应</span><br><span class="line">&#125;</span><br><span class="line">//具体观察者1</span><br><span class="line">class ConcreteObserver1 implements Observer</span><br><span class="line">&#123;</span><br><span class="line">    public void response()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体观察者1作出反应！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//具体观察者1</span><br><span class="line">class ConcreteObserver2 implements Observer</span><br><span class="line">&#123;</span><br><span class="line">    public void response()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体观察者2作出反应！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式是通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据。现在我们来分析其基本结构与实现方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Aggregate ag=<span class="keyword">new</span> ConcreteAggregate(); </span><br><span class="line">        ag.add(<span class="string">"中山大学"</span>); </span><br><span class="line">        ag.add(<span class="string">"华南理工"</span>); </span><br><span class="line">        ag.add(<span class="string">"韶关学院"</span>);</span><br><span class="line">        System.out.print(<span class="string">"聚合的内容有："</span>);</span><br><span class="line">        Iterator it=ag.getIterator(); </span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        &#123; </span><br><span class="line">            Object ob=it.next(); </span><br><span class="line">            System.out.print(ob.toString()+<span class="string">"\t"</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        Object ob=it.first();</span><br><span class="line">        System.out.println(<span class="string">"\nFirst："</span>+ob.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象聚合</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体聚合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list=<span class="keyword">new</span> ArrayList&lt;Object&gt;(); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        list.add(obj); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        list.remove(obj); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span>(<span class="keyword">new</span> ConcreteIterator(list)); </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list=<span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index=-<span class="number">1</span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(List&lt;Object&gt; list)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.list=list; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(index&lt;list.size()-<span class="number">1</span>)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">first</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        index=<span class="number">0</span>;</span><br><span class="line">        Object obj=list.get(index);;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        Object obj=<span class="keyword">null</span>; </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.hasNext())</span><br><span class="line">        &#123; </span><br><span class="line">            obj=list.get(++index); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> obj; </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Context c=<span class="keyword">new</span> Context();</span><br><span class="line">        Strategy s=<span class="keyword">new</span> ConcreteStrategyA();</span><br><span class="line">        c.setStrategy(s);</span><br><span class="line">        c.strategyMethod();</span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line">        s=<span class="keyword">new</span> ConcreteStrategyB();</span><br><span class="line">        c.setStrategy(s);</span><br><span class="line">        c.strategyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象策略类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span></span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span></span>;    <span class="comment">//策略方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体策略A的策略方法被访问！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"具体策略B的策略方法被访问！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Strategy <span class="title">getStrategy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(Strategy strategy)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy=strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        strategy.strategyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者（Mediator）模式的定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。</p>
<p>中介者模式是一种对象行为型模式，其主要优点如下。</p>
<ol>
<li>降低了对象之间的耦合性，使得对象易于独立地被复用。</li>
<li>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</li>
</ol>
<p>其主要缺点是：当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MediatorPattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Mediator md=new ConcreteMediator();</span><br><span class="line">        Colleague c1,c2;</span><br><span class="line">        c1=new ConcreteColleague1();</span><br><span class="line">        c2=new ConcreteColleague2();</span><br><span class="line">        md.register(c1);</span><br><span class="line">        md.register(c2);</span><br><span class="line">        c1.send();</span><br><span class="line">        System.out.println(&quot;-------------&quot;);</span><br><span class="line">        c2.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象中介者</span><br><span class="line">abstract class Mediator</span><br><span class="line">&#123;</span><br><span class="line">    public abstract void register(Colleague colleague);</span><br><span class="line">    public abstract void relay(Colleague cl); //转发</span><br><span class="line">&#125;</span><br><span class="line">//具体中介者</span><br><span class="line">class ConcreteMediator extends Mediator</span><br><span class="line">&#123;</span><br><span class="line">    private List&lt;Colleague&gt; colleagues=new ArrayList&lt;Colleague&gt;();</span><br><span class="line">    public void register(Colleague colleague)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!colleagues.contains(colleague))</span><br><span class="line">        &#123;</span><br><span class="line">            colleagues.add(colleague);</span><br><span class="line">            colleague.setMedium(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void relay(Colleague cl)</span><br><span class="line">    &#123;</span><br><span class="line">        for(Colleague ob:colleagues)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!ob.equals(cl))</span><br><span class="line">            &#123;</span><br><span class="line">                ((Colleague)ob).receive();</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象同事类</span><br><span class="line">abstract class Colleague</span><br><span class="line">&#123;</span><br><span class="line">    protected Mediator mediator;</span><br><span class="line">    public void setMedium(Mediator mediator)</span><br><span class="line">    &#123;</span><br><span class="line">        this.mediator=mediator;</span><br><span class="line">    &#125;   </span><br><span class="line">    public abstract void receive();   </span><br><span class="line">    public abstract void send();</span><br><span class="line">&#125;</span><br><span class="line">//具体同事类</span><br><span class="line">class ConcreteColleague1 extends Colleague</span><br><span class="line">&#123;</span><br><span class="line">    public void receive()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体同事类1收到请求。&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">    public void send()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体同事类1发出请求。&quot;);</span><br><span class="line">        mediator.relay(this); //请中介者转发</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//具体同事类</span><br><span class="line">class ConcreteColleague2 extends Colleague</span><br><span class="line">&#123;</span><br><span class="line">    public void receive()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体同事类2收到请求。&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">    public void send()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体同事类2发出请求。&quot;);</span><br><span class="line">        mediator.relay(this); //请中介者转发</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录（Memento）模式的定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。</p>
<p>备忘录模式是一种对象行为型模式，其主要优点如下。</p>
<ul>
<li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li>
<li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li>
<li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li>
</ul>
<p>其主要缺点是：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MementoPattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Originator or=new Originator();</span><br><span class="line">        Caretaker cr=new Caretaker();       </span><br><span class="line">        or.setState(&quot;S0&quot;); </span><br><span class="line">        System.out.println(&quot;初始状态:&quot;+or.getState());           </span><br><span class="line">        cr.setMemento(or.createMemento()); //保存状态      </span><br><span class="line">        or.setState(&quot;S1&quot;); </span><br><span class="line">        System.out.println(&quot;新的状态:&quot;+or.getState());        </span><br><span class="line">        or.restoreMemento(cr.getMemento()); //恢复状态</span><br><span class="line">        System.out.println(&quot;恢复状态:&quot;+or.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//备忘录</span><br><span class="line">class Memento</span><br><span class="line">&#123; </span><br><span class="line">    private String state; </span><br><span class="line">    public Memento(String state)</span><br><span class="line">    &#123; </span><br><span class="line">        this.state=state; </span><br><span class="line">    &#125;     </span><br><span class="line">    public void setState(String state)</span><br><span class="line">    &#123; </span><br><span class="line">        this.state=state; </span><br><span class="line">    &#125;</span><br><span class="line">    public String getState()</span><br><span class="line">    &#123; </span><br><span class="line">        return state; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//发起人</span><br><span class="line">class Originator</span><br><span class="line">&#123; </span><br><span class="line">    private String state;     </span><br><span class="line">    public void setState(String state)</span><br><span class="line">    &#123; </span><br><span class="line">        this.state=state; </span><br><span class="line">    &#125;</span><br><span class="line">    public String getState()</span><br><span class="line">    &#123; </span><br><span class="line">        return state; </span><br><span class="line">    &#125;</span><br><span class="line">    public Memento createMemento()</span><br><span class="line">    &#123; </span><br><span class="line">        return new Memento(state); </span><br><span class="line">    &#125; </span><br><span class="line">    public void restoreMemento(Memento m)</span><br><span class="line">    &#123; </span><br><span class="line">        this.setState(m.getState()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">//管理者</span><br><span class="line">class Caretaker</span><br><span class="line">&#123; </span><br><span class="line">    private Memento memento;       </span><br><span class="line">    public void setMemento(Memento m)</span><br><span class="line">    &#123; </span><br><span class="line">        memento=m; </span><br><span class="line">    &#125;</span><br><span class="line">    public Memento getMemento()</span><br><span class="line">    &#123; </span><br><span class="line">        return memento; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="访问者模式-1"><a href="#访问者模式-1" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>问者（Visitor）模式的定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。</p>
<p>访问者（Visitor）模式是一种对象行为型模式，其主要优点如下。</p>
<ol>
<li>扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li>
<li>复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</li>
<li>灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</li>
<li>符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</li>
</ol>
<p>访问者（Visitor）模式的主要缺点如下。</p>
<ol>
<li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</li>
<li>破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。</li>
<li>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisitorPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ObjectStructure os=<span class="keyword">new</span> ObjectStructure();</span><br><span class="line">        os.add(<span class="keyword">new</span> ConcreteElementA());</span><br><span class="line">        os.add(<span class="keyword">new</span> ConcreteElementB());</span><br><span class="line">        Visitor visitor=<span class="keyword">new</span> ConcreteVisitorA();</span><br><span class="line">        os.accept(visitor);</span><br><span class="line">        System.out.println(<span class="string">"------------------------"</span>);</span><br><span class="line">        visitor=<span class="keyword">new</span> ConcreteVisitorB();</span><br><span class="line">        os.accept(visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象访问者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体访问者A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorA</span> <span class="keyword">implements</span> <span class="title">Visitor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体访问者A访问--&gt;"</span>+element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体访问者A访问--&gt;"</span>+element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体访问者B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorB</span> <span class="keyword">implements</span> <span class="title">Visitor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体访问者B访问--&gt;"</span>+element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体访问者B访问--&gt;"</span>+element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象元素类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Element</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体元素A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementA</span> <span class="keyword">implements</span> <span class="title">Element</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operationA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"具体元素A的操作。"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体元素B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementB</span> <span class="keyword">implements</span> <span class="title">Element</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operationB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"具体元素B的操作。"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象结构角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span></span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> List&lt;Element&gt; list=<span class="keyword">new</span> ArrayList&lt;Element&gt;();   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Iterator&lt;Element&gt; i=list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(i.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            ((Element) i.next()).accept(visitor);</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Element element)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        list.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Element element)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        list.remove(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题整理</title>
    <url>/2020/02/15/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="private的问题"><a href="#private的问题" class="headerlink" title="private的问题"></a>private的问题</h3><p>private修饰的方法属性可以通过反射访问，那么private的意义是什么？</p>
<p>简单来说，private并不是解决“安全”问题的。 安全是指不让代码被非法看到/访问。但是只要人能拿到代码，总会有办法去查看和改变代码。可以用SecurityManager来防止private被访问，但是任然有其他各种方式拿到java的bytecode，并做任意修改。比如有asm这样的lib，也有instrument api这种东西。c++这种语言还能通过指针跳过private</p>
<p>回答：1：private并不是保证安全性的关键字。 是对开发的一种约束，强调的是OOP的封装概念，</p>
<p>​            2：从外部对对象进行常规调用时，不能够看到清晰的类结构和属性。</p>
<h3 id="类初始化顺序"><a href="#类初始化顺序" class="headerlink" title="类初始化顺序"></a>类初始化顺序</h3><p>类的初始化顺序，我以前只知道先初始化基类在初始化派生类，忽略了代码块儿的问题，正确的顺序应该是</p>
<p>基类的静态：正确的顺序是</p>
<p>基类静态代码块，基类静态成员字段（并列优先级，按照代码中出现的先后顺序执行，且只有第一次加载时执行）——&gt;派生类静态代码块，派生类静态成员字段（并列优先级，按照代码中出现的先后顺序执行，且只有第一次加载时执行）——&gt;基类普通代码块，基类普通成员字段（并列优点级，按代码中出现先后顺序执行）——&gt;基类构造函数——&gt;派生类普通代码块，派生类普通成员字段（并列优点级，按代码中出现先后顺序执行）——&gt;派生类构造函数</p>
<p>基本上写个例子就可以测试出结果</p>
<h3 id="clone方法"><a href="#clone方法" class="headerlink" title="clone方法"></a>clone方法</h3><p>基本数据类型(char ,short,int,long,float,double,byte,boolean)在传递的时候是按值传递，对象类型是按引用传递，（java在new 语句之后返回的是对象的指引用）,实际过程中经常会遇见复制一个已有的对象A到另一个具有相同状态的对象B,而且对B的修改不影响A。实现clone方法的实体需要继承Cloneable接口。深拷贝和浅拷贝最根本的区别在于是否真正获取一个对象的复制实体，而不是引用。假设B复制了A，修改A的时候，看B是否发生变化：</p>
<p>如果B跟着也变了，说明是浅拷贝，拿人手短！（修改堆内存中的同一个值）</p>
<p>如果B没有改变，说明是深拷贝，自食其力！（修改堆内存中的不同的值）</p>
<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>反射及智能在运行时对类进行装载，能够增加程序的灵活性，反射主要用来得到一个对象所属的类，获取类的成员方法和变量，在运行时创建对象，调用对象的方法。java创建对象的方法  new,反射，clone,反序列化</p>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>在C++中有一个概念-函数指针，其中最重要的功能是函数回调，利用函数的回调函数来编写程序，传递一个函数的指针参数来调用下一个函数，java中没有指针的概念，但是可以通过接口和类实现相同 的功能。在接口参数接受一个interface参数，来执行回调方法。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象是将数据和对数据的操作方法集中放在一起，作为一个相互依赖的整体，即对象，对象通过接口与外部发生交流。</p>
<p>面向对象主要有三个特征，继承、封装、多态</p>
<p>封装是将数据和方法抽象成 类，在对自身的数据方法进行保护，可以把自己的数据和方法让可信的类或对象进行操作，对不可信的数据方法进行隐藏。</p>
<p>继承是一种联结类的层次模型，允许和鼓励类的重用，提供了明确的表达共性的方法。派生类可以从基类中获取继承的方法和变量 </p>
<p>多态 允许不同类的对象对统一消息做出响应，包含参数化多态和包含多态。</p>
<h3 id="多态的实现机制"><a href="#多态的实现机制" class="headerlink" title="多态的实现机制"></a>多态的实现机制</h3><p>编译时多态和运行时多态。编译时通过方法的重载实现，运行时多态是通过方法的覆盖，继承方法是重写</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程是指程序在运行过程中，能够执行代码的一个执行单元。进程是一段正在执行程序的抽象。 java中线程的状态：<em>就绪、运行、挂起、结束</em></p>
<h2 id="java-实现线程的方式"><a href="#java-实现线程的方式" class="headerlink" title="java 实现线程的方式"></a>java 实现线程的方式</h2><p>1：类继承Thread  2：实现Runnable接口  3.继承Callable<t>接口</t></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest3</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"有返回值的线程"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ExecutorService threadPool = Executors.newSingleThreadExecutor();</span><br><span class="line">            Future&lt;String&gt; future = threadPool.submit(<span class="keyword">new</span> ThreadTest3());</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="run-与start-方法的区别"><a href="#run-与start-方法的区别" class="headerlink" title="run()与start()方法的区别"></a>run()与start()方法的区别</h2><p>一般系统通过调用start()方法来启用一个线程，此时该线程处于就绪的状态，而非运行状态，此时这个线程可以被JVM调用，调用的时候在通过run()方法来完成实际的操作。方法结束后该线程终止。</p>
<p>如果直接调用run()方法，这会被当成普通函数调用，程序中仍然只有主线程。程序是同步的，达不到多线程的目的。</p>
<h2 id="多线程同步的方法"><a href="#多线程同步的方法" class="headerlink" title="多线程同步的方法"></a>多线程同步的方法</h2><p>在多线程环境中，访问数据是一个很危险的事情，很容易出现数据的安全问题。因此java提供了几种实现同步机制的方法。</p>
<h3 id="1synchronzied关键字"><a href="#1synchronzied关键字" class="headerlink" title="1synchronzied关键字"></a>1synchronzied关键字</h3><p>主要有两种用法 synchronzied方法和synchronzied代码块</p>
<p>java中synchronzied的实现与Monitor相关，java中的所有对象都拥有一个私有线程锁或则成为Monitor锁，Monitor中的Owner字段表明该对象是否被线程拥有Monitor record。</p>
<h3 id="notify-与wait-方法"><a href="#notify-与wait-方法" class="headerlink" title="notify()与wait()方法"></a>notify()与wait()方法</h3><p>synchronzied锁住某个对象或者资源的时候，线程A1在执行synchronzied代码，线程A2也在执行synchronzied代码，线程A2要等待A1执行完成之后才能执行，这种情况下就可以使用wait()和notif()。synchronzied在执行期间，可以使用wait()方法释放对象锁，进入等待状态，并可以调用notif()提醒其他等待的线程。fei</p>
<h3 id="2重入锁ReentrantLock"><a href="#2重入锁ReentrantLock" class="headerlink" title="2重入锁ReentrantLock"></a>2重入锁ReentrantLock</h3><p>jdk 5添加了Lock接口和她的实现类，Lock也可以用来实现同步。</p>
<p>Lock()方法。以阻塞的方式获取锁，如果获取到锁，立刻返回，没有获取锁则继续等待。</p>
<p>tryLock()非阻塞的方式获取锁，获取到锁立刻返回true,未获取到锁返回false</p>
<p>lockInterruptibly() 如果获取到了锁，立刻返回，没有获取到锁，当前线程处于休眠状态，直到获取到锁，或者当前线程被别的线程中断。</p>
<h3 id="sleep-和wait-方法的区别"><a href="#sleep-和wait-方法的区别" class="headerlink" title="sleep()和wait()方法的区别"></a>sleep()和wait()方法的区别</h3><p>sleep()方法是Thread类的静态方法，是线程用来控制自身的，他会使线程暂停一段时间，等时间一到，该线程会自动苏醒。而wwait()方法是Object类的方法，这个方法会使拥有该对象锁的进程等待，知道其他线程调用notify()方法来唤醒</p>
<p>对锁的处理机制不同：sleep()方法的主要作用是线程暂停一段时间，时间到了会自动恢复，所以sleep()不会释放锁，而wait()主要应用于线程间的通信，当线程调用wait()方法后，线程会释放掉他拥有的锁。</p>
<h2 id="终止线程的方法"><a href="#终止线程的方法" class="headerlink" title="终止线程的方法"></a>终止线程的方法</h2><p>java语言中可以使用stop()和suspend()方法来终止线程的执行。stop()方法会释放已经锁定的所有监视资源。</p>
<p>而suspend()方法不会释放锁，这就会导致，如果使用suspend()挂起一个线程，那么在锁恢复之前不会被释放，这就很容易导致死锁。所以Java语言不建议上述两种方法来终止线程。一般建议是让线程自行结束进入Dead，即执行完Run()方法。提供某种方式能使线程跑完run()方法。例如可以通过interrupt()等异常</p>
<h2 id="synchronized和lock"><a href="#synchronized和lock" class="headerlink" title="synchronized和lock"></a>synchronized和lock</h2><p>用法不同：在需要同步的对象中加入synchronized控制，既可以加在方法上，也可以加在代码块儿中,而Lock需要显示的指定起始位置和结束位置。</p>
<p>性能不同：synchronized在资源竞争不激烈的时候，性能优于ReetrantLock,竞争激烈的时候，synchronized的性能下降的非常快，而ReetrantLock的性能基本保持不变</p>
<p>锁机制不同：synchronized获取锁和释放都在块结构中。获取多个锁时，必须以相反的顺序释放，而且是自动释放，而Lock需要开发人员手动释放，一般在finally里卖弄释放，否则可能会引起死锁 的问题。</p>
<p>当一个线程进入了synchronized方法里面，其他线程能否访问其他方法取决于这个方法。如果访问的其他方法是非synchronized的，其他线程可以访问。如果其他方法是静态的synchronized方法，静态synchronized方法仍然可以被调用。</p>
<h2 id="join-方法的作用"><a href="#join-方法的作用" class="headerlink" title="join()方法的作用"></a>join()方法的作用</h2><p>join()方法是让调用该方法的线程在执行完run()方法滞后，再执行join()方法，主要用于线程同步。或者使用该线程的join(2000)方法来等待该线程，设置等待时间。</p>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h1 id="虚拟机（JVM）"><a href="#虚拟机（JVM）" class="headerlink" title="虚拟机（JVM）"></a>虚拟机（JVM）</h1><h2 id="方法区和永久区的理解"><a href="#方法区和永久区的理解" class="headerlink" title="方法区和永久区的理解"></a>方法区和永久区的理解</h2><h1 id="spring-IOC和AOP"><a href="#spring-IOC和AOP" class="headerlink" title="spring IOC和AOP"></a>spring IOC和AOP</h1><p>先解释一下IOC和AOP, </p>
<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>许多应用都是通过彼此间的相互合作来实现业务逻辑的，如类A要调用类B的方法，以前我们都是在类A中，通过自身<strong><em>new</em></strong>一个类B，然后在调用类B的方法，现在我们把new类B的事情交给spring来做，在我们调用的时候，容器会为我们实例化。 IOC容器的初始化过程资源定位，即定义bean的xml——-》载入——–》IOC容器注册，注册beanDefinition,现在的常用方式是基于注解，bean的创建方式是通过<strong>工厂模式</strong>，数据通过<strong>反射</strong>的方式注入</p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p> 面向切面编程，在我们的应用中，经常需要做一些事情，但是这些事情与核心业务无关，比如，要记录所有update*方法的执行时间时间，操作人等等信息。AOP的实现原理就代理方式 有两只，动态代理和静态代理</p>
]]></content>
      <categories>
        <category>java面试</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle 打包</title>
    <url>/2020/01/13/gradle-%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">	apply <span class="string">plugin:</span> <span class="string">"java"</span></span><br><span class="line">	<span class="comment">//打包插件，不含第三方依赖jar</span></span><br><span class="line">    apply <span class="string">plugin:</span> <span class="string">"maven-publish"</span></span><br><span class="line">    apply <span class="string">plugin:</span> <span class="string">'idea'</span></span><br><span class="line"></span><br><span class="line">    version = <span class="string">'1.0.0'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// JVM 版本号要求</span></span><br><span class="line">    sourceCompatibility = <span class="number">1.8</span></span><br><span class="line">    targetCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// java编译的时候缺省状态下会因为中文字符而失败</span></span><br><span class="line">    [compileJava, compileTestJava, javadoc]*.options*.encoding = <span class="string">'UTF-8'</span></span><br><span class="line"></span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenLocal()</span><br><span class="line">        maven &#123; url <span class="string">"http://maven.aliyun.com/nexus/content/groups/public"</span> &#125;</span><br><span class="line">        mavenCentral()</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123; url <span class="string">"http://repo.spring.io/snapshot"</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">"http://repo.spring.io/milestone"</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'http://maven.springframework.org/release'</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'http://maven.springframework.org/milestone'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jar &#123;</span><br><span class="line">        manifest &#123;</span><br><span class="line">            attributes(<span class="string">"Implementation-Title"</span>: <span class="string">"Gradle"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示当前项目下所有用于 compile 的 jar.</span></span><br><span class="line">    task listJars(<span class="string">description:</span> <span class="string">'Display all compile jars.'</span>) &lt;&lt; &#123;</span><br><span class="line">        configurations.compile.each &#123; File file -&gt; println file.name &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gradle.projectsEvaluated &#123;</span><br><span class="line">        tasks.withType(JavaCompile) &#123;</span><br><span class="line">            options.compilerArgs &lt;&lt; <span class="string">"-Xlint:unchecked"</span> &lt;&lt; <span class="string">"-Xlint:deprecation"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    task <span class="string">"create-dirs"</span> &lt;&lt; &#123;</span><br><span class="line">        sourceSets*.java.srcDirs*.each &#123;</span><br><span class="line">            it.mkdirs()</span><br><span class="line">        &#125;</span><br><span class="line">        sourceSets*.resources.srcDirs*.each&#123;</span><br><span class="line">            it.mkdirs()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ext &#123;</span><br><span class="line">        set(<span class="string">'springCloudVersion'</span>, <span class="string">"Dalston.SR5"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line"><span class="comment">//        compile group: 'org.springframework.boot', name: 'spring-boot-starter-data-jpa', version: '2.1.4.RELEASE'</span></span><br><span class="line">        compile <span class="string">group:</span> <span class="string">'org.springframework.boot'</span>, <span class="string">name:</span> <span class="string">'spring-boot-starter-data-jpa'</span>, <span class="string">version:</span> <span class="string">'2.2.2.RELEASE'</span></span><br><span class="line">        compile <span class="string">group:</span> <span class="string">'org.springframework.boot'</span>, <span class="string">name:</span> <span class="string">'spring-boot-starter-web'</span>, <span class="string">version:</span> <span class="string">'2.2.2.RELEASE'</span></span><br><span class="line">        <span class="comment">// https://mvnrepository.com/artifact/org.projectlombok/lombok</span></span><br><span class="line">        compile <span class="string">group:</span> <span class="string">'org.projectlombok'</span>, <span class="string">name:</span> <span class="string">'lombok'</span>, <span class="string">version:</span> <span class="string">'1.18.8'</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置动态属性</span></span><br><span class="line">    ext &#123;</span><br><span class="line">        <span class="comment">//发布到仓库用户名</span></span><br><span class="line">        publishUserName = <span class="string">"dawei"</span></span><br><span class="line">        <span class="comment">//发布到仓库地址</span></span><br><span class="line">        publishUserPassword = <span class="string">"qq1235789"</span></span><br><span class="line">        <span class="comment">//仓库地址</span></span><br><span class="line">        publishURL = <span class="string">"http://47.102.99.93:8081/repository/panghu/"</span></span><br><span class="line"></span><br><span class="line">        apiBaseJarName = <span class="string">"base"</span></span><br><span class="line">        apiBaseJarVersion = <span class="string">'0.0.1'</span></span><br><span class="line">        builtBy = <span class="string">"gradle 1.9"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//jar包名称组成：[baseName]-[appendix]-[version]-[classifier].[extension]</span></span><br><span class="line"><span class="comment">//打包class文件</span></span><br><span class="line">    task apiBaseJar(<span class="string">type:</span>Jar)&#123;</span><br><span class="line">        version apiBaseJarVersion</span><br><span class="line">        baseName apiBaseJarName</span><br><span class="line">        from sourceSets.main.output</span><br><span class="line">        destinationDir file(<span class="string">"$buildDir/api-libs"</span>)</span><br><span class="line">        includes [<span class="string">'com/example/**'</span>]</span><br><span class="line">        manifest &#123;</span><br><span class="line">            attributes <span class="string">'packageName'</span>: apiBaseJarName, <span class="string">'Built-By'</span>: builtBy,<span class="string">'Built-date'</span>: <span class="keyword">new</span> Date().format(<span class="string">'yyyy-MM-dd HH:mm:ss'</span>),<span class="string">'Manifest-Version'</span>:version</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//打包源码</span></span><br><span class="line">    task apiBaseSourceJar(<span class="string">type:</span>Jar)&#123;</span><br><span class="line">        version apiBaseJarVersion</span><br><span class="line">        baseName apiBaseJarName</span><br><span class="line">        classifier <span class="string">"sources"</span></span><br><span class="line">        from sourceSets.main.allSource</span><br><span class="line">        destinationDir file(<span class="string">"$buildDir/api-libs"</span>)</span><br><span class="line">        includes [<span class="string">'com/example/**'</span>]</span><br><span class="line">        manifest &#123;</span><br><span class="line">            attributes <span class="string">'packageName'</span>: apiBaseJarName+<span class="string">'-sources'</span>, <span class="string">'Built-By'</span>: builtBy,<span class="string">'Built-date'</span>: <span class="keyword">new</span> Date().format(<span class="string">'yyyy-MM-dd HH:mm:ss'</span>),<span class="string">'Manifest-Version'</span>:version</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//上传jar包</span></span><br><span class="line">    publishing &#123;</span><br><span class="line">        publications &#123;</span><br><span class="line">            publishing.publications.create(<span class="string">'apiBase'</span>, MavenPublication) &#123;</span><br><span class="line">                groupId <span class="string">'base-core'</span></span><br><span class="line">                artifactId apiBaseJarName</span><br><span class="line">                version apiBaseJarVersion</span><br><span class="line">                <span class="comment">//同时上传class包和源码包</span></span><br><span class="line">                artifacts = [apiBaseJar, apiBaseSourceJar]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        repositories &#123;</span><br><span class="line">            maven &#123;</span><br><span class="line">                url publishURL</span><br><span class="line">                credentials &#123;</span><br><span class="line">                    username = publishUserName</span><br><span class="line">                    password = publishUserPassword</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>spring cloud 集成练习项目</title>
    <url>/2019/12/15/spring-cloud-%E9%9B%86%E6%88%90%E7%BB%83%E4%B9%A0%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="创建服务注册中心-（eureka）"><a href="#创建服务注册中心-（eureka）" class="headerlink" title="创建服务注册中心 （eureka）"></a>创建服务注册中心 （eureka）</h1><p>环境配置:</p>
<p>JDK 1.8</p>
<p>spring cloud version:Greenwich.SR1</p>
<p>spring boot version:2.1.5.RELEASE</p>
<p>eureka-server作为服务发现的核心，第一个搭建，后面的服务都要注册到eureka-server上，意思是告诉eureka-server自己的服务地址是啥。当然还可以用zookeeper或者spring consul。</p>
<p>这里我用的gradle构建的项目，再build.gradle中添加依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">	id <span class="string">'org.springframework.boot'</span> version <span class="string">'2.2.2.RELEASE'</span></span><br><span class="line">	id <span class="string">'io.spring.dependency-management'</span> version <span class="string">'1.0.8.RELEASE'</span></span><br><span class="line">	id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'idea'</span></span><br><span class="line">group = <span class="string">'com.example'</span></span><br><span class="line">version = <span class="string">'0.0.3'</span></span><br><span class="line">sourceCompatibility = <span class="string">'1.8'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">	mavenCentral()</span><br><span class="line"><span class="comment">//	maven &#123; url "http://maven.aliyun.com/nexus/content/groups/public/" &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">	set(<span class="string">'springCloudVersion'</span>, <span class="string">"Hoxton.RELEASE"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">	implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-eureka-server'</span></span><br><span class="line">	compile(<span class="string">'org.springframework.boot:spring-boot-starter-security'</span>)</span><br><span class="line">	testImplementation(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>) &#123;</span><br><span class="line">		exclude <span class="string">group:</span> <span class="string">'org.junit.vintage'</span>, <span class="string">module:</span> <span class="string">'junit-vintage-engine'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencyManagement &#123;</span><br><span class="line">	imports &#123;</span><br><span class="line">		mavenBom <span class="string">"org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">	useJUnitPlatform()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jar &#123;</span><br><span class="line">    String someString = <span class="string">''</span></span><br><span class="line">    configurations.runtime.each &#123; someString = someString + <span class="string">" lib\\"</span> + it.name &#125;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes <span class="string">'Main-Class'</span>: <span class="string">'com.each.dubboMainEnd'</span></span><br><span class="line">        attributes <span class="string">'Class-Path'</span>: someString</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task copyJar(<span class="string">type:</span>Copy)&#123;</span><br><span class="line">    from configurations.runtime</span><br><span class="line">    into (<span class="string">'build/libs/lib'</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task release(<span class="string">type:</span> Copy,<span class="string">dependsOn:</span> [build,copyJar]) &#123;</span><br><span class="line"><span class="comment">//    from  'conf'</span></span><br><span class="line">    <span class="comment">//   into ('build/libs/eachend/conf')</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在resurce下的application.properties修改配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">5678</span></span><br><span class="line"><span class="meta">spring.security.user.roles</span>=<span class="string">SUPERUSER</span></span><br><span class="line"><span class="meta">spring.security.user.name</span>=<span class="string">wxy</span></span><br><span class="line"><span class="meta">spring.security.user.password</span>=<span class="string">wxy123</span></span><br><span class="line"><span class="meta">eureka.client.register-with-eureka</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">eureka.client.fetch-registry</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">eureka.instance.hostname</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://wxy:wxy123@localhost:5678/eureka</span></span><br></pre></td></tr></table></figure>
<p>在启动类上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableEurekaServer</span> <span class="comment">//启动服务注册中心</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudEurekaServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(CloudEurekaServiceApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动服务，访问<a href="http://localhost:5678/，出现登陆页面，输入账号密码，就可以访问到注册中心" target="_blank" rel="noopener">http://localhost:5678/，出现登陆页面，输入账号密码，就可以访问到注册中心</a></p>
<h1 id="创建config-server分布式配置中心服务（git版）"><a href="#创建config-server分布式配置中心服务（git版）" class="headerlink" title="创建config-server分布式配置中心服务（git版）"></a>创建config-server分布式配置中心服务（git版）</h1><p>首先要准备一个<a href="https://github.com/pignum1/config" target="_blank" rel="noopener">git仓库</a>,然后新建一个springboot项目，修改build.gradle</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">	id <span class="string">'org.springframework.boot'</span> version <span class="string">'2.2.2.RELEASE'</span></span><br><span class="line">	id <span class="string">'io.spring.dependency-management'</span> version <span class="string">'1.0.8.RELEASE'</span></span><br><span class="line">	id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'idea'</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">'com.example'</span></span><br><span class="line">version = <span class="string">'0.0.4'</span></span><br><span class="line">sourceCompatibility = <span class="string">'1.8'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">	mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">	set(<span class="string">'springCloudVersion'</span>, <span class="string">"Hoxton.SR1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">	implementation <span class="string">'org.springframework.cloud:spring-cloud-config-server'</span></span><br><span class="line">	implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'</span></span><br><span class="line"><span class="comment">//	implementation 'org.springframework.cloud:spring-cloud-starter-security'</span></span><br><span class="line">	compile(<span class="string">'org.springframework.boot:spring-boot-starter-security'</span>)</span><br><span class="line"></span><br><span class="line">	compile(<span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span>)</span><br><span class="line">	testImplementation(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>) &#123;</span><br><span class="line">		exclude <span class="string">group:</span> <span class="string">'org.junit.vintage'</span>, <span class="string">module:</span> <span class="string">'junit-vintage-engine'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencyManagement &#123;</span><br><span class="line">	imports &#123;</span><br><span class="line">		mavenBom <span class="string">"org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">	useJUnitPlatform()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jar &#123;</span><br><span class="line">	String someString = <span class="string">''</span></span><br><span class="line">	configurations.runtime.each &#123; someString = someString + <span class="string">" lib\\"</span> + it.name &#125;</span><br><span class="line">	manifest &#123;</span><br><span class="line">		attributes <span class="string">'Main-Class'</span>: <span class="string">'com.each.dubboMainEnd'</span></span><br><span class="line">		attributes <span class="string">'Class-Path'</span>: someString</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task copyJar(<span class="string">type:</span>Copy)&#123;</span><br><span class="line">	from configurations.runtime</span><br><span class="line">	into (<span class="string">'build/libs/lib'</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task release(<span class="string">type:</span> Copy,<span class="string">dependsOn:</span> [build,copyJar]) &#123;</span><br><span class="line"><span class="comment">//    from  'conf'</span></span><br><span class="line">	<span class="comment">//   into ('build/libs/eachend/conf')</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改配置application.yml,添加仓库配置和自动刷新配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5679</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">basic:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">wxy</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">wxy123</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-server</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://github.com/pignum1/config.git</span></span><br><span class="line">          <span class="attr">searchPaths:</span> <span class="string">'&#123;application&#125;'</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://wxy:wxy123@47.102.99.93:5678/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;server.port&#125;&#125;</span></span><br><span class="line">    <span class="attr">appname:</span> <span class="string">config-server</span></span><br></pre></td></tr></table></figure>
<p>在启动类上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.configserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.config.server.EnableConfigServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(ConfigServerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动服务配置中心</p>
<h1 id="创建provider生产者"><a href="#创建provider生产者" class="headerlink" title="创建provider生产者"></a>创建provider生产者</h1><p>创建springboot项目， 修改build.gradle文件</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile(<span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'</span>)</span><br><span class="line">compile(<span class="string">'org.springframework.cloud:spring-cloud-starter-config'</span>)</span><br><span class="line">compile(<span class="string">'org.springframework.boot:spring-boot-starter-webflux'</span>)</span><br><span class="line">compile(<span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span>)</span><br><span class="line">compile(<span class="string">'org.springframework.cloud:spring-cloud-starter-openfeign'</span>)</span><br><span class="line">compile(<span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-hystrix'</span>)</span><br></pre></td></tr></table></figure>
<p>创建bootstrap.properties文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#datasource</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/cloud?useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">dawei</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">WEIxy.789</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.jackson.date-format</span>=<span class="string">yyyy-MM-dd HH:mm:ss</span></span><br><span class="line"><span class="meta">spring.jackson.time-zone</span>=<span class="string">GMT+8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.jpa.properties.hibernate.hbm2ddl.auto</span>=<span class="string">update</span></span><br><span class="line"><span class="meta">spring.jpa.database-platform</span>=<span class="string">org.hibernate.dialect.MySQL5Dialect</span></span><br><span class="line"><span class="meta">spring.datasource.dbcp.max-wait</span>=<span class="string">300</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">provider</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">5682</span></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://wxy:wxy123@localhost:5678/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.instance.status-page-url</span>=<span class="string">http://$&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;/swagger-ui.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#心跳频率</span></span><br><span class="line"><span class="meta">eureka.instance.lease-renewal-interval-in-seconds</span>=<span class="string">5</span></span><br><span class="line"><span class="meta">eureka.instance.lease-expiration-duration-in-seconds</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure>
<p>修改启动类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//@EnableSwagger2</span><br><span class="line">@SpringCloudApplication</span><br><span class="line">//@EntityScan(&quot;com.example.provider&quot;)</span><br><span class="line">//@EnableJpaRepositories(&quot;com.example.provider&quot;)</span><br><span class="line">@EnableJpaAuditing</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建服务生产类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/hello&quot;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDao userDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ProviderDao providerDao;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;打个招呼&quot;, notes = &quot;打个招呼&quot;)</span><br><span class="line">    @PostMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello(@RequestParam String name ) &#123;</span><br><span class="line">//        Provider</span><br><span class="line">        return &quot;你好啊!&quot;+name ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="创建服务消费者consumer服务"><a href="#创建服务消费者consumer服务" class="headerlink" title="创建服务消费者consumer服务"></a>创建服务消费者consumer服务</h1><p>新建一个spring boot服务, 修改buid.gradle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">	id &apos;org.springframework.boot&apos; version &apos;2.2.4.RELEASE&apos;</span><br><span class="line">	id &apos;io.spring.dependency-management&apos; version &apos;1.0.9.RELEASE&apos;</span><br><span class="line">	id &apos;java&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group = &apos;com.example&apos;</span><br><span class="line">version = &apos;0.0.1-SNAPSHOT&apos;</span><br><span class="line">sourceCompatibility = &apos;1.8&apos;</span><br><span class="line"></span><br><span class="line">configurations &#123;</span><br><span class="line">	developmentOnly</span><br><span class="line">	runtimeClasspath &#123;</span><br><span class="line">		extendsFrom developmentOnly</span><br><span class="line">	&#125;</span><br><span class="line">	compileOnly &#123;</span><br><span class="line">		extendsFrom annotationProcessor</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">	mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">	set(&apos;springCloudVersion&apos;, &quot;Hoxton.SR1&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">	implementation &apos;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&apos;</span><br><span class="line">	compile(&apos;org.springframework.cloud:spring-cloud-starter-config&apos;)</span><br><span class="line">	compile(&apos;org.springframework.boot:spring-boot-starter-webflux&apos;)</span><br><span class="line">	compile(&apos;org.springframework.boot:spring-boot-starter-actuator&apos;)</span><br><span class="line">	compile(&apos;org.springframework.cloud:spring-cloud-starter-openfeign&apos;)</span><br><span class="line">	compile(&apos;org.springframework.cloud:spring-cloud-starter-netflix-hystrix&apos;)</span><br><span class="line">	compileOnly &apos;org.projectlombok:lombok&apos;</span><br><span class="line">	developmentOnly &apos;org.springframework.boot:spring-boot-devtools&apos;</span><br><span class="line">	annotationProcessor &apos;org.projectlombok:lombok&apos;</span><br><span class="line">	testImplementation(&apos;org.springframework.boot:spring-boot-starter-test&apos;) &#123;</span><br><span class="line">		exclude group: &apos;org.junit.vintage&apos;, module: &apos;junit-vintage-engine&apos;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencyManagement &#123;</span><br><span class="line">	imports &#123;</span><br><span class="line">		mavenBom &quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">	useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改bootstrap.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">consumer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://wxy:wxy123@localhost:5678/eureka/</span></span><br><span class="line"><span class="meta">eureka.instance.prefer-ip-address</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">eureka.instance.instance-id</span>=<span class="string">$&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;server.port&#125;&#125;</span></span><br><span class="line"><span class="meta">eureka.instance.appname</span>=<span class="string">consumer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务配置中心</span></span><br><span class="line"><span class="meta">spring.cloud.config.discovery.service-id</span>=<span class="string">config-server</span></span><br><span class="line"><span class="meta">spring.cloud.config.discovery.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.cloud.config.fail-fast</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.cloud.config.username</span>=<span class="string">wxy</span></span><br><span class="line"><span class="meta">spring.cloud.config.password</span>=<span class="string">wxy123</span></span><br><span class="line"><span class="meta">spring.cloud.config.profile</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure>
<p>启动类修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class ConsumerApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@LoadBalanced</span><br><span class="line">	public RestTemplate restTemplate()&#123;</span><br><span class="line">		RestTemplate restTemplate = new RestTemplate();</span><br><span class="line">		List&lt;HttpMessageConverter&lt;?&gt;&gt; list = restTemplate.getMessageConverters();</span><br><span class="line">		for (HttpMessageConverter&lt;?&gt; httpMessageConverter : list) &#123;</span><br><span class="line">			if(httpMessageConverter instanceof StringHttpMessageConverter) &#123;</span><br><span class="line">				((StringHttpMessageConverter) httpMessageConverter).setDefaultCharset(Charset.forName(&quot;utf-8&quot;));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return restTemplate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建服务调用类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetHello</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/greet"</span>)</span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"fallbackMethod"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHelloWorld</span><span class="params">(String parm)</span> </span>&#123;</span><br><span class="line">        MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> LinkedMultiValueMap&lt;String, String&gt;();</span><br><span class="line">        map.add(<span class="string">"name"</span>,parm);</span><br><span class="line">        String res = <span class="keyword">this</span>.restTemplate.postForObject(<span class="string">"http://provider/hello/hello"</span>, map, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fallbackMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="fegin服务消费者"><a href="#fegin服务消费者" class="headerlink" title="fegin服务消费者"></a>fegin服务消费者</h1><p>使用fegin的方式调用生产者,仍然需要新建一个spring boot项目</p>
<p>引入依赖,修改build.gradle</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">	id <span class="string">'org.springframework.boot'</span> version <span class="string">'2.2.4.RELEASE'</span></span><br><span class="line">	id <span class="string">'io.spring.dependency-management'</span> version <span class="string">'1.0.9.RELEASE'</span></span><br><span class="line">	id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group = <span class="string">'com.example'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="string">'1.8'</span></span><br><span class="line"></span><br><span class="line">configurations &#123;</span><br><span class="line">	developmentOnly</span><br><span class="line">	runtimeClasspath &#123;</span><br><span class="line">		extendsFrom developmentOnly</span><br><span class="line">	&#125;</span><br><span class="line">	compileOnly &#123;</span><br><span class="line">		extendsFrom annotationProcessor</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">	mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">	set(<span class="string">'springCloudVersion'</span>, <span class="string">"Hoxton.SR1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">	implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'</span></span><br><span class="line">	compile(<span class="string">'org.springframework.cloud:spring-cloud-starter-config'</span>)</span><br><span class="line">	compile(<span class="string">'org.springframework.boot:spring-boot-starter-webflux'</span>)</span><br><span class="line">	compile(<span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span>)</span><br><span class="line">	compile(<span class="string">'org.springframework.cloud:spring-cloud-starter-openfeign'</span>)</span><br><span class="line">	compile(<span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-hystrix'</span>)</span><br><span class="line"></span><br><span class="line">	compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line"><span class="comment">// https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-feign</span></span><br><span class="line">	compile <span class="string">group:</span> <span class="string">'org.springframework.cloud'</span>, <span class="string">name:</span> <span class="string">'spring-cloud-starter-feign'</span>, <span class="string">version:</span> <span class="string">'1.4.7.RELEASE'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	compileOnly <span class="string">'org.projectlombok:lombok'</span></span><br><span class="line">	developmentOnly <span class="string">'org.springframework.boot:spring-boot-devtools'</span></span><br><span class="line">	annotationProcessor <span class="string">'org.projectlombok:lombok'</span></span><br><span class="line">	testImplementation(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>) &#123;</span><br><span class="line">		exclude <span class="string">group:</span> <span class="string">'org.junit.vintage'</span>, <span class="string">module:</span> <span class="string">'junit-vintage-engine'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencyManagement &#123;</span><br><span class="line">	imports &#123;</span><br><span class="line">		mavenBom <span class="string">"org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">	useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改application.properties配置，基本和ribbon的配置是一样的,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name=fegin</span><br><span class="line">server.port=5685</span><br><span class="line"></span><br><span class="line">eureka.client.service-url.defaultZone=http://wxy:wxy123@47.102.99.93:5678/eureka/</span><br><span class="line"></span><br><span class="line">eureka.instance.status-page-url=http://$&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;/swagger-ui.html</span><br><span class="line"></span><br><span class="line">#心跳频率</span><br><span class="line">eureka.instance.lease-renewal-interval-in-seconds=5</span><br><span class="line">eureka.instance.lease-expiration-duration-in-seconds=10</span><br></pre></td></tr></table></figure>
<p>创建映射的服务调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"provider"</span>,fallback = FeignClientFallback<span class="class">.<span class="keyword">class</span>, <span class="title">configuration</span> </span>= FeignConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">FeginClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/hello/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">greet</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientFallback</span>  <span class="keyword">implements</span> <span class="title">FeginClient</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">greet</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"greet error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建调用的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">     FeginClient feginClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String  <span class="title">hello</span> <span class="params">( String  name )</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> feginClient.greet(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在启动类上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringCloudApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableHystrix</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.example.*"</span>)</span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeginApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(FeginApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动服务后就可以试着用fegin的方式调用方法打招呼的方法了</p>
<h1 id="创建ZUUL服务网关"><a href="#创建ZUUL服务网关" class="headerlink" title="创建ZUUL服务网关"></a>创建ZUUL服务网关</h1><p>新建一个项目，修改build.gradle</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">	id <span class="string">'org.springframework.boot'</span> version <span class="string">'2.2.4.RELEASE'</span></span><br><span class="line">	id <span class="string">'io.spring.dependency-management'</span> version <span class="string">'1.0.9.RELEASE'</span></span><br><span class="line">	id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group = <span class="string">'com.example'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="string">'1.8'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">	mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">	set(<span class="string">'springCloudVersion'</span>, <span class="string">"Hoxton.SR1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">	implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-zuul'</span></span><br><span class="line"></span><br><span class="line">	compile(<span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'</span>)</span><br><span class="line">	compile(<span class="string">'org.springframework.cloud:spring-cloud-starter-config'</span>)</span><br><span class="line">	compile(<span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span>)</span><br><span class="line">	testImplementation(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>) &#123;</span><br><span class="line">		exclude <span class="string">group:</span> <span class="string">'org.junit.vintage'</span>, <span class="string">module:</span> <span class="string">'junit-vintage-engine'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencyManagement &#123;</span><br><span class="line">	imports &#123;</span><br><span class="line">		mavenBom <span class="string">"org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">	useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建bootstrap.properties，修改配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">zuul</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://wxy:wxy123@localhost:5678/eureka/</span></span><br><span class="line"><span class="meta">eureka.instance.prefer-ip-address</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">eureka.instance.instance-id</span>=<span class="string">$&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;server.port&#125;&#125;</span></span><br><span class="line"><span class="meta">eureka.instance.appname</span>=<span class="string">zuul</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务配置中心</span></span><br><span class="line"><span class="meta">spring.cloud.config.discovery.service-id</span>=<span class="string">config-server</span></span><br><span class="line"><span class="meta">spring.cloud.config.discovery.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.cloud.config.fail-fast</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.cloud.config.username</span>=<span class="string">wxy</span></span><br><span class="line"><span class="meta">spring.cloud.config.password</span>=<span class="string">wxy123</span></span><br><span class="line"><span class="meta">spring.cloud.config.profile</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure>
<p>git上的配置application-dev.properties内容如下,转发路劲和超时时间</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">5684</span></span><br><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">zuul.routes.consumer</span>=<span class="string">/consumer/**</span></span><br><span class="line"><span class="meta">zuul.routes.provider</span>=<span class="string">/provider/**</span></span><br><span class="line"><span class="meta">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</span>=<span class="string">80000</span></span><br></pre></td></tr></table></figure>
<p>修改启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@SpringCloudApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(ZuulApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时访问其他服务可以通过访问网关上的路径转发来访问其他服务，来隐藏其他服务的地址，还可以做鉴权等其他功能。</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2019/12/15/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>spring-cloud-ali sentinel接口限流</title>
    <url>/2019/12/08/spring-cloud-ali-sentinel%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<h1 id="Sentinel是什么"><a href="#Sentinel是什么" class="headerlink" title="Sentinel是什么"></a>Sentinel是什么</h1><p>​        Sentinel的官方标题是：分布式系统的流量防卫兵。从名字上来看，很容易就能猜到它是用来作服务稳定性保障的。对于服务稳定性保障组件，如果熟悉Spring Cloud的用户，第一反应应该就是Hystrix。但是比较可惜的是Netflix已经宣布对Hystrix停止更新。那么，在未来我们还有什么更好的选择呢？除了Spring Cloud官方推荐的resilience4j之外，目前Spring Cloud Alibaba下整合的Sentinel也是用户可以重点考察和选型的目标。 </p>
<h1 id="使用Sentinel实现接口限流"><a href="#使用Sentinel实现接口限流" class="headerlink" title="使用Sentinel实现接口限流"></a>使用Sentinel实现接口限流</h1><p> Sentinel的使用分为两部分： </p>
<ul>
<li>sentinel-dashboard：与hystrix-dashboard类似，但是它更为强大一些。除了与hystrix-dashboard一样提供实时监控之外，还提供了流控规则、熔断规则的在线维护等功能。</li>
<li>客户端整合：每个微服务客户端都需要整合sentinel的客户端封装与配置，才能将监控信息上报给dashboard展示以及实时的更改限流或熔断规则等。</li>
</ul>
<h3 id="部署Sentinel-Dashboard"><a href="#部署Sentinel-Dashboard" class="headerlink" title="部署Sentinel Dashboard"></a>部署Sentinel Dashboard</h3><p><a href="https://github.com/alibaba/Sentinel/releases" target="_blank" rel="noopener">下载地址</a> </p>
<p>下载到本地以后可以直接启动</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">java -jar sentinel-dashboard<span class="number">-1.6</span><span class="number">.0</span>.jar</span><br></pre></td></tr></table></figure>
<p>sentinel-dashboard不像Nacos的服务端那样提供了外置的配置文件，比较容易修改参数。不过不要紧，由于sentinel-dashboard是一个标准的spring boot应用，所以如果要自定义端口号等内容的话，可以通过在启动命令中增加参数来调整，比如：<code>-Dserver.port=8888</code>。</p>
<p>默认情况下，sentinel-dashboard以8080端口启动，所以可以通过访问：<code>localhost:8080</code>来验证是否已经启动成功. 默认用户名和密码都是<code>sentinel</code> </p>
<p>对于用户登录的相关配置可以在启动命令中增加下面的参数来进行配置：</p>
<ul>
<li><code>-Dsentinel.dashboard.auth.username=sentinel</code>: 用于指定控制台的登录用户名为 sentinel；</li>
<li><code>-Dsentinel.dashboard.auth.password=123456</code>: 用于指定控制台的登录密码为 123456；如果省略这两个参数，默认用户和密码均为 sentinel</li>
<li><code>-Dserver.servlet.session.timeout=7200</code>: 用于指定 Spring Boot 服务端 session 的过期时间，如 7200 表示 7200 秒；60m 表示 60 分钟，默认为 30 分钟；</li>
</ul>
<p>我是在阿里云上运行的，运行的命令是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后台启动的命令 </span></span><br><span class="line">nohup java -jar sentinel-dashboard<span class="number">-1.6</span><span class="number">.0</span>.jar &gt;consoleMsg.<span class="built_in">log</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br><span class="line"><span class="comment">//查看jar进程的命令</span></span><br><span class="line">ps aux|grep sentinel-dashboard<span class="number">-1.6</span><span class="number">.0</span>.jar</span><br><span class="line"><span class="comment">//杀死进程</span></span><br><span class="line">kill <span class="number">-9</span> <span class="number">30768</span></span><br><span class="line"><span class="comment">//查看日志</span></span><br><span class="line">cat xxx.<span class="built_in">log</span>  日志中有报错信息</span><br><span class="line"><span class="comment">//清空日志</span></span><br><span class="line">echo <span class="string">" "</span> &gt;xxx.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p> nohup命令的作用就是让程序在后台运行，不用担心关闭连接进程断掉的问题了， 并且将标准输出的日志重定向至文件consoleMsg.log ,consoleMsg.log文件前提要创建好的,这个log文件最好跟jar包放一起 。 </p>
<h1 id="整合Sentinel"><a href="#整合Sentinel" class="headerlink" title="整合Sentinel"></a>整合Sentinel</h1><p>创建一个新的springboot服务，命名为alibaba-sentinel-test1，添加依赖项</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sentinel</span></span><br><span class="line">compile <span class="string">group:</span> <span class="string">'com.alibaba.cloud'</span>, <span class="string">name:</span> <span class="string">'spring-cloud-starter-alibaba-sentinel'</span>, <span class="string">version:</span> <span class="string">'2.1.0.RELEASE'</span></span><br><span class="line"><span class="comment">//lombok</span></span><br><span class="line">compile <span class="string">group:</span> <span class="string">'org.projectlombok'</span>, <span class="string">name:</span> <span class="string">'lombok'</span>, <span class="string">version:</span> <span class="string">'1.18.2'</span></span><br></pre></td></tr></table></figure>
<p>修改配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">alibaba-sentinel-test1</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8002</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel dashboard的访问地</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.transport.dashboard</span>=<span class="string">localhost:8080</span></span><br><span class="line"><span class="comment">#延迟加载</span></span><br><span class="line"><span class="comment">#spring.cloud.sentinel.eager=true</span></span><br></pre></td></tr></table></figure>
<p>添加请求方方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Sentinel"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动服务后，登录本地的sentinel页面（ <a href="http://localhost:8080/），并没有出现数据，这个时候发起请求" target="_blank" rel="noopener">http://localhost:8080/），并没有出现数据，这个时候发起请求</a></p>
<p>localhost:8002,页面上就显示如下图：</p>
<p><img src="/2019/12/08/spring-cloud-ali-sentinel接口限流/first-view.png" alt></p>
<p>点击 列表中的 簇点链路 ，点击/hello中的流控按钮，编辑限流单机阈值为2.</p>
<p><img src="/2019/12/08/spring-cloud-ali-sentinel接口限流/C:/Program Files\blog\source\_posts\spring-cloud-ali-sentinel接口限流\second-view.png" alt></p>
<p>点击新增之后，所有的规则都可以去流控规则列表中查看到.</p>
<h2 id="验证限流规则"><a href="#验证限流规则" class="headerlink" title="验证限流规则"></a>验证限流规则</h2><p>使用postman发起请求或者是curl发起请求测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl localhost:8002/hello</span><br><span class="line">Hello Sentinel</span><br><span class="line">$ curl localhost:8002/hello</span><br><span class="line">Hello Sentinel</span><br><span class="line">$ curl localhost:8002/hello</span><br><span class="line">Blocked by Sentinel (flow limiting)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring cloud alibaba</category>
      </categories>
      <tags>
        <tag>spring cloud alibaba</tag>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud-aliba 服务注册</title>
    <url>/2019/12/03/spring-cloud-aliba-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<h1 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h1><p> Nacos致力于帮助您发现、配置和管理微服务。Nacos提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。Nacos帮助您更敏捷和容易地构建、交付和管理微服务平台。Nacos是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施 </p>
<p><a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">nacos下载地址</a></p>
<p>我下载的版本是1.1.4</p>
<p> 下载完成之后，解压。根据不同平台，执行不同命令，启动单机版Nacos服务： </p>
<ul>
<li>Linux/Unix/Mac：<code>sh startup.sh -m standalone</code></li>
<li><p>Windows：<code>cmd startup.cmd -m standalone</code></p>
<p><code>startup.sh</code>脚本位于Nacos解压后的bin目录下。这里主要介绍Spring Cloud与Nacos的集成使用，对于Nacos的高级配置，后续再补充。 启动完成之后，访问：<code>http://127.0.0.1:8848/nacos/</code>，可以进入Nacos的服务管理页面， 出现登录页面，默认用户名密码为：nacos </p>
</li>
</ul>
<h2 id="构建应用接入Nacos注册中心"><a href="#构建应用接入Nacos注册中心" class="headerlink" title="构建应用接入Nacos注册中心"></a>构建应用接入Nacos注册中心</h2><p> 在完成了Nacos服务的安装和启动之后，下面我们就可以编写两个应用（服务提供者与服务消费者）来验证服务的注册与发现了。 </p>
<h3 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h3><p> <strong>第一步</strong>：创建一个Spring Boot应用，可以命名为：<code>alibaba-nacos-discovery-server</code> </p>
<p>引入依赖,这两个依赖还没有在spring cloud 官方版本，所以需要手动引入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ali depence</span><br><span class="line">compile group: &apos;com.alibaba.cloud&apos;, name: &apos;spring-cloud-starter-alibaba-nacos-discovery&apos;, version: &apos;2.1.0.RELEASE&apos;</span><br><span class="line"></span><br><span class="line">// https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-alibaba-nacos-discovery</span><br><span class="line">compile group: &apos;org.springframework.cloud&apos;, name: &apos;spring-cloud-starter-alibaba-nacos-discovery&apos;, version: &apos;0.9.0.RELEASE&apos;</span><br></pre></td></tr></table></figure>
<p>在启动类上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlibabaNacosDiscoveryServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(AlibabaNacosDiscoveryServerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个服务提供方法类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在配置文件application.properties中配置服务名称和Nacos地址 </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">alibaba-nacos-discovery-server</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8001</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">localhost:8848</span></span><br><span class="line"><span class="meta">spring.main.allow-bean-definition-overriding</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<p>启动服务，这个时候可以在 <a href="http://127.0.0.1:8848/nacos/" target="_blank" rel="noopener">http://127.0.0.1:8848/nacos/</a> 服务列表上看见</p>
<p><img src="/2019/12/03/spring-cloud-aliba-服务注册/server.png" alt></p>
<h3 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h3><p>创建一个Spring Boot应用，命名为：<code>alibaba-nacos-discovery-client-common</code>。引入依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'org.springframework.boot:spring-boot-starter-web'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ali depence</span></span><br><span class="line">compile <span class="string">group:</span> <span class="string">'com.alibaba.cloud'</span>, <span class="string">name:</span> <span class="string">'spring-cloud-starter-alibaba-nacos-discovery'</span>, <span class="string">version:</span> <span class="string">'2.1.0.RELEASE'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-alibaba-nacos-discovery</span></span><br><span class="line">compile <span class="string">group:</span> <span class="string">'org.springframework.cloud'</span>, <span class="string">name:</span> <span class="string">'spring-cloud-starter-alibaba-nacos-discovery'</span>, <span class="string">version:</span> <span class="string">'0.9.0.RELEASE'</span></span><br></pre></td></tr></table></figure>
<p>在启动类上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlibabaNacosDiscoveryClientCommonApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(AlibabaNacosDiscoveryClientCommonApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@RestController</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//负载均衡</span></span><br><span class="line">		<span class="meta">@Autowired</span></span><br><span class="line">		LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@LoadBalanced</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@LoadBalanced</span></span><br><span class="line">		<span class="keyword">public</span> WebClient.<span class="function">Builder <span class="title">loadBalancedWebClientBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> WebClient.builder();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建服务消费方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TestInterface testInterface;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebClient.Builder webClientBuilder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过spring cloud common中的负载均衡接口选取服务提供节点实现接口调用</span></span><br><span class="line">        ServiceInstance serviceInstance = loadBalancerClient.choose(<span class="string">"alibaba-nacos-discovery-server"</span>);</span><br><span class="line">        String url = serviceInstance.getUri() + <span class="string">"/hello?name="</span> + <span class="string">"panghu"</span>;</span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        String result = restTemplate.getForObject(url, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Invoke : "</span> + url + <span class="string">", return : "</span> + result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = restTemplate.getForObject(<span class="string">"http://alibaba-nacos-discovery-server/hello?name=panghu"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Return : "</span> + result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test3"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Mono&lt;String&gt; result = webClientBuilder.build()</span><br><span class="line">                .get()</span><br><span class="line">                .uri(<span class="string">"http://alibaba-nacos-discovery-server/hello?name=panghu"</span>)</span><br><span class="line">                .retrieve()</span><br><span class="line">                .bodyToMono(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test4"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = testInterface.hello(<span class="string">"panghu"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Return : "</span> + result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建fegin的调用接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"alibaba-nacos-discovery-server"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(@RequestParam(name = <span class="string">"name"</span>)</span> String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候启动消费者、提供者，在本地输入 <a href="http://localhost:8003/test1" target="_blank" rel="noopener">http://localhost:8003/test1</a>, <a href="http://localhost:8003/test2" target="_blank" rel="noopener">http://localhost:8003/test2</a> , <a href="http://localhost:8003/test3" target="_blank" rel="noopener">http://localhost:8003/test3</a> , <a href="http://localhost:8003/test4" target="_blank" rel="noopener">http://localhost:8003/test4</a> .使用不同的方法调用服务。</p>
<h1 id="使用nacos构建配置中心"><a href="#使用nacos构建配置中心" class="headerlink" title="使用nacos构建配置中心"></a>使用nacos构建配置中心</h1><p>Nacos除了实现了服务的注册发现之外，还将配置中心功能整合在了一起。通过Nacos的配置管理功能，我们可以将整个架构体系内的所有配置都集中在Nacos中存储。这样做的好处，在以往的教程中介绍Spring Cloud Config时也有提到，主要有以下几点：</p>
<ul>
<li>分离的多环境配置，可以更灵活的管理权限，安全性更高</li>
<li>应用程序的打包更为纯粹，以实现一次打包，多处运行的特点</li>
</ul>
<h2 id="创建配置"><a href="#创建配置" class="headerlink" title="创建配置"></a>创建配置</h2><p> 第一步：进入Nacos的控制页面，在配置列表功能页面中，点击右上角的“+”按钮，进入“新建配置”页面，如下图填写内容： </p>
<p><img src="/2019/12/03/spring-cloud-aliba-服务注册/config.png" alt></p>
<p>其中：</p>
<ul>
<li><code>Data ID</code>：填入<code>alibaba-nacos-config-client.properties</code></li>
<li><code>Group</code>：不修改，使用默认值<code>DEFAULT_GROUP</code></li>
<li><code>配置格式</code>：选择<code>Properties</code></li>
<li><code>配置内容</code>：应用要加载的配置内容，这里仅作为示例，做简单配置，比如：<code>panghu.title.title=spring-cloud-alibaba-learning</code></li>
</ul>
<h2 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h2><p>引入依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://mvnrepository.com/artifact/com.alibaba.cloud/spring-cloud-starter-alibaba-nacos-config</span></span><br><span class="line">compile <span class="string">group:</span> <span class="string">'com.alibaba.cloud'</span>, <span class="string">name:</span> <span class="string">'spring-cloud-starter-alibaba-nacos-config'</span>, <span class="string">version:</span> <span class="string">'2.1.0.RELEASE'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ali depence</span></span><br><span class="line">compile <span class="string">group:</span> <span class="string">'com.alibaba.cloud'</span>, <span class="string">name:</span> <span class="string">'spring-cloud-starter-alibaba-nacos-discovery'</span>, <span class="string">version:</span> <span class="string">'2.1.0.RELEASE'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-alibaba-nacos-discovery</span></span><br><span class="line">compile <span class="string">group:</span> <span class="string">'org.springframework.cloud'</span>, <span class="string">name:</span> <span class="string">'spring-cloud-starter-alibaba-nacos-discovery'</span>, <span class="string">version:</span> <span class="string">'0.9.0.RELEASE'</span></span><br></pre></td></tr></table></figure>
<p> 在启动类应中实现一个HTTP接口验证配置文件加载是否成功</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlibabaNacosConfigClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(AlibabaNacosConfigClientApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RestController</span></span><br><span class="line">	<span class="meta">@RefreshScope</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Value</span>(<span class="string">"$&#123;panghu.title:&#125;"</span>)</span><br><span class="line">		<span class="keyword">private</span> String title;</span><br><span class="line">		<span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> title;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>内容非常简单，`@SpringBootApplication`定义是个Spring Boot应用；还定义了一个Controller，其中通过`@Value`注解，注入了key为panghu.title`的配置（默认为空字符串），这个配置会通过`/test`接口返回，后续我们会通过这个接口来验证Nacos中配置的加载。另外，这里还有一个比较重要的注解`@RefreshScope`，主要用来让这个类下的配置内容支持动态刷新，也就是当我们的应用启动之后，修改了Nacos中的配置内容之后，这里也会马上生效。 
</code></pre><p>​        创建配置文件<code>bootstrap.properties</code>，并配置服务名称和Nacos地址 ，SpringCloudConfig和 NacosConfig这种统一配置服务在springboot项目中初始化时，都是加载bootstrap.properties配置文件去初始化上下文。这是由spring boot的加载属性文件的优先级决定的，想要在加载属性之前去config server上取配置文件，NacosConfig或SpringCloudConfig相关配置就是需要最先加载的，而bootstrap.properties的加载是先application.properties的，所以config client要配置config的相关配置就只能写到bootstrap.properties里了</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">alibaba-nacos-config-client</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8001</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="meta">spring.main.allow-bean-definition-overriding</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br></pre></td></tr></table></figure>
<p>启动服务后访问 <a href="http://localhost:8001/test" target="_blank" rel="noopener">http://localhost:8001/test</a> ，显示页面如下所示</p>
<p><img src="/2019/12/03/spring-cloud-aliba-服务注册/config-server.png" alt></p>
<h1 id="Nacos配置的加载规则详解"><a href="#Nacos配置的加载规则详解" class="headerlink" title="Nacos配置的加载规则详解"></a>Nacos配置的加载规则详解</h1><p>，Nacos中创建的配置内容是这样的：</p>
<ul>
<li><code>Data ID</code>：alibaba-nacos-config-client.properties</li>
<li><code>Group</code>：DEFAULT_GROUP</li>
</ul>
<p>拆解一下，主要有三个元素，它们与具体应用的配置内容对应关系如下：</p>
<ul>
<li>Data ID中的<code>alibaba-nacos-config-client</code>：对应客户端的配置<code>spring.cloud.nacos.config.prefix</code>，默认值为<code>${spring.application.name}</code>，即：服务名</li>
<li>Data ID中的<code>properties</code>：对应客户端的配置<code>spring.cloud.nacos.config.file-extension</code>，默认值为<code>properties</code></li>
<li>Group的值<code>DEFAULT_GROUP</code>：对应客户端的配置<code>spring.cloud.nacos.config.group</code>，默认值为<code>DEFAULT_GROUP</code></li>
</ul>
<p>在采用默认值的应用要加载的配置规则就是：<code>Data ID=${spring.application.name}.properties</code>，<code>Group=DEFAULT_GROUP</code>。</p>
<p>下面，我们做一些假设例子，方便大家理解这些配置之间的关系：</p>
<p><strong>例子一</strong>：如果我们不想通过服务名来加载，那么可以增加如下配置，就会加载到<code>Data ID=example.properties</code>，<code>Group=DEFAULT_GROUP</code>的配置内容了：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.prefix</span>=<span class="string">example</span></span><br></pre></td></tr></table></figure>
<p><strong>例子二</strong>：如果我们想要加载yaml格式的内容，而不是Properties格式的内容，那么可以通过如下配置，实现加载<code>Data ID=example.yaml</code>，<code>Group=DEFAULT_GROUP</code>的配置内容了：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.prefix</span>=<span class="string">example</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.file-extension</span>=<span class="string">yaml</span></span><br></pre></td></tr></table></figure>
<p><strong>例子三</strong>：如果我们对配置做了分组管理，那么可以通过如下配置，实现加载<code>Data ID=example.yaml</code>，<code>Group=DEV_GROUP</code>的配置内容了：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.prefix</span>=<span class="string">example</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.file-extension</span>=<span class="string">yaml</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.group</span>=<span class="string">DEV_GROUP</span></span><br></pre></td></tr></table></figure>
<h2 id="多环境管理"><a href="#多环境管理" class="headerlink" title="多环境管理"></a>多环境管理</h2><p> 在Nacos中，本身有多个不同管理级别的概念，包括：<code>Data ID</code>、<code>Group</code>、<code>Namespace</code>。只要利用好这些层级概念的关系，就可以根据自己的需要来实现多环境的管理。 </p>
<p><code>Data ID</code>在Nacos中，我们可以理解为就是一个Spring Cloud应用的配置文件名,我们知道默认情况下<code>Data ID</code>的名称格式是这样的：<code>${spring.application.name}.properties</code>，即：以Spring Cloud应用命名的properties文件。</p>
<p>实际上，<code>Data ID</code>的规则中，还包含了环境逻辑，这一点与Spring Cloud Config的设计类似。我们在应用启动时，可以通过<code>spring.profiles.active</code>来指定具体的环境名称，此时客户端就会把要获取配置的<code>Data ID</code>组织为：<code>${spring.application.name}-${spring.profiles.active}.properties</code>。</p>
<p> 实际上，更原始且最通用的匹配规则，是这样的：<code>${spring.cloud.nacos.config.prefix}</code>-<code>${spring.profile.active}</code>.<code>${spring.cloud.nacos.config.file-extension}</code>。而上面的结果是因为<code>${spring.cloud.nacos.config.prefix}</code>和<code>${spring.cloud.nacos.config.file-extension}</code>都使用了默认值。 </p>
<h3 id="使用后缀实现"><a href="#使用后缀实现" class="headerlink" title="使用后缀实现"></a>使用后缀实现</h3><p>测试在nacos中创建一个新的配置文件 alibaba-nacos-config-client-dev.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">panghu.title</span>=<span class="string">7654321</span></span><br></pre></td></tr></table></figure>
<p>在配置文件中添加spring.profiles.active=dev，</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">alibaba-nacos-config-client</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8001</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="meta">spring.main.allow-bean-definition-overriding</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#spring.cloud.nacos.config.prefix=example</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure>
<p>重新启动服务，访问 <a href="http://localhost:8001/test" target="_blank" rel="noopener">http://localhost:8001/test</a> 可以发现打印出的结果是7654321</p>
<h3 id="使用Group实现"><a href="#使用Group实现" class="headerlink" title="使用Group实现"></a>使用<code>Group</code>实现</h3><p>测试在nacos中创建一个新的配置文件 alibaba-nacos-config-client.properties</p>
<p><img src="/2019/12/03/spring-cloud-aliba-服务注册/config-group.png" alt></p>
<p>在配置文件中添加</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">alibaba-nacos-config-client</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8001</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="meta">spring.main.allow-bean-definition-overriding</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#spring.cloud.nacos.config.prefix=example</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.group</span>=<span class="string">DEV_GROUP</span></span><br></pre></td></tr></table></figure>
<p>再次重新启动服务，访问 <a href="http://localhost:8001/test" target="_blank" rel="noopener">http://localhost:8001/test</a> 可以发现打印出的结果是1234567</p>
<h3 id="使用Namespace实现"><a href="#使用Namespace实现" class="headerlink" title="使用Namespace实现"></a>使用<code>Namespace</code>实现</h3><p> <strong>第一步</strong>：先在Nacos中，根据环境名称来创建多个<code>Namespace</code>。比如： </p>
<p><img src="/2019/12/03/spring-cloud-aliba-服务注册/namespace.png" alt></p>
<p>在dev分支下创建配置文件</p>
<p><img src="/2019/12/03/spring-cloud-aliba-服务注册/namespace-dev.png" alt></p>
<p>在启动的配置文件中添加</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.namespace</span>=<span class="string">d8b4a958-e2e8-4ed7-be64-69646aeb42c0</span></span><br></pre></td></tr></table></figure>
<p> 分别利用Nacos配置管理功能中的几个不同纬度来实现多环境的配置管理。</p>
<h2 id="加载多个配置文件"><a href="#加载多个配置文件" class="headerlink" title="加载多个配置文件"></a>加载多个配置文件</h2><p>在配置中心添加两个配置文件</p>
<p>a.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">a.name</span>=<span class="string">a</span></span><br></pre></td></tr></table></figure>
<p>b.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">b.name</span>=<span class="string">b</span></span><br></pre></td></tr></table></figure>
<p>在springBoot的配置文件中添加</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[0].dataId</span>=<span class="string">a.properties</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[0].group</span>=<span class="string">DEFAULT_GROUP</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[0].refresh</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[1].data-id</span>=<span class="string">b.properties</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[1].group</span>=<span class="string">DEFAULT_GROUP</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[1].refresh</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<p>修改测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"$&#123;panghu.title:&#125;"</span>)</span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Value</span>( <span class="string">"$&#123;a.name:&#125;"</span> )</span><br><span class="line">	<span class="keyword">private</span> String aname;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Value</span>( <span class="string">"$&#123;b.name:&#125;"</span> )</span><br><span class="line">	<span class="keyword">private</span> String bname;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> title+<span class="string">"_____a:"</span>+aname+<span class="string">"_____b:"</span>+bname;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启服务访问<a href="http://localhost:8001/test" target="_blank" rel="noopener">http://localhost:8001/test</a> 可以发现打印出的结果是 spring-cloud-alibaba-learning_____a:a_____b:b </p>
<h2 id="共享配置"><a href="#共享配置" class="headerlink" title="共享配置"></a>共享配置</h2><p>通过上面加载多个配置的实现，实际上我们已经可以实现不同应用共享配置了。但是Nacos中还提供了另外一个便捷的配置方式，比如下面的设置与上面使用的配置内容是等价的：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.shared-dataids</span>=<span class="string">actuator.properties,log.properties</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.refreshable-dataids</span>=<span class="string">actuator.properties,log.properties</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>spring.cloud.nacos.config.shared-dataids</code>参数用来配置多个共享配置的<code>Data Id</code>，多个的时候用用逗号分隔</li>
<li><code>spring.cloud.nacos.config.refreshable-dataids</code>参数用来定义哪些共享配置的<code>Data Id</code>在配置变化时，应用中可以动态刷新，多个<code>Data Id</code>之间用逗号隔开。如果没有明确配置，默认情况下所有共享配置都不支持动态刷新</li>
</ul>
<h2 id="配置加载的优先级"><a href="#配置加载的优先级" class="headerlink" title="配置加载的优先级"></a>配置加载的优先级</h2><p>当我们加载多个配置的时候，如果存在相同的key时，我们需要深入了解配置加载的优先级关系。</p>
<p>在使用Nacos配置的时候，主要有以下三类配置：</p>
<ul>
<li>A: 通过<code>spring.cloud.nacos.config.shared-dataids</code>定义的共享配置</li>
<li>B: 通过<code>spring.cloud.nacos.config.ext-config[n]</code>定义的加载配置</li>
<li>C: 通过内部规则（<code>spring.cloud.nacos.config.prefix</code>、<code>spring.cloud.nacos.config.file-extension</code>、<code>spring.cloud.nacos.config.group</code>这几个参数）拼接出来的配置</li>
</ul>
<p>要弄清楚这几个配置加载的顺序，我们从日志中也可以很清晰的看到，我们可以做一个简单的实验：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[0].data-id</span>=<span class="string">a.properties</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[0].group</span>=<span class="string">DEFAULT_GROUP</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[0].refresh</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.shared-dataids</span>=<span class="string">b.properties</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.refreshable-dataids</span>=<span class="string">b.properties</span></span><br></pre></td></tr></table></figure>
<p>这个配置文件的加载顺寻是 A &lt; B &lt; C </p>
<h1 id="Nacos的数据持久化"><a href="#Nacos的数据持久化" class="headerlink" title="Nacos的数据持久化"></a>Nacos的数据持久化</h1><p>在搭建Nacos集群之前，我们需要先修改Nacos的数据持久化配置为MySQL存储。默认情况下，Nacos使用嵌入式数据库实现数据的存储。所以，如果启动多个默认配置下的Nacos节点，数据存储是存在一致性问题的。为了解决这个问题，Nacos采用了集中式存储的方式来支持集群化部署，目前只要支持MySQL的存储。</p>
<p>配置Nacos的MySQL存储只需要下面三步：</p>
<p><strong>第一步</strong>：安装数据库，版本要求：5.6.5+</p>
<p><strong>第二步</strong>：初始化MySQL数据库，数据库初始化文件：<code>nacos-mysql.sql</code>，该文件可以在Nacos程序包下的<code>conf</code>目录下获得。</p>
<p> <strong>第三步</strong>：修改<code>conf/application.properties</code>文件，增加支持MySQL数据源配置，添加（目前只支持mysql）数据源的url、用户名和密码。配置样例如下： </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="meta">db.num</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">db.url.0</span>=<span class="string">jdbc:mysql://localhost:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span></span><br><span class="line"><span class="meta">db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">db.password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>
<h4 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h4><p>在Nacos的<code>conf</code>目录下有一个<code>cluster.conf.example</code>，可以直接把<code>example</code>扩展名去掉来使用，也可以单独创建一个<code>cluster.conf</code>文件，然后打开将后续要部署的Nacos实例地址配置在这里。</p>
<p>本文以在本地不同端点启动3个Nacos服务端为例，可以如下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:8841</span><br><span class="line">127.0.0.1:8842</span><br><span class="line">127.0.0.1:8843</span><br></pre></td></tr></table></figure>
<p> 在完成了上面的配置之后，我们就可以开始在各个节点上启动Nacos实例，以组建Nacos集群来使用了。 </p>
<p>本文中，在集群配置的时候，我们设定了3个Nacos的实例都在本地，只是以不同的端口区分，所以我们在启动Nacos的时候，需要修改不同的端口号。</p>
<p>下面介绍一种方法来方便地启动Nacos的三个本地实例，我们可以将bin目录下的<code>startup.sh</code>脚本复制三份，分别用来启动三个不同端口的Nacos实例，为了可以方便区分不同实例的启动脚本，我们可以把端口号加入到脚本的命名中，比如：</p>
<ul>
<li>startup-8841.sh</li>
<li>startup-8842.sh</li>
<li><p>startup-8843.sh</p>
<p>然后，分别修改这三个脚本中的参数，具体如下图的红色部分（端口号根据上面脚本命名分配）： </p>
</li>
</ul>
<p><img src="/2019/12/03/spring-cloud-aliba-服务注册/C:/Program Files\blog\source\_posts\spring-cloud-aliba-服务注册\sh.png" alt></p>
<h4 id="Proxy配置"><a href="#Proxy配置" class="headerlink" title="Proxy配置"></a>Proxy配置</h4><p>在Nacos的集群启动完毕之后，根据架构图所示，我们还需要提供一个统一的入口给我们用来维护以及给Spring Cloud应用访问。简单地说，就是我们需要为上面启动的的三个Nacos实例做一个可以为它们实现负载均衡的访问点。这个实现的方式非常多，这里就举个用Nginx来实现的简单例子吧。</p>
<p>在Nginx配置文件的http段中，我们可以加入下面的配置内容：</p>
<p><img src="/2019/12/03/spring-cloud-aliba-服务注册/C:/Program Files\blog\source\_posts\spring-cloud-aliba-服务注册\nginx.png" alt></p>
]]></content>
      <categories>
        <category>spring cloud alibaba</category>
      </categories>
      <tags>
        <tag>spring cloud alibaba</tag>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud steam</title>
    <url>/2019/11/26/spring-cloud-steam/</url>
    <content><![CDATA[<p> 我们通过简单的配置和注解就能实现向RabbitMQ中生产和消费消息。实际上我们使用的对RabbitMQ的starter就是通过Spring Cloud Stream中对RabbitMQ的支持来实现的。下面我们就通过本文来了解一下Spring Cloud Stream。 </p>
<p> Spring Cloud Stream是一个用来为微服务应用构建消息驱动能力的框架。它可以基于Spring Boot来创建独立的、可用于生产的Spring应用程序。它通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动的微服务应用。Spring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，并且引入了发布-订阅、消费组以及消息分区这三个核心概念。简单的说，Spring Cloud Stream本质上就是整合了Spring Boot和Spring Integration，实现了一套轻量级的消息驱动的微服务框架。通过使用Spring Cloud Stream，可以有效地简化开发人员对消息中间件的使用复杂度，让系统开发人员可以有更多的精力关注于核心业务逻辑的处理。由于Spring Cloud Stream基于Spring Boot实现，所以它秉承了Spring Boot的优点，实现了自动化配置的功能帮忙我们可以快速的上手使用，但是目前为止Spring Cloud Stream只支持下面两个著名的消息中间件的自动化配置： </p>
<ul>
<li><code>RabbitMQ</code></li>
<li><code>Kafka</code></li>
</ul>
<h1 id="构建一个Spring-Cloud-Stream消费者"><a href="#构建一个Spring-Cloud-Stream消费者" class="headerlink" title="构建一个Spring Cloud Stream消费者"></a>构建一个Spring Cloud Stream消费者</h1><p>创建一个消费者 stream-hello </p>
<p>添加 Spring Cloud Stream对RabbitMQ的支持，</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rabbit -steam依赖</span></span><br><span class="line">	compile <span class="string">group:</span> <span class="string">'org.springframework.cloud'</span>, <span class="string">name:</span> <span class="string">'spring-cloud-starter-stream-rabbit'</span>, <span class="string">version:</span> <span class="string">'2.1.3.RELEASE'</span></span><br></pre></td></tr></table></figure>
<p> 创建用于接收来自RabbitMQ消息的消费者<code>SinkReceiver</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(Sink<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SinkReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SinkReceiver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener</span>(Sink.INPUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Object payload)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Received: "</span> + payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>@EnableBinding</strong> :实现了对消息通道（channel）的绑定 </p>
<p> <strong>@EnableBinding (Sink.class)</strong> ：绑定了Sink接口，该接口是Spring cloud Stream中默认实现的对输入消息通道绑定的定义 </p>
<p> 从代码中可以看到通过注解的方式绑定了一个名字为input的通道  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sink</span> </span>&#123;</span><br><span class="line">    String INPUT = <span class="string">"input"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Input</span>(<span class="string">"input"</span>)</span><br><span class="line">    <span class="function">SubscribableChannel <span class="title">input</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然有输入就会有输出 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    String OUTPUT = <span class="string">"output"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Output</span>(<span class="string">"output"</span>)</span><br><span class="line">    <span class="function">MessageChannel <span class="title">output</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 当需要绑定多个接口的时候，只需要用逗号隔开，添加类即可 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(&#123;Sink<span class="class">.<span class="keyword">class</span>,<span class="title">Source</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SinkReceiver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger=LoggerFactory.getLogger(StreamHelloApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@StreamListener</span>(Sink.INPUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Object payload)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Receive---------------------------------------:"</span>+payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@StreamListener</strong>将方法作为消息的监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@StreamListener</span>(Sink.INPUT)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Object payload)</span> </span>&#123;</span><br><span class="line">     logger.info(<span class="string">"Received: "</span> + payload);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>启动类与正常相同，启动服务并开启rabbitMQ的本地服务，默认的配置就是请求本地的rabbitMQ，不需要额外配置，服务启动后，控制台上打印出</p>
<p><img src="/2019/11/26/spring-cloud-steam/rabbitMQ-start.png" alt></p>
<p>这个时候点开rabbitMQ的控制台，在页面上输入 <a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a></p>
<p><img src="/2019/11/26/spring-cloud-steam/rabbitMQ-connect.png" alt></p>
<p>点击连接信息并查看消息，输入“send message” 并点击publish</p>
<p><img src="/2019/11/26/spring-cloud-steam/rabbitMQ-send.png" alt></p>
<p>此时这个控制台打印出</p>
<p><img src="/2019/11/26/spring-cloud-steam/rabbitMQ-receive.png" alt></p>
<p>完成上示简单的示例后， 引入<code>spring-cloud-starter-stream-rabbit</code>依赖，该依赖包是Spring Cloud Stream对RabbitMQ支持的封装，其中包含了对RabbitMQ的自动化配置等内容。从下面它定义的依赖关系中，我们还可以知道它等价于<code>spring-cloud-stream-binder-rabbit</code>依赖。 </p>
<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="绑定器"><a href="#绑定器" class="headerlink" title="绑定器"></a>绑定器</h2><p> 这里的Binder是指Stream的Binde,如果没有Binder,那么spring boot 在使用消息中间件的时候，由于每个消息中间件都不太相同，一旦切换将会使代码重构。而使用了Binder之后，最终暴露给用户的只有Channel </p>
<h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h2><p> Stream的消息通讯方式遵循了发布-订阅模式，当一条消息发送到消息中间件后，它会通过共享的Topic主题进行广播，消息消费者在订阅的主题中收到它并触发相关事务。对于Topic只是一个抽象概念，在MQ中是Exchange,在Kafaka中则是Topic </p>
<p>相对于点对点队列实现的消息通信来说，Spring Cloud Stream 采用的发布-订阅模式可以有效降低消息生产者与消费者之间的耦合。当需要对同一类消息增加一种处理方式时，只需要增加一个应用程序并将输入通道绑定到既有的Topic中就可以实现功能的扩展，而不需要改变原来已经实现的任何内容</p>
<h2 id="消费组"><a href="#消费组" class="headerlink" title="消费组"></a>消费组</h2><p>由于我们的每一个微服务应用都会有多个实例，但是我们只希望消息只被其中一个实例消费一次，所以有了消费组的概念。当多个实例在同一组的时候，也就是设置spring.cloud.stream.bindings.input.group属性的时候，那么消息只会被其中一个实例消费一次。默认情况下，Stream默认分配了一个独立的匿名消费组。所以，如果不是必须像刷新配置一样，最好是指定消费组。</p>
<h2 id="消息分区"><a href="#消息分区" class="headerlink" title="消息分区"></a>消息分区</h2><p>指定某一个实例消费信息。Stream为分区提供了抽象实现，所以它不在乎消息中间件是否有分区功能。</p>
<h1 id="使用详解"><a href="#使用详解" class="headerlink" title="使用详解"></a>使用详解</h1><h2 id="开启绑定功能-EnableBinding"><a href="#开启绑定功能-EnableBinding" class="headerlink" title="开启绑定功能@EnableBinding"></a>开启绑定功能@EnableBinding</h2><p>它只有唯一一个属性：value。上面已经介绍过，由于该注解已经被@Import了BindingBeansRegistrar实现，所以在加载了基本配置内容之后，它会回调来读取value中的类，以创建消息通道的绑定。另外，由于value是一个Class类型的数组，所以我们可以通过value属性一次性指定多个关于消息通道的配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;BindingServiceConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">BindingBeansRegistrar</span>.<span class="title">class</span>, <span class="title">BinderFactoryConfiguration</span>.<span class="title">class</span>, <span class="title">SpelExpressionConverterConfiguration</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">EnableIntegration</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableBinding</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="绑定消息通道"><a href="#绑定消息通道" class="headerlink" title="绑定消息通道"></a>绑定消息通道</h2><p> value里面填的接口对象，里面有消息通道的定义，通过接口对象进行通道绑定 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(&#123;Sink<span class="class">.<span class="keyword">class</span>,<span class="title">Source</span>.<span class="title">class</span>&#125;)</span></span><br></pre></td></tr></table></figure>
<p>其中Sink、Source分别是默认的输入、输出管道</p>
<p> 也可以通过继承直接定义输入和输出通道  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span> <span class="keyword">extends</span> <span class="title">Source</span>, <span class="title">Sink</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置相同的主题Topic </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.stream.bindings.input.destination</span>=<span class="string">sink-channel</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.output.destination</span>=<span class="string">sink-channel</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.input-1.destination</span>=<span class="string">sink-channel</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.output-1.destination</span>=<span class="string">sink-channel</span></span><br></pre></td></tr></table></figure>
<p>创建消息生产者</p>
<p>通过结合 @EnableBinding结合@InboundChannelAdapter注解实现消息的发送 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@EnableBinding</span>(value = &#123;Source<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SinkSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Source source;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(SinkSender<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicInteger NUM = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InboundChannelAdapter</span>(value = Source.OUTPUT,poller = <span class="meta">@Poller</span>(fixedRate = <span class="string">"3000"</span>))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">timerMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">        log.info(NUM.getAndIncrement() + <span class="string">" Send message : "</span> + format);</span><br><span class="line">        <span class="keyword">return</span> format;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        source.output().send(org.springframework.integration.support.MessageBuilder.withPayload(message).build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动服务，控制台打印出</p>
<p><img src="/2019/11/26/spring-cloud-steam/rabbitMQ-customer.png" alt></p>
<h2 id="消息的生产与消费"><a href="#消息的生产与消费" class="headerlink" title="消息的生产与消费"></a>消息的生产与消费</h2><p> 由于Stream 是由 Spring Integration 构建起来的， 支持Integration原生实现 所以可以使用Integration提供相同服务 </p>
<p> @ServiceActivator类比于@StreanListener,实现了对Sink.INPUT通道的监听处理，而该通道绑定了名为input的主题，这个主题就是我们在配置文件上配置的，必须确保input和output为同一个主题Topic. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">@StreamListener(SinkSender.INPUT)</span><br><span class="line">public void receives(Object payload)&#123;</span><br><span class="line">    logger.info(&quot;Receive---------------------------------------:&quot;+payload.toString());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@ServiceActivator(inputChannel = SinkSender.INPUT)</span><br><span class="line">public void receivess(Object payload)&#123;</span><br><span class="line">    logger.info(&quot;Receive---------------------------------------:&quot;+payload.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息发送和消息接收要在同一个 同一个主题Topic </p>
<p> 共用一个主题Topic，构成了一组生产者与消费者 。 @InboundChannelAdapter是对通道的输出绑定，同时使用Poller轮询的方式执行 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">    @InboundChannelAdapter(value=Source.OUTPUT,poller = @Poller(fixedDelay = &quot;2000&quot;))</span><br><span class="line">    public MessageSource&lt;Date&gt; timerMessageSource()&#123;</span><br><span class="line">        return ()-&gt;new GenericMessage&lt;&gt;(new Date());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 消息转换  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transformer</span>(inputChannel = SinkSender.INPUT,outputChannel = SinkSender.OUTPUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Date message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="StreamListener详解"><a href="#StreamListener详解" class="headerlink" title="@StreamListener详解"></a>@StreamListener详解</h2><p> @StreamListener虽然同@ServiceActivator功能相似，但是功能更加强大 </p>
<p>上文中的注解可以替换为@ServiceActivator(inputChannel =Sink.INPUT)</p>
<p>消息转换 </p>
<p>例如将json字符串转换成java对象 </p>
<p> 使用@Transformer注解实现，通过上面的例子，我们可以通过代码的方式去实现消息的转化。 </p>
<p> 使用@StreamListener注解实现,只需要指定传输过来的数据格式即可，因为Stream已经有了内置的消息转换机制，我们无需重复编写。所以说对于此注解来说，只是多写了一个配置信息而已。 </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.stream.bindings.input-1.content-type</span>=<span class="string">application/json</span></span><br></pre></td></tr></table></figure>
<h3 id="消息反馈"><a href="#消息反馈" class="headerlink" title="消息反馈"></a>消息反馈</h3><p> 处理完消息之后，需要反馈一个消息给对方，这时候可以通过@SendTo注解来指定返回内容的输出通道 ， 使用sendto注解即可搞定.对于配置信息，要确保绑定的topic也就是destination是同一个在可以实现订阅，因为通道名字会默认为交换机exchange也就是topic的名字，所以在测试的时候例如在一个应用里面要记得配置相同的交换机。 </p>
<p>修改receive方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@StreamListener</span>(Sink.INPUT)</span><br><span class="line">  <span class="meta">@SendTo</span>(Source.OUTPUT)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">receives</span><span class="params">(Object payload)</span></span>&#123;</span><br><span class="line">      logger.info(<span class="string">"Receive---------------------------------------:"</span>+payload.toString());</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"From llg Channe Return"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>除了 @SendTo(Source.OUTPUT)，也可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@ServiceActivator(inputChannel = Sink.INPUT,outputChannel = Source.OUTPUT)</span><br><span class="line">    public Object receivess(Object payload)&#123;</span><br><span class="line">        logger.info(&quot;Receive---------------------------------------:&quot;+payload.toString());</span><br><span class="line">        return &quot;返回&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费组-1"><a href="#消费组-1" class="headerlink" title="消费组"></a>消费组</h3><p>消费组的概念上文说过，其实就是如果出现需要让服务中多个实例的其中一个消费消息的话，就需要设置消费组进行隔离标记。</p>
<p>不难理解，最主要还是因为是订阅模式，所以会统一发送消息，并且默认组名是匿名组，所以也就自然而然的对服务的所有实例发送了，下面我们来设置消费组。</p>
<p>可以看到配置一个组名Service ,那么开启多个实例的时候自然而然的所有实例的组名都是Service.所以消费组的意思就是把一个服务按一个组划分，每次只传递一个消息到这个组来，再随机给其中的一个实例消费。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.input.group</span>=<span class="string">Service</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.input.destination</span>=<span class="string">input</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.output.destination</span>=<span class="string">input</span></span><br></pre></td></tr></table></figure>
<h3 id="消息分区-1"><a href="#消息分区-1" class="headerlink" title="消息分区"></a>消息分区</h3><p> 为了将某些特定的消息给特定的实例消费，所以需要设置消息分区 </p>
<p>首先需要在消费者应用配置信息</p>
<p>spring.cloud.stream.bindings.input.consumer.partitioned=true :开启消费者分区功能<br>spring.cloud.stream.instance-count=2 ：指定了消费者的实例总数<br>spring.cloud.stream.instance-index=0 ：索引号，从0开始。必须每个实例按索引为0开始递增</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.input.group</span>=<span class="string">Service</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.input.destination</span>=<span class="string">input</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.output.destination</span>=<span class="string">input</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.input.consumer.partitioned</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.cloud.stream.instance-count</span>=<span class="string">2</span></span><br><span class="line"><span class="meta">spring.cloud.stream.instance-index</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure>
<p> 接着配置生产者 </p>
<p>spring.cloud.stream.bindings.output.producer.partition-key-expression=payload   指定了分区键的表达式规则</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.stream.bindings.output.producer.partition-count</span>=<span class="string">2  指定了消息分区的数量</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.output.producer.partition-key-expression</span>=<span class="string">payload</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.output.producer.partition-count</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure>
<h3 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h3><p>类似于springmvc的消息转换器等等，Stream允许使用sprinc.cloud.stream.bindings.<channelname>.content-type 属性以声明式的配置方式为绑定的输入和输出通道设置消息内容的类型。</channelname></p>
<p>json——pojo</p>
<p>json——org.springframework.tuple.Tuple</p>
<p>object——-byte[]  传输序列化数据</p>
<p>string——–byte[]</p>
<p>object—–纯文本</p>
<h1 id="绑定器详解"><a href="#绑定器详解" class="headerlink" title="绑定器详解"></a>绑定器详解</h1><p> 最为关键的接口是Binder接口，它是用来将输入和输出连接到外部中间件的抽象。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Binder</span>&lt;<span class="title">T</span>, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">ConsumerProperties</span>, <span class="title">P</span> <span class="keyword">extends</span> <span class="title">ProducerProperties</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Binding&lt;T&gt; <span class="title">bindConsumer</span><span class="params">(String var1, String var2, T var3, C var4)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Binding&lt;T&gt; <span class="title">bindProducer</span><span class="params">(String var1, T var2, P var3)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用程序对输入和输出通道进行绑定的时候，实际上就是通过该接口的实现来完成的。</p>
<p>向消息通道发送数据的生产者调用bindProducer方法来绑定输出通道时，第一个参数代表了发往消息中间件的目标名称，第二个参数代表了发送消息的本地通道实例，第三个参数是用来创建通道时使用的属性配置（比如分区键的表达式等）。<br>从消息通道接受数据的消费者调用bindConsumer方法来绑定输入通道时，第一个参数代表了接受消息中间件的目标名称，第二个参数代表了消费组的名称（如果多个消费者实例使用相同的组名，则消息将对这些消费者实例实现负载均衡，每个生产者发出的消息只会被组内一个消费者实例接受接受和处理），第三个参数代表了接受消息的本地通道实例，第四个参数是用来创建通道时使用的属性配置。<br>一个典型的Binder绑定器实现一般包含以下内容。</p>
<p>一个实现Binder接口的类<br>一个Spring配置加载类，用来创建连接消息中间件的基础结构使用的实例。<br>一个或多个能够在classpath下的META-INF/spring.binders路径找到的绑定器定义文件。比如我们可以再spring-cloud-starter-stream-rabbit中找到该文件，该文件中存储了当前绑定器要使用的自动化配置类的路径：</p>
<h1 id="自动化配置"><a href="#自动化配置" class="headerlink" title="自动化配置"></a>自动化配置</h1><p>Spring Cloud Stream 通过绑定器SPI的实现应用程序逻辑上的输入输出通道连接到物理上的消息中间件。为了适应多个消息中间件的差异，所以需要实现各自的绑定器</p>
<p>下面的依赖包括了rabbitmq的binder依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>多绑定器配置<br>就是说可以同时用多种消息中间件</p>
<p>首先如果我们需要默认为某种绑定器的时候，比如默认为rabbit的绑定器</p>
<p>spring.cloud.stream.default-binder=rabbit<br>对于一些少数的消息通道需要单独设置绑定器,通过上面的配置我们可以发现我们是直接写rabbit和kafka，但是这不是代表名字，而是某个配置文件的别名。</p>
<p>spring.cloud.stream.bindings.input.binder=kafka<br>对需要使用多个消息中间件，例如消息输入通道和消息输出通道使用不同的消息中间件.显示指定配置别名后会自动禁用默认的绑定器配置，所以我们需要使用spring.cloud.stream.binders.<configurationname>属性来进行设置</configurationname></p>
<p>spring.cloud.stream.bindings.input.binder=rabbit1<br>spring.cloud.stream.bindings.output.binder=rabbit2</p>
<p>spring.cloud.stream.binders.rabbit1.type=rabbit<br>spring.cloud.stream.binders.rabbit1.environment.spring.rabbitmq.host=localhost<br>spring.cloud.stream.binders.rabbit1.environment.spring.rabbitmq.port=5672<br>spring.cloud.stream.binders.rabbit1.environment.spring.rabbitmq.username=guest<br>spring.cloud.stream.binders.rabbit1.environment.spring.rabbitmq.password=guest</p>
<p>spring.cloud.stream.binders.rabbit2.type=rabbit<br>spring.cloud.stream.binders.rabbit2.environment.spring.rabbitmq.host=192.168.88.8<br>spring.cloud.stream.binders.rabbit2.environment.spring.rabbitmq.port=5672<br>spring.cloud.stream.binders.rabbit2.environment.spring.rabbitmq.username=guest<br>spring.cloud.stream.binders.rabbit2.environment.spring.rabbitmq.password=guest<br>以下是对绑定器的一些属性配置 </p>
<p>spring.cloud.stream.binders.<configurationname>.type 指定了绑定器类型<br>spring.cloud.stream.binders.<configurationname>.environment 用来设置各种绑定器属性<br>spring.cloud.stream.binders.<configurationname>.inheritEnvironment=true 当前绑定器是否继承应用程序自身额环境配置<br>spring.cloud.stream.binders.<configurationname>.defaultCandidate=true 设置当前绑定器配置是否被视为默认绑定器的候选项  </configurationname></configurationname></configurationname></configurationname></p>
<h1 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h1><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>下面是spring cloud stream 应用级别的通用基础属性，这些属性都以spring.cloud.stream 为前缀</p>
<p>instanceCount=1 应用程序部署的实例数量。当使用Kafka的时候需要设置分区<br>instanceIndex  应用程序实例的索引，该值从0开始，最大值设置为-1.当使用分区和kafka的时候使用<br>dynamicDestinations 动态绑定的目标列表，该列表默认为空，当设置了具体列表之后，只有列表中的目标才能发现<br>defaultBinder 默认绑定器配置，在应用程序中有多个绑定器时使用<br>绑定通道配置<br>绑定通道分别为输入通道和输出通道，所以在绑定通道的配置中包含了三类面向不同通道类型的配置：通用配置、消费者配置、生产者配置</p>
<h2 id="通用配置"><a href="#通用配置" class="headerlink" title="通用配置"></a>通用配置</h2><p>下面省略spring.cloud.stream.bindings.<channelname>.前缀</channelname></p>
<p>destination  配置Topic名称，也就是exchange名称 ，如果是消费者可以配置多个并且用逗号隔开<br>group  消费组<br>contentType 消息类型<br>binder 指定那个具体的绑定器</p>
<h2 id="消费者配置"><a href="#消费者配置" class="headerlink" title="消费者配置"></a>消费者配置</h2><p>仅对消费者有效，下面省略spring.cloud.stream.bindings.<channelname>.consumer 前缀</channelname></p>
<p>concurrency 输入通道消费者的并发数，默认为1<br>partitioned 是否采用分区，默认false<br>headerMode 当设置为raw的时候将禁用对消息头的解析。该属性只有在使用不支持消息头功能的中间件时有效，因为Spring Cloud Stream 默认会解析嵌入的头部信息 ，默认值embeddedHeaders<br>maxAttempts 对输入通道消息处理的最大重试次数，默认值3<br>backOffInitialInterval  重试消息处理的初始间隔时间 ，默认1000<br>backOffMaxInterval 重试消息处理的最大间隔时间，默认为10000<br>backOffMultiplier 重试消息处理时间间隔的递增乘数 2.0</p>
<h2 id="生产者配置"><a href="#生产者配置" class="headerlink" title="生产者配置"></a>生产者配置</h2><p>仅对生产者者有效，下面省略spring.cloud.stream.bindings.<channelname>.producer 前缀</channelname></p>
<p>partitionKeyExpression 配置输出通道数据分区键的SpEL表达式。当设置该属性后，将对绑定通道的输出数据进行分区处理。同时，partitionCount参数必须大于1才能生效。<br>partitionKeyExtractorClass 配置分区键提取策略接口PartitionKeyExtractionStrategy 的实现。当设置该属性之后，将对当前绑定通道的输出数据进行分区处理。同时，partitionCount参数必须大于1才能生效，该参数与partitionKeyExpression互斥，不能同时使用<br>partitionSelectorClass 该参数用来指定分区选择器的接口PartitionSelectorStrategy的实现，如果两者都没设置，那么默认计算规则为hashCode(key)%partitionCount，这里的key根据上面的配置得到<br>partitionSelectorExpression  该参数用来设置自定义分区的选择器的SpEL表达式<br>headerMode  当设置为raw的时候将禁用对消息头的解析。该属性只有在使用不支持消息头功能的中间件时有效，因为Spring Cloud Stream 默认会解析嵌入的头部信息 ，默认值embeddedHeaders<br>绑定器配置<br>由于Stream只实现了kafka和rabbitmq的实现，所以下面只讲这两种实现</p>
<h2 id="RabbitMQ配置"><a href="#RabbitMQ配置" class="headerlink" title="RabbitMQ配置"></a>RabbitMQ配置</h2><h3 id="通用配置-1"><a href="#通用配置-1" class="headerlink" title="通用配置"></a>通用配置</h3><p>由于rabbitmq默认使用了spring boot 的ConnectFactory，所以Rabbitmq绑定器支持在Spring boot 中的配置选项，他们以spring.rabbitmq为前缀</p>
<p>在Spring Cloud Stream 对RabbitMQ时下的绑定器中，以spring.cloud.stream.rabbit.binder 为前缀</p>
<p>adminAddresses 该参数用来配置RabbitMQ管理插件的URL,当需要配置多个时用逗号分隔。该参数只有在nodes参数包含多个时使用，并且这里配置的内容必须在spring.rabbitmq.address 中存在<br>nodes 该参数用来配置RabbitMQ的节点名称，用逗号隔开，并且这里配置的内容必须在spring.rabbitmq.address 中存在。<br>compressinLevel 绑定通道的压缩级别，它的具体可选值及含义可见java.util.zip.Deflater的定义</p>
<h3 id="消费者配置-1"><a href="#消费者配置-1" class="headerlink" title="消费者配置"></a>消费者配置</h3><p>仅对消费者有效，下面省略spring.cloud.stream.rabbit.bindings.<channelname>.consumer 前缀</channelname></p>
<p>acknowledgeMode  用来设置消息的确认模式，可写：NONE、MANUAL、AUTO，默认值为AUTO<br>autoBindDlq 用来设置是否自动声明DLQ（queue），并绑定到DLX(exchange)上<br>durableSubScription 用来设置订阅是否被持久化，该参数被设置时有效。默认为true<br>maxConcurrency 用来设置消费者的最大并发数 ，默认为1<br>prefetch 用来设置预取数量，它表示在一次会话中从消息中间件中获取的消息数量，该值越大消息处理越快，但是会导致非顺序处理的风险。默认为1<br>prefix 用来设置统一的目标和队列名称前缀<br>recoveryInterval 用来设置恢复连接的尝试时间间隔，默认为5000<br>requeueRejected 用来设置消息传递失败时重传，默认为true<br>requestHeaderPatterns 用来设置需要被传递的请求头信息<br>replyHeaderPatterns 用来设置需要被传递的响应头信息<br>republishToDlq 默认情况下，消息在重试也失败之后会被拒绝。如果DLQ被配置的时候，RabbitMQ会将失败的消息路由到DLQ中。如果该参数被设置为true ,总线会将失败的消息附加一些头信息（包括异常信息，引入失败的跟踪堆栈）之后重新发布到DLQ中<br>transacted 用来设置是否启用channeltransacted 是否在消息中使用事务 ，默认false<br>txSize 用来设置transaction-size 的数量，当acknowledgeMode被设置为AUTO时候，容器会在处理txSize 数目消息之后才开始应答，默认为1</p>
<h3 id="生产者配置-1"><a href="#生产者配置-1" class="headerlink" title="生产者配置"></a>生产者配置</h3><p>仅对生产者者有效，下面省略spring.cloud.stream.rabbit.bindings.<channelname>.producer 前缀</channelname></p>
<p>autoBindDlq 用来设置是否自动声明DLQ（queue），并绑定到DLX(exchange)上<br>batchindEnabled 是否启用消息批处理 ，默认false<br>batchSize 当批处理开启时，用在设置缓存的批处理消息数量，默认为100<br>batchBufferLimit 批处理缓存限制 ，默认为10000<br>batchTimeout 批处理超时时间，默认5000<br>compress 消息发送时是否启用压缩 ，默认false<br>deliveryMode 消息发送模式 ,默认PERSISTENT<br>prefix 用来设置统一的目标前缀<br>requestHeaderPatterns 用来设置需要被传递的请求头信息<br>replyHeaderPatterns 用来设置需要被传递的响应头信息 </p>
<h2 id="KafKa配置"><a href="#KafKa配置" class="headerlink" title="KafKa配置"></a>KafKa配置</h2><h3 id="通用配置-2"><a href="#通用配置-2" class="headerlink" title="通用配置"></a>通用配置</h3><p>在Spring Cloud Stream 对kafka时下的绑定器中，以spring.cloud.stream.kafka.binder 为前缀</p>
<p>brokers =localhost：Kafka绑定器连接的消息中间件列表。需要配置多个时用逗号分隔，每个地址可以是单独的host,也可以是host:port 的形式<br>defaultBrokerPort=9092 ：用来设置默认的消息中间件端口号。当brokers中的配置地址没有包含端口信息时，将使用该参数配置的默认端口进行连接<br>zkNodes=localhost ：kakfa绑定器使用的Zookeeper端口号，当brokers中的配置地址没有包含端口信息时，将使用该参数配置的默认端口进行配置<br>defaultZKport=2181 : 用来设置默认的Zookeeper端口号。当zKNodes 中的配置地址没有包含端口信息时，将使用该参数配置的默认端口进行连接<br>headers : 用来设置会被传输的自定义头信息<br>offsetUpdateCountTImeout =10000: 用来设置offset的更新频率，以毫秒为单位，如果设置为0则忽略<br>offsetUpdateCount=0 : 用来设置offset以次数表示的更新频率，如果为0则忽略，该参数与offsetUpdateCountTImeout互斥<br>requireAcks =1：用来设置确认消息的数量<br>minParttitionCount 该参数仅在设置了autoCreateTopics和autoAddParttions时生效，用来设置该绑定器所使用主题的全局分区最小数量。如果当生产者的parttionCount的参数或instanceCount*concurrency 设置大于该参数配置时，该参数值将被覆盖<br>replicationFactor=1 当autoCreateTopics 参数为true时候，用来配置自动创建主题的副本数量<br>autoCreateTopics=true 该参数默认为true,绑定器会自动地创建新主题。如果设置为false,那么绑定器将使用已经配置的主题，但是在这种情况下，如果需要使用的主题不存在，绑定器会启动失败<br>huautoAddPartition=false 该参数默认为false,绑定器会根据已经配置的主题分区来实现，如果目标主题的分区数小于预期值，那么绑定器会启动失败。如果该参数设置为true,绑定器将在需要的时候自动创建新的分区<br>socketBufferSize =2097152 该参数用来设置KafKa 的Socket的缓存大小</p>
<h3 id="消费者配置-2"><a href="#消费者配置-2" class="headerlink" title="消费者配置"></a>消费者配置</h3><p>仅对消费者有效，下面省略spring.cloud.stream.kafka.bindings.<channelname>.consumer 前缀</channelname></p>
<p>autoCommitOffset=true ：用来设置是否在处理消息时自动提交offset。如果设置为false,在消息头 中会加入ACK头消息以实现延迟确认。<br>autoCommitOnError ：该参数只有在autoCommitOffset设置为true时才有效。当设置为false的时候，引起错误消息不会自动提交offset,仅提交成功消息的offset。如果设置为true,不论消息是否成功，都会自动提交。当不设置该值时，它实际上具有与enabledDlq相同配置<br>reconveryInterval =5000 ：尝试恢复连接的时间间隔，以毫秒为单位<br>resetOffsets =false ：是否使用提供的startOffset 值来重置消费者的offset值<br>startOffset =null : 用来设置新建组的起始offset,该值也会在resetOffsets开始时被使用<br>enableDlq =false : 该参数设置为true时，将为消费者启用DLQ行为，引起错误的消息将被发送到名为error.<destination>.<group>的主题去</group></destination></p>
<h3 id="生产者配置-2"><a href="#生产者配置-2" class="headerlink" title="生产者配置"></a>生产者配置</h3><p>仅对生产者者有效，下面省略spring.cloud.stream.kafka.bindings.<channelname>.producer 前缀</channelname></p>
<p>bufferSize = 16384 Kafka批量发送前的缓存数据上限，以字节为单位<br>sync=false 该参数用来设置Kafka消息生产者的发送模式，默认为false,即采用async配置，允许批量发送数据。当设置为true时，将采用sync配置，消息将不会被批量发送，而是一条一条发送<br>batchTimeout=0 消息生产者批量发送时，为了积累更多发送数据而设置的等待时间。通常情况下，生产者基本不会等待，而是直接发送所有在前一批此发送时基类的消息数据。当我们设置一个非0值时，可以以延迟为代价来增加系统的吞吐量</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>stream</tag>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud 服务网关</title>
    <url>/2019/11/26/spring-cloud-%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/</url>
    <content><![CDATA[<h1 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h1><p> 之前几篇Spring Cloud中几个核心组件的介绍，我们已经可以构建一个简略的（不够完善）微服务架构了。比如下图所示： </p>
<p><img src="/2019/11/26/spring-cloud-服务网关/struct.png" alt></p>
<p> 我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。 </p>
<p> 在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。 </p>
<ul>
<li>首先，破坏了服务无状态特点。为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外可续对接口访问的控制处理。</li>
<li><p>其次，无法直接复用既有接口。当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。</p>
<p>为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器，它就是本文将来介绍的：服务网关。 </p>
<pre><code>服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。 
</code></pre></li>
</ul>
<h2 id="构建服务网关"><a href="#构建服务网关" class="headerlink" title="构建服务网关"></a>构建服务网关</h2><p> Spring Cloud Zuul来构建服务网关 </p>
<p>添加服务网关的依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'</span></span><br><span class="line">implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-eureka-server'</span></span><br><span class="line">implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-zuul'</span></span><br></pre></td></tr></table></figure>
<p>在启动类上添加服务网关注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiGatewayApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(ApiGatewayApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改配置文件application.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础信息配置</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">api-gateway</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">5679</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 路由规则配置</span></span><br><span class="line"><span class="comment">#zuul.routes.api-a.path=/demo/**</span></span><br><span class="line"><span class="comment">#zuul.routes.api-a.serviceId=practice</span></span><br><span class="line"><span class="meta">zuul.routes.ribbon-1</span>=<span class="string">/mypath/**</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># API网关也将作为一个服务注册到eureka-server上</span></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:5678/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注册中心上ip地址显示</span></span><br><span class="line"><span class="meta">eureka.instance.prefer-ip-address</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">eureka.instance.instance-id</span>=<span class="string">$&#123;spring.cloud.client.ipAddress&#125;:$&#123;server.port&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置服务注销事件(秒)</span></span><br><span class="line"><span class="meta">eureka.instance.lease-renewal-interval-in-seconds</span>=<span class="string">5</span></span><br><span class="line"><span class="meta">eureka.instance.lease-expiration-duration-in-seconds</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure>
<p>启动服务注册中心 eureka-service,服务消费则ribbon-1 ,服务网关api-gateway ,直接请求Hystrix-demo1的路径是localhost:5888/consumer，通过网关调用时，路劲可以写成 localhosy:5679/ribbon-1/consumer</p>
<h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><h3 id="传统路由配置"><a href="#传统路由配置" class="headerlink" title="传统路由配置"></a>传统路由配置</h3><p> 所谓的传统路由配置方式就是在不依赖于服务发现机制的情况下，通过在配置文件中具体指定每个路由表达式与服务实例的映射关系来实现API网关对外部请求的路由。 </p>
<p> 单实例配置：通过一组<code>zuul.routes..path</code>与<code>zuul.routes..url</code>参数对的方式配置，比如： </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">zuul.routes.user-service.path</span>=<span class="string">/user-service/**</span></span><br><span class="line"><span class="meta">zuul.routes.user-service.url</span>=<span class="string">http://localhost:8080/</span></span><br></pre></td></tr></table></figure>
<p> 该配置实现了对符合<code>/user-service/**</code>规则的请求路径转发到<code>http://localhost:8080/</code>地址的路由规则，比如，当有一个请求<code>http://localhost:5679/user-service/hello</code>被发送到API网关上，由于<code>/user-service/hello</code>能够被上述配置的<code>path</code>规则匹配，所以API网关会转发请求到<code>http://localhost:8080/hello</code>地址。 </p>
<p> 多实例配置：通过一组<code>zuul.routes..path</code>与<code>zuul.routes..serviceId</code>参数对的方式配置，比如： </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">zuul.routes.user-service.path</span>=<span class="string">/user-service/**</span></span><br><span class="line"><span class="meta">zuul.routes.user-service.serviceId</span>=<span class="string">user-service</span></span><br><span class="line"></span><br><span class="line"><span class="meta">ribbon.eureka.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">user-service.ribbon.listOfServers</span>=<span class="string">http://localhost:8080/,http://localhost:8081/</span></span><br></pre></td></tr></table></figure>
<p>该配置实现了对符合<code>/user-service/**</code>规则的请求路径转发到<code>http://localhost:8080/</code>和<code>http://localhost:8081/</code>两个实例地址的路由规则。它的配置方式与服务路由的配置方式一样，都采用了<code>zuul.routes..path</code>与<code>zuul.routes..serviceId</code>参数对的映射方式，只是这里的<code>serviceId</code>是由用户手工命名的服务名称，配合<code>.ribbon.listOfServers</code>参数实现服务与实例的维护。由于存在多个实例，API网关在进行路由转发时需要实现负载均衡策略，于是这里还需要Spring Cloud Ribbon的配合。由于在Spring Cloud Zuul中自带了对Ribbon的依赖，所以我们只需要做一些配置即可，比如上面示例中关于Ribbon的各个配置，它们的具体作用如下：</p>
<ul>
<li><code>ribbon.eureka.enabled</code>：由于<code>zuul.routes..serviceId</code>指定的是服务名称，默认情况下Ribbon会根据服务发现机制来获取配置服务名对应的实例清单。但是，该示例并没有整合类似Eureka之类的服务治理框架，所以需要将该参数设置为false，不然配置的<code>serviceId</code>是获取不到对应实例清单的。</li>
<li><code>user-service.ribbon.listOfServers</code>：该参数内容与<code>zuul.routes..serviceId</code>的配置相对应，开头的<code>user-service</code>对应了<code>serviceId</code>的值，这两个参数的配置相当于在该应用内部手工维护了服务与实例的对应关系。</li>
</ul>
<p>不论是单实例还是多实例的配置方式，我们都需要为每一对映射关系指定一个名称，也就是上面配置中的<code>，每一个</code>就对应了一条路由规则。每条路由规则都需要通过<code>path</code>属性来定义一个用来匹配客户端请求的路径表达式，并通过<code>url</code>或<code>serviceId</code>属性来指定请求表达式映射具体实例地址或服务名。</p>
<h3 id="服务路由配置"><a href="#服务路由配置" class="headerlink" title="服务路由配置"></a>服务路由配置</h3><p>服务路由我们在上一篇中也已经有过基础的介绍和体验，Spring Cloud Zuul通过与Spring Cloud Eureka的整合，实现了对服务实例的自动化维护，所以在使用服务路由配置的时候，我们不需要向传统路由配置方式那样为<code>serviceId</code>去指定具体的服务实例地址，只需要通过一组<code>zuul.routes..path</code>与<code>zuul.routes..serviceId</code>参数对的方式配置即可。</p>
<p>比如下面的示例，它实现了对符合<code>/user-service/**</code>规则的请求路径转发到名为<code>user-service</code>的服务实例上去的路由规则。其中<code></code>可以指定为任意的路由名称。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">zuul.routes.user-service.path</span>=<span class="string">/user-service/**</span></span><br><span class="line"><span class="meta">zuul.routes.user-service.serviceId</span>=<span class="string">user-service</span></span><br></pre></td></tr></table></figure>
<p> 对于面向服务的路由配置，除了使用<code>path</code>与<code>serviceId</code>映射的配置方式之外，还有一种更简洁的配置方式：<code>zuul.routes.=</code>，其中<code>用来指定路由的具体服务名，</code>用来配置匹配的请求表达式。比如下面的例子，它的路由规则等价于上面通过<code>path</code>与<code>serviceId</code>组合使用的配置方式。 </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">zuul.routes.user-service</span>=<span class="string">/user-service/**</span></span><br></pre></td></tr></table></figure>
<p> 传统路由的映射方式比较直观且容易理解，API网关直接根据请求的URL路径找到最匹配的<code>path</code>表达式，直接转发给该表达式对应的<code>url</code>或对应<code>serviceId</code>下配置的实例地址，以实现外部请求的路由。那么当采用<code>path</code>与<code>serviceId</code>以服务路由方式实现时候，没有配置任何实例地址的情况下，外部请求经过API网关的时候，它是如何被解析并转发到服务具体实例的呢？ </p>
<p> 在Spring Cloud Netflix中，Zuul巧妙的整合了Eureka来实现面向服务的路由。实际上，我们可以直接将API网关也看做是Eureka服务治理下的一个普通微服务应用。它除了会将自己注册到Eureka服务注册中心上之外，也会从注册中心获取所有服务以及它们的实例清单。所以，在Eureka的帮助下，API网关服务本身就已经维护了系统中所有serviceId与实例地址的映射关系。当有外部请求到达API网关的时候，根据请求的URL路径找到最佳匹配的<code>path</code>规则，API网关就可以知道要将该请求路由到哪个具体的<code>serviceId</code>上去。 </p>
<h2 id="过滤器示例"><a href="#过滤器示例" class="headerlink" title="过滤器示例"></a>过滤器示例</h2><p> 通过上面所述的两篇我们，我们已经能够实现请求的路由功能，所以我们的微服务应用提供的接口就可以通过统一的API网关入口被客户端访问到了。但是，每个客户端用户请求微服务应用提供的接口时，它们的访问权限往往都需要有一定的限制，系统并不会将所有的微服务接口都对它们开放。然而，目前的服务路由并没有限制权限这样的功能，所有请求都会被毫无保留地转发到具体的应用并返回结果，为了实现对客户端请求的安全校验和权限控制，最简单和粗暴的方法就是为每个微服务应用都实现一套用于校验签名和鉴别权限的过滤器或拦截器。不过，这样的做法并不可取，它会增加日后的系统维护难度，因为同一个系统中的各种校验逻辑很多情况下都是大致相同或类似的，这样的实现方式会使得相似的校验逻辑代码被分散到了各个微服务中去，冗余代码的出现是我们不希望看到的。所以，比较好的做法是将这些校验逻辑剥离出去，构建出一个独立的鉴权服务。在完成了剥离之后，有不少开发者会直接在微服务应用中通过调用鉴权服务来实现校验，但是这样的做法仅仅只是解决了鉴权逻辑的分离，并没有在本质上将这部分不属于业余的逻辑拆分出原有的微服务应用，冗余的拦截器或过滤器依然会存在。 </p>
<p>由于网关服务的加入，外部客户端访问我们的系统已经有了统一入口，既然这些校验与具体业务无关，那何不在请求到达的时候就完成校验和过滤，而不是转发后再过滤而导致更长的请求延迟。同时，通过在网关中完成校验和过滤，微服务应用端就可以去除各种复杂的过滤器和拦截器了，这使得微服务应用的接口开发和测试复杂度也得到了相应的降低。</p>
<p>为了在API网关中实现对客户端请求的校验，我们将需要使用到Spring Cloud Zuul的另外一个核心功能：<strong>过滤器</strong>。</p>
<p> 我们定义了一个简单的Zuul过滤器，它实现了在请求被路由之前检查HttpServletRequest中是否有login参数，若有就进行路由，若没有就拒绝访问，返回401 Unauthorized错误。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulFilter</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">netflix</span>.<span class="title">zuul</span>.<span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * fileType的返回值类型表示为过滤器的类型，过滤器的类型表示在那个生命周期执行</span></span><br><span class="line"><span class="comment">     * pre,post,error,route,static</span></span><br><span class="line"><span class="comment">     * pre表示的是在路由之前执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示过滤器的执行顺序（多个过滤器时有意义）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *表示过滤器是否执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体的过滤规则</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = ctx.getRequest();</span><br><span class="line">        String login = request.getParameter( <span class="string">"login"</span> );</span><br><span class="line">        <span class="keyword">if</span>(login == <span class="keyword">null</span>)&#123;</span><br><span class="line">            ctx.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            ctx.setResponseStatusCode(<span class="number">401</span>);</span><br><span class="line">            ctx.addZuulResponseHeader(<span class="string">"content-type"</span>,<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">            ctx.setResponseBody(<span class="string">"无登陆信息"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在实现了自定义过滤器之后，它并不会直接生效，我们还需要为其创建具体的Bean才能启动该过滤器，比如，在应用主类中增加如下内容 ,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiGatewayApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(ApiGatewayApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function">ZuulFilter <span class="title">getZuulFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ZuulFilter();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新启动服务网关，再次访问 <a href="http://localhost:5679/mypath/consumer" target="_blank" rel="noopener">http://localhost:5679/mypath/consumer</a> ,页面显示</p>
<p><img src="/2019/11/26/spring-cloud-服务网关/gate.png" alt></p>
<p>这个时候通过网关必须携带login的信息  <a href="http://localhost:5679/mypath/consumer?login=2" target="_blank" rel="noopener">http://localhost:5679/mypath/consumer?login=2</a> </p>
<p> 到这里，对于Spring Cloud Zuul过滤器的基本功能就已介绍完毕。 </p>
<h2 id="zuul核心过滤器源码分析"><a href="#zuul核心过滤器源码分析" class="headerlink" title="zuul核心过滤器源码分析"></a>zuul核心过滤器源码分析</h2><p> 包含了对请求的路由和过滤两个功能，其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础；而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础。然而实际上，路由功能在真正运行时，它的路由映射和请求转发都是由几个不同的过滤器完成的。其中，路由映射主要通过pre类型的过滤器完成，它将请求路径与配置的路由规则进行匹配，以找到需要转发的目标地址；而请求转发的部分则是由route类型的过滤器来完成，对pre类型过滤器获得的路由地址进行转发。所以，过滤器可以说是Zuul实现API网关功能最为核心的部件，每一个进入Zuul的HTTP请求都会经过一系列的过滤器处理链得到请求响应并返回给客户端。 </p>
<p> Spring Cloud Zuul中实现的过滤器必须包含4个基本特征：过滤类型、执行顺序、执行条件、具体操作。这些元素看着似乎非常的熟悉，实际上它就是ZuulFilter接口中定义的四个抽象方法： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">filterType</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function">Object <span class="title">run</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>filterType：该函数需要返回一个字符串来代表过滤器的类型，而这个类型就是在HTTP请求过程中定义的各个阶段。在Zuul中默认定义了四种不同生命周期的过滤器类型，具体如下：<ul>
<li>pre：可以在请求被路由之前调用。</li>
<li>routing：在路由请求时候被调用。</li>
<li>post：在routing和error过滤器之后被调用。</li>
<li>error：处理请求时发生错误时被调用。</li>
</ul>
</li>
<li>filterOrder：通过int值来定义过滤器的执行顺序，数值越小优先级越高。</li>
<li>shouldFilter：返回一个boolean类型来判断该过滤器是否要执行。我们可以通过此方法来指定过滤器的有效范围。</li>
<li>run：过滤器的具体逻辑。在该函数中，我们可以实现自定义的过滤逻辑，来确定是否要拦截当前的请求，不对其进行后续的路由，或是在请求路由返回结果之后，对处理结果做一些加工等。</li>
</ul>
<h2 id="请求生命周期"><a href="#请求生命周期" class="headerlink" title="请求生命周期"></a>请求生命周期</h2><pre><code>Zuul默认定义了四个不同的过滤器类型，它们覆盖了一个外部HTTP请求到达API网关，直到返回请求结果的全部生命周期。下图源自Zuul的官方WIKI中关于请求生命周期的图解，它描述了一个HTTP请求到达API网关之后，如何在各个不同类型的过滤器之间流转的详细过程。 
</code></pre><p><img src="/2019/11/26/spring-cloud-服务网关/lifeCycle.png" alt></p>
<p> 当外部HTTP请求到达API网关服务的时候，首先它会进入第一个阶段pre，在这里它会被pre类型的过滤器进行处理，该类型的过滤器主要目的是在进行请求路由之前做一些前置加工，比如请求的校验等。在完成了pre类型的过滤器处理之后，请求进入第二个阶段routing，也就是之前说的路由请求转发阶段，请求将会被routing类型过滤器处理，这里的具体处理内容就是将外部请求转发到具体服务实例上去的过程，当服务实例将请求结果都返回之后，routing阶段完成，请求进入第三个阶段post，此时请求将会被post类型的过滤器进行处理，这些过滤器在处理的时候不仅可以获取到请求信息，还能获取到服务实例的返回信息，所以在post类型的过滤器中，我们可以对处理结果进行一些加工或转换等内容。另外，还有一个特殊的阶段error，该阶段只有在上述三个阶段中发生异常的时候才会触发，但是它的最后流向还是post类型的过滤器，因为它需要通过post过滤器将最终结果返回给请求客户端。 </p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>spring cloud</tag>
        <tag>zuul</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot创建webService</title>
    <url>/2019/11/20/spring-boot%E5%88%9B%E5%BB%BAwebService/</url>
    <content><![CDATA[<h1 id="Spring-boot-创建webService接口"><a href="#Spring-boot-创建webService接口" class="headerlink" title="Spring boot 创建webService接口"></a>Spring boot 创建webService接口</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li><strong>JDK 1.80_121</strong> </li>
<li><strong>spring boot :2.2.1.RELEASE</strong></li>
<li><strong>cxf-spring-boot-starter-jaxws：3.2.5</strong> </li>
</ul>
<h2 id="创建springboot-项目"><a href="#创建springboot-项目" class="headerlink" title="创建springboot 项目"></a>创建springboot 项目</h2><p>添加gradle依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// https://mvnrepository.com/artifact/org.apache.cxf/cxf-spring-boot-starter-jaxws</span></span><br><span class="line">	compile <span class="string">group:</span> <span class="string">'org.apache.cxf'</span>, <span class="string">name:</span> <span class="string">'cxf-spring-boot-starter-jaxws'</span>, <span class="string">version:</span> <span class="string">'3.2.5'</span></span><br><span class="line"><span class="comment">// https://mvnrepository.com/artifact/org.apache.commons/commons-lang3</span></span><br><span class="line">	compile <span class="string">group:</span> <span class="string">'org.apache.commons'</span>, <span class="string">name:</span> <span class="string">'commons-lang3'</span>, <span class="string">version:</span> <span class="string">'3.4'</span></span><br></pre></td></tr></table></figure>
<p>webService注解图示</p>
<p><img src="/2019/11/20/spring-boot创建webService/webservice.png" alt></p>
<h2 id="创建webService接口"><a href="#创建webService接口" class="headerlink" title="创建webService接口"></a>创建webService接口</h2><h3 id="创建接口"><a href="#创建接口" class="headerlink" title="创建接口"></a>创建接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebService</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WSDemoService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@WebMethod</span></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(@WebParam(name = <span class="string">"friend"</span>)</span> String friend)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建实现类"><a href="#创建实现类" class="headerlink" title="创建实现类"></a>创建实现类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@WebService</span>(name = <span class="string">"demoservice"</span>, targetNamespace = <span class="string">"http://WSDemoService.controller.webdemo1.example.com/"</span> ,endpointInterface = <span class="string">"com.example.webdemo1.controller.WSDemoService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WSDemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">WSDemoService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String friend)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(friend)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Who are you ?"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + friend + <span class="string">"!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注册及发布服务"><a href="#注册及发布服务" class="headerlink" title="注册及发布服务"></a>注册及发布服务</h3><p>这个地方的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.cxf.Bus;</span><br><span class="line"><span class="keyword">import</span> org.apache.cxf.bus.spring.SpringBus;</span><br><span class="line"><span class="keyword">import</span> org.apache.cxf.jaxws.EndpointImpl;</span><br><span class="line"><span class="keyword">import</span> org.apache.cxf.transport.servlet.CXFServlet;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.ws.Endpoint;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> WXY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> WebServiceConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> T0D0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/11/20 1:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebServiceConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"cxfServlet"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">dispatcherServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> CXFServlet(), <span class="string">"/service/*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = Bus.DEFAULT_BUS_ID)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpringBus <span class="title">springBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringBus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WSDemoService demoService; <span class="comment">//由于在实现类中加了@Service因此此处无需初始化实例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注册服务示例*/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Endpoint <span class="title">endpoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EndpointImpl endpoint = <span class="keyword">new</span> EndpointImpl(springBus(), demoService);</span><br><span class="line">        endpoint.publish(<span class="string">"/test"</span>);</span><br><span class="line">        <span class="keyword">return</span> endpoint;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问接口"><a href="#访问接口" class="headerlink" title="访问接口"></a>访问接口</h3><p>启动服务，并本地访问 <em> <a href="http://localhost:8080/service" target="_blank" rel="noopener">http://localhost:8080/service</a> </em>可以查看所有发布的webService接口</p>
<p><img src="/2019/11/20/spring-boot创建webService/serviceShow.png" alt></p>
<h1 id="xml格式数据的webService接口"><a href="#xml格式数据的webService接口" class="headerlink" title="xml格式数据的webService接口"></a>xml格式数据的webService接口</h1><p>​        虽然现在大部分结构数据格式是json,但是和一些老系统对接还是会用到webService这种跨语言的的接口，传输的数据格式也是XML。</p>
<h2 id="在项目中添加依赖"><a href="#在项目中添加依赖" class="headerlink" title="在项目中添加依赖"></a>在项目中添加依赖</h2><p>xml转换使用的工具是XmlMapper工具，</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	xml</span></span><br><span class="line">	compile <span class="string">group:</span> <span class="string">'com.fasterxml.jackson.core'</span>, <span class="string">name:</span> <span class="string">'jackson-core'</span>, <span class="string">version:</span> <span class="string">'2.10.0'</span></span><br><span class="line">	compile <span class="string">group:</span> <span class="string">'com.fasterxml.jackson.core'</span>, <span class="string">name:</span> <span class="string">'jackson-databind'</span>, <span class="string">version:</span> <span class="string">'2.10.0'</span></span><br><span class="line">	compile <span class="string">group:</span> <span class="string">'com.fasterxml.jackson.dataformat'</span>, <span class="string">name:</span> <span class="string">'jackson-dataformat-xml'</span>, <span class="string">version:</span> <span class="string">'2.10.0'</span></span><br></pre></td></tr></table></figure>
<h2 id="XML注解"><a href="#XML注解" class="headerlink" title="XML注解"></a>XML注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JacksonXmlRootElement</span>用于类名，是xml最外层的根节点。注解中有localName属性，该属性如果不设置，那么生成的XML最外面就是Clazz.</span><br><span class="line"><span class="meta">@JacksonXmlCData</span>注解是为了生成&lt;![CDATA[text]]&gt;</span><br><span class="line"><span class="meta">@JacksonXmlProperty</span>注解通常可以不需要，若不用，生成xml标签名称就是实体类属性名称。但是如果你想要你的xml节点名字，首字母大写。比如例子中的Content，那么必须加这个注解，并且注解的localName填上你想要的节点名字。最重要的是！实体类原来的属性content必须首字母小写！否则会被识别成两个不同的属性。注解的isAttribute，确认是否为节点的属性，如上面“gradeId”。</span><br><span class="line"><span class="meta">@JacksonXmlElementWrapper</span>一般用于list，list外层的标签。若不用的话，useWrapping =<span class="keyword">false</span></span><br><span class="line"><span class="meta">@JacksonXmlText</span>，用实体类属性上，说明该属性是否为简单内容，如果是，那么生成xml时，不会生成对应标签名称</span><br><span class="line"><span class="meta">@JsonIgnore</span>，忽略该实体类的属性，该注解是用于实体类转json的，但用于转xml一样有效，具体原因个人推测是XmlMapper是ObjectMapper的子类。</span><br></pre></td></tr></table></figure>
<h2 id="创建XML数据实体"><a href="#创建XML数据实体" class="headerlink" title="创建XML数据实体"></a>创建XML数据实体</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GradeDomain</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JacksonXmlProperty</span>(localName = <span class="string">"gradeId"</span>,isAttribute = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gradeId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JacksonXmlText</span></span><br><span class="line">    <span class="keyword">private</span> String gradeName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getGradeId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gradeId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGradeId</span><span class="params">(<span class="keyword">int</span> gradeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gradeId = gradeId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGradeName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gradeName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGradeName</span><span class="params">(String gradeName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gradeName = gradeName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScoreDomain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JacksonXmlProperty</span>(localName = <span class="string">"scoreName"</span>)</span><br><span class="line">    <span class="meta">@JacksonXmlCData</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JacksonXmlProperty</span>(localName = <span class="string">"scoreNumber"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JacksonXmlRootElement</span>(localName = <span class="string">"student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDomain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String studentName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JacksonXmlProperty</span>(localName = <span class="string">"age"</span>)</span><br><span class="line">    <span class="meta">@JacksonXmlCData</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JacksonXmlProperty</span>(localName = <span class="string">"grade"</span>)</span><br><span class="line">    <span class="keyword">private</span> GradeDomain grade;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JacksonXmlElementWrapper</span>(localName = <span class="string">"scoreList"</span>)</span><br><span class="line">    <span class="meta">@JacksonXmlProperty</span>(localName = <span class="string">"score"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;ScoreDomain&gt; scores;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建服务接口"><a href="#创建服务接口" class="headerlink" title="创建服务接口"></a>创建服务接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebMethod</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> OperateResult <span class="title">dataCheck</span><span class="params">(@WebParam(name = <span class="string">"student"</span>)</span>StudentDomain studentDomain)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="XmlMapper配置属性"><a href="#XmlMapper配置属性" class="headerlink" title="XmlMapper配置属性"></a>XmlMapper配置属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMapper xmlMapper = <span class="keyword">new</span> XmlMapper();</span><br><span class="line"><span class="comment">//反序列化时，若实体类没有对应的属性，是否抛出JsonMappingException异常，false忽略掉</span></span><br><span class="line">xmlMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//序列化是否绕根元素，true，则以类名为根元素</span></span><br><span class="line">xmlMapper.configure(SerializationFeature.WRAP_ROOT_VALUE, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//忽略空属性</span></span><br><span class="line">xmlMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line"><span class="comment">//XML标签名:使用骆驼命名的属性名，</span></span><br><span class="line">xmlMapper.setPropertyNamingStrategy(PropertyNamingStrategy.UPPER_CAMEL_CASE);</span><br><span class="line"><span class="comment">//设置转换模式</span></span><br><span class="line">xmlMapper.enable(MapperFeature.USE_STD_BEAN_NAMING);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public OperateResult dataCheck(StudentDomain studentDomain) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line"></span><br><span class="line">           ObjectMapper xmlMapper = new XmlMapper();</span><br><span class="line">           xmlMapper.configure( DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false );</span><br><span class="line">           xmlMapper.configure( SerializationFeature.WRAP_ROOT_VALUE,false );</span><br><span class="line">           xmlMapper.setSerializationInclusion( JsonInclude.Include.NON_NULL );</span><br><span class="line">           xmlMapper.setPropertyNamingStrategy( PropertyNamingStrategy.UPPER_CAMEL_CASE );</span><br><span class="line">           xmlMapper.enable( MapperFeature.USE_STD_BEAN_NAMING );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           StudentDomain domain = new StudentDomain();</span><br><span class="line">           domain.setStudentName( &quot;张三&quot; );</span><br><span class="line">           domain.setAge( 18 );</span><br><span class="line">           GradeDomain grade = new GradeDomain();</span><br><span class="line">           grade.setGradeId( 1 );</span><br><span class="line">           grade.setGradeName( &quot;高三&quot; );</span><br><span class="line">           domain.setGrade( grade );</span><br><span class="line">           ScoreDomain score1 = new ScoreDomain();</span><br><span class="line">           score1.setName( &quot;语文&quot; );</span><br><span class="line">           score1.setScore( 90 );</span><br><span class="line">           ScoreDomain score2 = new ScoreDomain();</span><br><span class="line">           score2.setName( &quot;数学&quot; );</span><br><span class="line">           score2.setScore( 98 );</span><br><span class="line">           ScoreDomain score3 = new ScoreDomain();</span><br><span class="line">           score3.setName( &quot;英语&quot; );</span><br><span class="line">           score3.setScore( 91 );</span><br><span class="line">           List&lt;ScoreDomain&gt; scores = Arrays.asList( score1,score2,score3 );</span><br><span class="line">           domain.setScores( scores );</span><br><span class="line">           String xml = xmlMapper.writeValueAsString( domain );</span><br><span class="line">           System.out.println( xml );</span><br><span class="line">           StudentDomain studentDomain1 = xmlMapper.readValue( xml,StudentDomain.class );</span><br><span class="line">           System.out.println( studentDomain1 );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           return new OperateResult( &quot;S&quot;,&quot;嘿嘿嘿&quot; );</span><br><span class="line">       &#125;catch (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           return new OperateResult(&quot;F&quot;,&quot;哈哈哈&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>再启动服务调用 <a href="http://localhost:8080/service/test?wsdl" target="_blank" rel="noopener">http://localhost:8080/service/test?wsdl</a> ，可以使用soapui测试接口</p>
<h1 id="生成客户端"><a href="#生成客户端" class="headerlink" title="生成客户端"></a>生成客户端</h1><p> 右键生成的目标包 -&gt; 菜单拉倒最后一个 “WebServices”,输入WSDL生成客户端，<img src="/2019/11/20/spring-boot创建webService/client.png" alt></p>
<p>创建测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       WSDemoServiceImplService service = <span class="keyword">new</span> WSDemoServiceImplService(</span><br><span class="line">               WSDemoServiceImplService.WSDEMOSERVICEIMPLSERVICE_WSDL_LOCATION,</span><br><span class="line">               WSDemoServiceImplService.WSDEMOSERVICEIMPLSERVICE_QNAME);</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">"下面是hello打印的数据"</span>);</span><br><span class="line">       System.out.println(service.getDemoservicePort().hello(<span class="string">"haha"</span>));</span><br><span class="line">       System.out.println(<span class="string">"下面是dataCheck打印的数据"</span>);</span><br><span class="line">       OperateResult operateResult = service.getDemoservicePort().dataCheck( <span class="keyword">null</span> );</span><br><span class="line">       System.out.println(service.getDemoservicePort().dataCheck( <span class="keyword">null</span> ));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>关于webService整理就到这了.. </p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>webService</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud 分布式配置中心</title>
    <url>/2019/11/12/spring-cloud-%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<h1 id="分布式配置中心（Dalston版本）"><a href="#分布式配置中心（Dalston版本）" class="headerlink" title="分布式配置中心（Dalston版本）"></a>分布式配置中心（Dalston版本）</h1><h2 id="传统作法"><a href="#传统作法" class="headerlink" title="传统作法"></a>传统作法</h2><p>​    通常在生产环境，Config Server与服务注册中心一样，我们也需要将其扩展为高可用的集群。在之前实现的config-server基础上来实现高可用非常简单，不需要我们为这些服务端做任何额外的配置，只需要遵守一个配置规则：将所有的Config Server都指向同一个Git仓库，这样所有的配置内容就通过统一的共享文件系统来维护，而客户端在指定Config Server位置时，只要配置Config Server外的均衡负载即可，就像如下图所示的结构：</p>
<p><img src="/2019/11/12/spring-cloud-分布式配置中心/config.png" alt></p>
<h2 id="服务端-config-server"><a href="#服务端-config-server" class="headerlink" title="服务端 config-server"></a>服务端 config-server</h2><p>首先需要准备一个<a href="https://github.com/pignum1/config.git" target="_blank" rel="noopener">git仓库</a>，作为分布式配置的管理</p>
<p>创建idea的配置服务端,引入服务端的配置依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'org.springframework.cloud:spring-cloud-config-server'</span></span><br><span class="line">#刷新配置</span><br><span class="line">implementation <span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span></span><br></pre></td></tr></table></figure>
<p>在application.properties种添加配置文件和Git的地址，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#服务端口</span><br><span class="line">server.port=9876</span><br><span class="line">#服务名称</span><br><span class="line">spring.application.name=myConfigServer</span><br><span class="line">#服务注册中心</span><br><span class="line"></span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:5678/eureka/</span><br><span class="line">#服务的git仓库地址</span><br><span class="line">spring.cloud.config.server.git.uri=https://github.com/pignum1/config.git</span><br><span class="line">#配置文件所在的目录</span><br><span class="line">spring.cloud.config.server.git.search-paths=/order</span><br><span class="line">#配置文件所在的分支</span><br><span class="line">spring.cloud.config.label=master</span><br><span class="line"></span><br><span class="line">#spring cloud2.x刷新配置需要开启</span><br><span class="line">management.endpoints.web.exposure.include=refresh,health,info</span><br></pre></td></tr></table></figure>
<p>在启动类商添加注解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableConfigServer</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@ResponseBody</span><br><span class="line">public class ConfigServerApplication &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ConfigServerApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 启动服务后，按照配置文件的访问路径规则去请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]</span><br><span class="line">/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line">/&#123;application&#125;-&#123;profile&#125;.properties</span><br><span class="line">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties</span><br></pre></td></tr></table></figure>
<p>​        启动服务后访问 <a href="http://localhost:9876/order/a/master" target="_blank" rel="noopener">http://localhost:9876/order/a/master</a> ，访问order文件下的order-a.properties文件，可以得到返回的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;order&quot;,</span><br><span class="line">  &quot;profiles&quot;: [</span><br><span class="line">    &quot;a&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;label&quot;: &quot;master&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;ab1b5e0ba15605570591d632977d8debcf7f77a9&quot;,</span><br><span class="line">  &quot;state&quot;: null,</span><br><span class="line">  &quot;propertySources&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;https://github.com/pignum1/config.git/order/order-a.properties&quot;,</span><br><span class="line">      &quot;source&quot;: &#123;</span><br><span class="line">        &quot;from&quot;: &quot;123&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的道德JSON字符串是因为我移除了spring cloud 默认的xml格式转换消息器 ,</p>
<p>在配置类中移除依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 删除xml格式转换消息器</span><br><span class="line"> */</span><br><span class="line">configurations &#123;</span><br><span class="line">	all*.exclude group: &apos;com.fasterxml.jackson.dataformat&apos;, module: &apos;jackson-dataformat-xml&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="客户端-config-client"><a href="#客户端-config-client" class="headerlink" title="客户端 config-client"></a>客户端 config-client</h2><p>同样创建一个spring cloud 项目，在依赖管理添加客户端的依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//客户端依赖</span><br><span class="line">implementation &apos;org.springframework.cloud:spring-cloud-starter-config&apos;</span><br><span class="line">//mvc</span><br><span class="line">implementation &apos;org.springframework.boot:spring-boot-starter-web&apos;</span><br><span class="line">#刷新配置</span><br><span class="line">implementation &apos;org.springframework.boot:spring-boot-starter-actuator&apos;</span><br><span class="line">#注册中心依赖</span><br><span class="line">implementation &apos;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&apos;</span><br></pre></td></tr></table></figure>
<p>在resources下新建 bootstrap . yml文件，因为spring cloud的配置先读取的是bootstrap 文件。读取的顺序是bootstrap &gt;连接config获取的配置文件&gt; application 文件。否则启动时服务端拉数据的默认端口是8888</p>
<p>bootstrap . yml配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://localhost:5678/eureka/</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: order</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      uri: http://localhost:9876</span><br><span class="line">      profile: a</span><br><span class="line">      label: master</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8030</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: refresh</span><br></pre></td></tr></table></figure>
<p>此时启动客户端，控制台会打印下面的信息</p>
<p><img src="/2019/11/12/spring-cloud-分布式配置中心/console.png" alt></p>
<p>创建测试controller，这个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RefreshScope</span><br><span class="line">@RestController</span><br><span class="line">public class TestController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;from&#125;&quot;)</span><br><span class="line">    private String from;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/service&quot;)</span><br><span class="line">    public String from() &#123;</span><br><span class="line"></span><br><span class="line">        return this.from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFrom(String from) &#123;</span><br><span class="line">        this.from = from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getFrom() &#123;</span><br><span class="line">        return from;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求 <a href="http://localhost:8030/service" target="_blank" rel="noopener">http://localhost:8030/service</a> ，页面上显示值为 123</p>
<p>如果这个时候修改order-a.properties 文件里面的from值为321，再次发起请求时页面仍未123，这时只要使用post方法请求  <a href="http://localhost:8030/actuator/refresh" target="_blank" rel="noopener">http://localhost:8030/actuator/refresh</a>  刷新配置，再次请求<a href="http://localhost:8030/service" target="_blank" rel="noopener">http://localhost:8030/service</a> ，页面上显示的值就成了321 。</p>
<h2 id="添加重试机制"><a href="#添加重试机制" class="headerlink" title="添加重试机制"></a>添加重试机制</h2><p>当该方法有很多服务，需要一个一个去刷新，一般使用 MQ+spring-could-bus 消息总线模式来批量更新配置信息。  还有一个附加的，就是在服务端在从配置中心获取配置信息时，如果出现了网络波动，导致项目启动时无法获取信息的话，可以使用如下配置来规避。<br>还是在config-client项目上进行扩展 依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#重试机制的依赖</span><br><span class="line">implementation &apos;org.springframework.retry:spring-retry&apos;</span><br><span class="line">implementation &apos;org.springframework.boot:spring-boot-starter-aop&apos;</span><br></pre></td></tr></table></figure>
<p>在config的客户端  application.properties 添加配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#retry</span><br><span class="line">#和重试机制相关的配置有如下四个：</span><br><span class="line"># 配置重试次数，默认为6</span><br><span class="line">spring.cloud.config.retry.max-attempts=6</span><br><span class="line"># 间隔乘数，默认1.1</span><br><span class="line">spring.cloud.config.retry.multiplier=1.1</span><br><span class="line"># 初始重试间隔时间，默认1000ms</span><br><span class="line">spring.cloud.config.retry.initial-interval=1000</span><br><span class="line"># 最大间隔时间，默认2000ms</span><br><span class="line">spring.cloud.config.retry.max-interval=2000</span><br></pre></td></tr></table></figure>
<p>在bootstrap .yml添加配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#启动失败时能够快速响应</span><br><span class="line">#spring:</span><br><span class="line">		cloud:</span><br><span class="line">			config:</span><br><span class="line">				fail-fast=true</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>spring cloud</tag>
        <tag>config</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud-hystrix</title>
    <url>/2019/11/12/springcloud-hystrix/</url>
    <content><![CDATA[<h1 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h1><pre><code>在分布式环境中，许多服务依赖项中的一些必然会失败。Hystrix是一个库，通过添加延迟容忍和容错逻辑，帮助你控制这些分布式服务之间的交互。Hystrix通过隔离服务之间的访问点、停止级联失败和提供回退选项来实现这一点，所有这些都可以提高系统的整体弹性 
</code></pre><h2 id="Hystrix的设计目的"><a href="#Hystrix的设计目的" class="headerlink" title="Hystrix的设计目的"></a>Hystrix的设计目的</h2><ol>
<li>对通过第三方客户端库访问的依赖项（通常是通过网络）的延迟和故障进行保护和控制。</li>
<li>在复杂的分布式系统中阻止级联故障。</li>
<li>快速失败，快速恢复。</li>
<li>回退，尽可能优雅地降级。</li>
<li>启用近实时监控、警报和操作控制。</li>
</ol>
<p>​        复杂分布式体系结构中的应用程序有许多依赖项，每个依赖项在某些时候都不可避免地会失败。如果主机应用程序没有与这些外部故障隔离，那么它有可能被他们拖垮。</p>
<h2 id="Hystrix设计原则"><a href="#Hystrix设计原则" class="headerlink" title="Hystrix设计原则"></a>Hystrix设计原则</h2><ul>
<li>防止任何单个依赖项耗尽所有容器（如Tomcat）用户线程。</li>
<li>甩掉包袱，快速失败而不是排队。</li>
<li>在任何可行的地方提供回退，以保护用户不受失败的影响。</li>
<li>使用隔离技术（如隔离板、泳道和断路器模式）来限制任何一个依赖项的影响。</li>
<li>通过近实时的度量、监视和警报来优化发现时间。</li>
<li>通过配置的低延迟传播来优化恢复时间。</li>
<li>支持对Hystrix的大多数方面的动态属性更改，允许使用低延迟反馈循环进行实时操作修改。</li>
<li>避免在整个依赖客户端执行中出现故障，而不仅仅是在网络流量中。</li>
</ul>
<h2 id="Hystrix是如何实现它的目标的"><a href="#Hystrix是如何实现它的目标的" class="headerlink" title="Hystrix是如何实现它的目标的"></a>Hystrix是如何实现它的目标的</h2><ol>
<li>用一个HystrixCommand 或者 HystrixObservableCommand （这是命令模式的一个例子）包装所有的对外部系统（或者依赖）的调用，典型地它们在一个单独的线程中执行</li>
<li>调用超时时间比你自己定义的阈值要长。有一个默认值，对于大多数的依赖项你是可以自定义超时时间的。</li>
<li>为每个依赖项维护一个小的线程池(或信号量)；如果线程池满了，那么该依赖性将会立即拒绝请求，而不是排队。</li>
<li>调用的结果有这么几种：成功、失败（客户端抛出异常）、超时、拒绝。</li>
<li>在一段时间内，如果服务的错误百分比超过了一个阈值，就会触发一个断路器来停止对特定服务的所有请求，无论是手动的还是自动的。</li>
<li>当请求失败、被拒绝、超时或短路时，执行回退逻辑。</li>
<li><p>近实时监控指标和配置变化。</p>
<p>当你使用Hystrix来包装每个依赖项时，上图中所示的架构会发生变化，如下图所示： </p>
<p>每个依赖项相互隔离，当延迟发生时，它会被限制在资源中，并包含回退逻辑，该逻辑决定在依赖项中发生任何类型的故障时应作出何种响应： </p>
</li>
</ol>
<p><img src="/2019/11/12/springcloud-hystrix/depence.png" alt></p>
<h1 id="Hystrix的使用"><a href="#Hystrix的使用" class="headerlink" title="Hystrix的使用"></a>Hystrix的使用</h1><h2 id="服务容错保护（Hystrix服务降级）"><a href="#服务容错保护（Hystrix服务降级）" class="headerlink" title="服务容错保护（Hystrix服务降级）"></a>服务容错保护（Hystrix服务降级）</h2><p> 使用Spring Cloud Hystrix实现断路器 </p>
<p>创建两个spring cloud服务，一个服务方，一个调用方，在调用方中添加断路器的依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-hystrix'</span></span><br></pre></td></tr></table></figure>
<p>创建服务提供方 Hystrix-demo1，创建测试方法，添加线程睡眠5秒来触发断路器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep( <span class="number">50000</span> );</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"wake"</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="string">"sleep"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建调用方  Hystrix-demo2，</p>
<p>在启动类商添加注解来启用断路器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br></pre></td></tr></table></figure>
<p>测试请求方法， API方法加上了@HystrixCommand注解，并设置fallbackMethod属性为回退方法名称 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">consumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/consumer"</span>)</span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"fallback"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://hystrix-demo1/hello"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"fallback"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分别启动服务提供者和服务消费者，并用POSTMAN 调用consumer方法，此时页面返回的数据为</p>
<p><img src="/2019/11/12/springcloud-hystrix/down.png" alt></p>
<pre><code>以看到服务提供方输出了原本要返回的结果，但是由于返回前延迟了5秒，而服务消费方触发了服务请求超时异常，服务消费者就通过HystrixCommand注解中指定的降级逻辑进行执行，因此该请求的结果返回了`fallback`。这样的机制，对自身服务起到了基础的保护，同时还为异常情况提供了自动的服务降级切换机制。 
</code></pre><h2 id="依赖隔离"><a href="#依赖隔离" class="headerlink" title="依赖隔离"></a>依赖隔离</h2><pre><code>而Hystrix使用该模式实现线程池的隔离，它会为每一个Hystrix命令创建一个独立的线程池，这样就算某个在Hystrix命令包装下的依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响，而不会拖慢其他的服务。 
</code></pre><ul>
<li>应用自身得到完全的保护，不会受不可控的依赖服务影响。即便给依赖服务分配的线程池被填满，也不会影响应用自身的额其余部分。</li>
<li>可以有效的降低接入新服务的风险。如果新服务接入后运行不稳定或存在问题，完全不会影响到应用其他的请求。</li>
<li>当依赖的服务从失效恢复正常后，它的线程池会被清理并且能够马上恢复健康的服务，相比之下容器级别的清理恢复速度要慢得多。</li>
<li>当依赖的服务出现配置错误的时候，线程池会快速的反应出此问题（通过失败次数、延迟、超时、拒绝等指标的增加情况）。同时，我们可以在不影响应用功能的情况下通过实时的动态属性刷新（后续会通过Spring Cloud Config与Spring Cloud Bus的联合使用来介绍）来处理它。</li>
<li>当依赖的服务因实现机制调整等原因造成其性能出现很大变化的时候，此时线程池的监控指标信息会反映出这样的变化。同时，我们也可以通过实时动态刷新自身应用对依赖服务的阈值进行调整以适应依赖方的改变。</li>
<li><p>除了上面通过线程池隔离服务发挥的优点之外，每个专有线程池都提供了内置的并发实现，可以利用它为同步的依赖服务构建异步的访问。</p>
<p>我们使用了@HystrixCommand来将某个函数包装成了Hystrix命令，这里除了定义服务降级之外，Hystrix框架就会自动的为这个函数实现调用的隔离。所以，依赖隔离、服务降级在使用时候都是一体化实现的，这样利用Hystrix来实现服务容错保护在编程模型上就非常方便的，并且考虑更为全面。 </p>
</li>
</ul>
<h2 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h2><p> “断路器”本身是一种开关装置，用于在电路上保护线路过载，当线路中有电器发生短路时，“断路器”能够及时的切断故障电路，  分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），直接切断原来的主逻辑调用。 </p>
<p> 那么断路器是在什么情况下开始起作用呢？这里涉及到断路器的三个重要参数：快照时间窗、请求总数下限、错误百分比下限 </p>
<ul>
<li>快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。</li>
<li>请求总数下限：在快照时间窗内，必须满足请求总数下限才有资格根据熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用此时不足20次，即时所有的请求都超时或其他原因失败，断路器都不会打开。</li>
<li><p>错误百分比下限：当请求总数在快照时间窗内超过了下限，比如发生了30次调用，如果在这30次调用中，有16次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%下限情况下，这时候就会将断路器打开。</p>
<p>在断路器打开之后，处理逻辑并没有结束，我们的降级逻辑已经被成了主逻辑，那么原来的主逻辑要如何恢复呢？对于这一问题，hystrix也为我们实现了自动恢复功能。当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。 </p>
</li>
</ul>
<h1 id="Hystrix监控面板"><a href="#Hystrix监控面板" class="headerlink" title="Hystrix监控面板"></a>Hystrix监控面板</h1><p> 断路器是根据一段时间窗内的请求情况来判断并操作断路器的打开和关闭状态的。而这些请求情况的指标信息都是HystrixCommand和HystrixObservableCommand实例在执行过程中记录的重要度量信息，它们除了Hystrix断路器实现中使用之外，对于系统运维也有非常大的帮助。 </p>
<p> 下面我们基于之前的示例来结合Hystrix Dashboard实现Hystrix指标数据的可视化面板， 我们将用到的几个应用  </p>
<ul>
<li>cloud-eureka-server：服务注册中心</li>
<li>Hystrix-demo1：服务提供者</li>
<li><p>Hystrix-demo2：使服务消费者</p>
<p>创建一个标准的Spring Boot工程，命名为：hystrix-dashboard ,添加依赖</p>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span></span><br><span class="line">implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-hystrix'</span></span><br><span class="line">implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-hystrix-dashboard'</span></span><br></pre></td></tr></table></figure>
<p>在启动类上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixDashboardApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(HystrixDashboardApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">hystrix-dashboard</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">1301</span></span><br></pre></td></tr></table></figure>
<p>启动项目后访问  <a href="http://localhost:1301/hystrix" target="_blank" rel="noopener">http://localhost:1301/hystrix</a> ，显示页面如下</p>
<p><img src="/2019/11/12/springcloud-hystrix/hystrix.png" alt></p>
<p>这是Hystrix Dashboard的监控首页，该页面中并没有具体的监控信息。从页面的文字内容中我们可以知道，Hystrix Dashboard共支持三种不同的监控方式，依次为：</p>
<ul>
<li>默认的集群监控：通过URL<code>http://turbine-h；ostname:port/turbine.stream</code>开启，实现对默认集群的监控。</li>
<li>指定的集群监控：通过URL<code>http://turbine-hostname:port/turbine.stream?cluster=[clusterName]</code>开启，实现对clusterName集群的监控。</li>
<li>单体应用的监控：通过URL<code>http://hystrix-app:port/hystrix.stream</code>开启，实现对具体某个服务实例的监控。</li>
</ul>
<p>前两者都对集群的监控，需要整合Turbine才能实现，我们主要实现对单个服务实例的监控，所以这里我们先来实现<strong>单个服务实例</strong>的监控。</p>
<p>既然Hystrix Dashboard监控单实例节点需要通过访问实例的<code>/hystrix.stream</code>接口来实现，自然我们需要为服务实例添加这个端点，而添加该功能的步骤也同样简单。</p>
<h2 id="单个服务实例的监控"><a href="#单个服务实例的监控" class="headerlink" title="单个服务实例的监控"></a><strong>单个服务实例</strong>的监控</h2><p> Hystrix Dashboard 监控的结构</p>
<p><img src="/2019/11/12/springcloud-hystrix/struct.png" alt></p>
<p>在<strong>服务消费者</strong>（Hystrix-demo2）实例中添加监听配置</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-hystrix'</span>implementation <span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span></span><br></pre></td></tr></table></figure>
<p>添加配置文件</p>
 <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#为服务实例（被监控服务）添加这个 endpoint，修改服务实例的配置文件，添加对actuator的配置</span></span><br><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">hystrix.stream</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改Hystrix默认超时时间</span></span><br><span class="line"><span class="meta">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</span> = <span class="string">2000</span></span><br></pre></td></tr></table></figure>
<p>在启动类种添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">hystrixMetricsStreamServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServletRegistrationBean registration = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> HystrixMetricsStreamServlet());</span><br><span class="line">    registration.addUrlMappings(<span class="string">"/hystrix.stream"</span>);</span><br><span class="line">    <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时在 <a href="http://localhost:1301/hystrix" target="_blank" rel="noopener">http://localhost:1301/hystrix</a>  输入框中输入http://:服务消费者IP:服务消费端口/hystrix.stream，</p>
<p>这个时候页面显示的是Loading,发起服务容错种的consumer请求，页面上<img src="/2019/11/12/springcloud-hystrix/hystrixScreen.png" alt></p>
<p>显示的各个参数解释引用别人的图<img src="/2019/11/12/springcloud-hystrix/hystrixParams.png" alt></p>
<p> 这里就对单体服务的监控介绍完了。但是在分布式系统中往往有很多服务需要监控。</p>
<p> <em>注意：当使用Hystrix Dashboard监控Spring Cloud Zuul构建的API网关时，ThreadPool信息会一直处于Loading状态，这是由于Zuul默认使用信号量来实现隔离，只有通过Hystrix配置把隔离机制改为线程池的方式才能得以展示。</em> </p>
<h1 id="Hystrix监控数据聚合"><a href="#Hystrix监控数据聚合" class="headerlink" title="Hystrix监控数据聚合"></a>Hystrix监控数据聚合</h1><p>​        通过Hystrix Dashboard，我们可以方便的查看服务实例的综合情况，比如：服务调用次数、服务调用延迟等。但是仅通过Hystrix Dashboard我们只能实现对服务当个实例的数据展现，在生产环境我们的服务是肯定需要做高可用的，那么对于多实例的情况，我们就需要将这些度量指标数据进行聚合。下面我们就来介绍一下另外一个工具：Turbine。 </p>
<p>​    上文中构建的有</p>
<ul>
<li>eureka-server：服务注册中心</li>
<li>Hystrix-demo1：服务提供者</li>
<li>Hystrix-demo1：使用ribbon和hystrix实现的服务消费者</li>
<li>hystrix-dashboard：用于展示<code>eureka-consumer-ribbon-hystrix</code>服务的Hystrix数据</li>
</ul>
<h3 id="通过HTTP收集聚合（turbine检测单个集群-）"><a href="#通过HTTP收集聚合（turbine检测单个集群-）" class="headerlink" title="通过HTTP收集聚合（turbine检测单个集群 ）"></a>通过HTTP收集聚合（turbine检测单个集群 ）</h3><p>创建一个新的 Spring Boot工程，命名为：turbine </p>
<p>添加依赖和properties的配置</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">	implementation <span class="string">'org.springframework.boot:spring-boot-starter-web'</span></span><br><span class="line"></span><br><span class="line">	implementation <span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span></span><br><span class="line">	implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-hystrix'</span></span><br><span class="line"><span class="comment">//	implementation 'org.springframework.cloud:spring-cloud-starter-netflix-turbine-stream'</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-turbine</span></span><br><span class="line">	compile <span class="string">group:</span> <span class="string">'org.springframework.cloud'</span>, <span class="string">name:</span> <span class="string">'spring-cloud-starter-turbine'</span>, <span class="string">version:</span> <span class="string">'1.4.7.RELEASE'</span></span><br><span class="line"><span class="comment">// https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka</span></span><br><span class="line">	compile <span class="string">group:</span> <span class="string">'org.springframework.cloud'</span>, <span class="string">name:</span> <span class="string">'spring-cloud-starter-eureka'</span>, <span class="string">version:</span> <span class="string">'1.4.7.RELEASE'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">turbine</span></span><br><span class="line"></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8989</span></span><br><span class="line"></span><br><span class="line"><span class="meta">management.server.port</span>=<span class="string">8990</span></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://localhost:5678/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#turbine.app-config参数指定了需要收集监控信息的服务名,这里监测的服务消费者，多个,隔开</span></span><br><span class="line"><span class="meta">turbine.app-config</span>=<span class="string">Hystrix-demo2 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数指定了集群名称为default，当我们服务数量非常多的时候，可以启动多个Turbine服务来构建不同的聚合集群，而该参数可以用来区分这些不同的聚合集群，</span></span><br><span class="line"><span class="comment"># 同时该参数值可以在Hystrix仪表盘中用来定位不同的聚合集群，只需要在Hystrix Stream的URL中通过cluster参数来指定；</span></span><br><span class="line"><span class="meta">turbine.cluster-name-expression</span>=<span class="string">"default"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#eureka.instance.hostname= mymaster</span></span><br><span class="line"><span class="comment">#eureka.instance.prefer-ip-address=false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数设置为true，可以让同一主机上的服务通过主机名与端口号的组合来进行区分，</span></span><br><span class="line"><span class="comment"># 默认情况下会以host来区分不同的服务，这会使得在本地调试的时候，本机上的不同服务聚合成一个服务来统计</span></span><br><span class="line"><span class="meta">turbine.combine-host-port</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<p>在启动类上添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableTurbine</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurbineApplication</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(TurbineApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时再启动turbine 服务，再在 <a href="http://localhost:1301/hystrix" target="_blank" rel="noopener">http://localhost:1301/hystrix</a>  输入turbine 的<a href="http://localhost:8989/turbine.stream，这时候页面上还是Loading,再访问一次消费者的consumer端口" target="_blank" rel="noopener">http://localhost:8989/turbine.stream，这时候页面上还是Loading,再访问一次消费者的consumer端口</a> <a href="http://localhost:5888/consumer" target="_blank" rel="noopener">http://localhost:5888/consumer</a> </p>
<p><img src="/2019/11/12/springcloud-hystrix/single.png" alt></p>
<p>这格式化系统的架构如下图</p>
<p><img src="/2019/11/12/springcloud-hystrix/singleStruct.png" alt> </p>
<h3 id="通过消息代理收集聚合（AMQP）"><a href="#通过消息代理收集聚合（AMQP）" class="headerlink" title="通过消息代理收集聚合（AMQP）"></a>通过消息代理收集聚合（AMQP）</h3><p> pring Cloud在封装Turbine的时候，还实现了基于消息代理的收集实现。所以，我们可以将所有需要收集的监控信息都输出到消息代理中，然后Turbine服务再从消息代理中异步的获取这些监控信息，最后将这些监控信息聚合并输出到Hystrix Dashboard中。通过引入消息代理，我们的Turbine和Hystrix Dashoard实现的监控架构可以改成如下图所示的结构： </p>
<p><img src="/2019/11/12/springcloud-hystrix/t-ampq.png" alt></p>
<p>这块等我整理完rabbitmq在回来</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>spring cloud</tag>
        <tag>hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot rabbit</title>
    <url>/2019/08/25/spring-boot-rabbit/</url>
    <content><![CDATA[<h1 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h1><p>消息队列（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message而已。主要用于不同进程Process/线程Thread之间通信。<br>消息队列的好处：<br>不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个。<br>不同进程（process）之间传递消息时，为了实现标准化，将消息的格式规范化了，并且，某一个进程接受的消息太多，一下子无法处理完，并且也有先后顺序，必须对收到的消息进行排队，因此诞生了事实上的消息队列。<br>MQ框架非常之多，比较流行的有RabbitMq、ActiveMq、ZeroMq、kafka，以及阿里开源的RocketMQ。</p>
<h1 id="RabbitMQ的安装"><a href="#RabbitMQ的安装" class="headerlink" title="RabbitMQ的安装"></a>RabbitMQ的安装</h1><p>linux（centos7.6）下的安装，因为是erlang语言写的，所以首先需要安装erlang,我的习惯是创建/usr/local/erlang,/usr/local/rabbitMQ两个文件夹。<br>首先是安装erlang<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//切换目录到/usr/local/erlang</span><br><span class="line">cd  /usr/local/erlang</span><br><span class="line">//下载</span><br><span class="line">wget http://www.rabbitmq.com/releases/erlang/erlang-19.0.4-1.el7.centos.x86_64.rpm</span><br><span class="line">//安装</span><br><span class="line">rpm -ivh erlang-19.0.4-1.el7.centos.x86_64.rpm</span><br><span class="line">//查看erlang版本</span><br><span class="line">erl</span><br></pre></td></tr></table></figure></p>
<p>出现下面的图样，说明安装成功了<br><img src="/2019/08/25/spring-boot-rabbit/erlang.png" alt><br>接着就是安装rabbitMQ,需要注意的是erlang 和 rabbitMQ的版本关系，最好取官网上查询对应的安装版本。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//切换目录到rabbitMQ</span><br><span class="line">cd /usr/local/rabbitMq</span><br><span class="line">//下载</span><br><span class="line">wget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.15/rabbitmq-server-3.6.15-1.el7.noarch.rpm</span><br><span class="line">//安装</span><br><span class="line">rpm -ivh rabbitmq-server-3.6.15-1.el7.noarch.rpm</span><br><span class="line">//检查rabbitMq是否安装成功</span><br><span class="line">rpm -qa|grep rabbitmq</span><br></pre></td></tr></table></figure></p>
<p>同样输入rpm -qa|grep rabbitmq会出现下面的图片<br><img src="/2019/08/25/spring-boot-rabbit/rabbitmq.png" alt><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//启动rabbitmq</span><br><span class="line">systemctl start rabbitmq-server</span><br><span class="line">//关闭rabbitmq</span><br><span class="line">systemctl stop rabbitmq-server</span><br><span class="line">//查看运行状态</span><br><span class="line">systemctl status rabbitmq-server</span><br><span class="line">//启动网页插件</span><br><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure></p>
<p>但是这个时候还需要开通服务器的端口，5672（服务端口）和15672（网页插件）<br>出现绿色running说明运行起来了<br><img src="/2019/08/25/spring-boot-rabbit/rabbitmqstatus.png" alt><br>但是因为默认的rabbirmq.conf的默认配置是# loopback_users.guest = true，不能在本机外登陆guest账号，(也能改成false,就可以了)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//列出角色</span><br><span class="line">rabbitmqctl list_users</span><br><span class="line">//新增角色</span><br><span class="line">rabbitmqctl add_user wxy wxy</span><br><span class="line">//添加权限</span><br><span class="line">rabbitmqctl set_permissions -p / wxy &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line">//修改用户的角色(我设置的是超级管理员，还有监控者，管理者等，了解更多去官网吧)</span><br><span class="line">rabbitmqctl set_user_tags wxy administrator</span><br><span class="line">//删除用户</span><br><span class="line">rabbitmqctl delete_user Username</span><br><span class="line">//修改密码</span><br><span class="line">rabbitmqctl change_password Username Newpassword</span><br></pre></td></tr></table></figure></p>
<h1 id="rabbitmq的五种队列"><a href="#rabbitmq的五种队列" class="headerlink" title="rabbitmq的五种队列"></a>rabbitmq的五种队列</h1><p>创建一个虚拟的virtualhost,给用户这个分配这个虚拟服务的权限<br><img src="/2019/08/25/spring-boot-rabbit/virtualhost.png" alt><br><img src="/2019/08/25/spring-boot-rabbit/hostpermission.png" alt><br><img src="/2019/08/25/spring-boot-rabbit/view.png" alt><br><img src="/2019/08/25/spring-boot-rabbit/view2.png" alt></p>
<h2 id="简单队列"><a href="#简单队列" class="headerlink" title="简单队列"></a>简单队列</h2><p>创建一个简单的springboot服务，向消息对类中发送一段消息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//在build.gralde中加入依赖</span><br><span class="line">//amqp-client</span><br><span class="line">compile group: &apos;com.rabbitmq&apos;, name: &apos;amqp-client&apos;, version: &apos;3.4.1&apos;</span><br><span class="line"></span><br><span class="line">//创建连接RabbitMQ</span><br><span class="line">public class ConnectionUtil &#123;</span><br><span class="line">    public static Connection getConnection() throws Exception &#123;</span><br><span class="line">        //定义连接工厂</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        //设置服务地址</span><br><span class="line">        factory.setHost(&quot;localhost&quot;);</span><br><span class="line">        //端口</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        //设置账号信息，用户名、密码、vhost</span><br><span class="line">        factory.setVirtualHost(&quot;testhost&quot;);</span><br><span class="line">        factory.setUsername(&quot;wxy&quot;);</span><br><span class="line">        factory.setPassword(&quot;wxy&quot;);</span><br><span class="line">        // 通过工程获取连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        return connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编写测试方法发送消息到队列中</span><br><span class="line">public class Send &#123;</span><br><span class="line">    private final static String QUEUE_NAME = &quot;q_test_01&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接以及mq通道</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        // 从连接中创建通道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line"></span><br><span class="line">        // 消息内容</span><br><span class="line">        String message = &quot;Hello World!&quot;;</span><br><span class="line">        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());</span><br><span class="line">        System.out.println(&quot; [x] Sent &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line">        //关闭通道和连接</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编辑测试方法接收消息</span><br><span class="line">public class Recive &#123;</span><br><span class="line">    private final static String QUEUE_NAME = &quot;q_test_01&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接以及mq通道</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        // 从连接中创建通道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        // 声明队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line">        // 定义队列的消费者</span><br><span class="line">        QueueingConsumer consumer = new QueueingConsumer(channel);</span><br><span class="line">        // 监听队列</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, true, consumer);</span><br><span class="line">        // 获取消息</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = new String(delivery.getBody());</span><br><span class="line">            System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行程序后打开rabbitmq的web页面，可以发现页面上如下图所示<br><img src="/2019/08/25/spring-boot-rabbit/simplesend.png" alt></p>
<h2 id="work模式"><a href="#work模式" class="headerlink" title="work模式"></a>work模式</h2><p>编辑消息发送者，队列中发送一百个消息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class WorkSend &#123;</span><br><span class="line">    private final static String QUEUE_NAME = &quot;test_queue_work&quot;;</span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接以及mq通道</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            // 消息内容</span><br><span class="line">            String message = &quot;&quot; + i;</span><br><span class="line">            channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());</span><br><span class="line">            System.out.println(&quot; [x] Sent &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(i * 10);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在编辑两个消费者来接受消息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Recv1 &#123;</span><br><span class="line">    private final static String QUEUE_NAME = &quot;test_queue_work&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        // 获取到连接以及mq通道</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line"></span><br><span class="line">        // 同一时刻服务器只会发一条消息给消费者</span><br><span class="line">        channel.basicQos(0);</span><br><span class="line"></span><br><span class="line">        // 定义队列的消费者</span><br><span class="line">        QueueingConsumer consumer = new QueueingConsumer(channel);</span><br><span class="line">        // 监听队列，false表示手动返回完成状态，true表示自动</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, true, consumer);</span><br><span class="line"></span><br><span class="line">        // 获取消息</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = new String(delivery.getBody());</span><br><span class="line">            System.out.println(&quot; [recv1] Received &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line">            //休眠</span><br><span class="line">            Thread.sleep(10);</span><br><span class="line">            // 返回确认状态，注释掉表示使用自动确认模式</span><br><span class="line">            //channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Recv2 &#123;</span><br><span class="line">    private final static String QUEUE_NAME = &quot;test_queue_work&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        // 获取到连接以及mq通道</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line"></span><br><span class="line">        // 同一时刻服务器只会发一条消息给消费者</span><br><span class="line">        channel.basicQos(0);</span><br><span class="line"></span><br><span class="line">        // 定义队列的消费者</span><br><span class="line">        QueueingConsumer consumer = new QueueingConsumer(channel);</span><br><span class="line">        // 监听队列，false表示手动返回完成状态，true表示自动</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, true, consumer);</span><br><span class="line"></span><br><span class="line">        // 获取消息</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = new String(delivery.getBody());</span><br><span class="line">            System.out.println(&quot; [recv2] Received &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line">            // 休眠1秒</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            //下面这行注释掉表示使用自动确认模式</span><br><span class="line">            //channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试的结果：<br>消费者1和消费者2获取到的消息内容是不同的，同一个消息只能被一个消费者获取。一个是消费奇数号消息，一个是偶数。<br>其实，这样是不合理的，因为消费者1线程停顿的时间短。应该是消费者1要比消费者2获取到的消息多才对。RabbitMQ 默认将消息顺序发送给下一个消费者，这样，每个消费者会得到相同数量的消息。即轮询（round-robin）分发消息。<br>怎样才能做到按照每个消费者的能力分配消息呢？联合使用 Qos 和 Acknowledge 就可以做到。<br>basicQos 方法设置了当前信道最大预获取（prefetch）消息数量为1。消息从队列异步推送给消费者，消费者的 ack 也是异步发送给队列，从队列的视角去看，总是会有一批消息已推送但尚未获得 ack 确认，Qos 的 prefetchCount 参数就是用来限制这批未确认消息数量的。设为1时，队列只有在收到消费者发回的上一条消息 ack 确认后，才会向该消费者发送下一条消息。prefetchCount 的默认值为0，即没有限制，队列会将所有消息尽快发给消费者。<br>两个概念：<br>轮询分发 ：使用任务队列的优点之一就是可以轻易的并行工作。如果我们积压了好多工作，我们可以通过增加工作者（消费者）来解决这一问题，使得系统的伸缩性更加容易。在默认情况下，RabbitMQ将逐个发送消息到在序列中的下一个消费者(而不考虑每个任务的时长等等，且是提前一次性分配，并非一个一个分配)。平均每个消费者获得相同数量的消息。这种方式分发消息机制称为Round-Robin（轮询）<br>公平分发 ：虽然上面的分配法方式也还行，但是有个问题就是：比如：现在有2个消费者，所有的奇数的消息都是繁忙的，而偶数则是轻松的。按照轮询的方式，奇数的任务交给了第一个消费者，所以一直在忙个不停。偶数的任务交给另一个消费者，则立即完成任务，然后闲得不行。而RabbitMQ则是不了解这些的。这是因为当消息进入队列，RabbitMQ就会分派消息。它不看消费者为应答的数目，只是盲目的将消息发给轮询指定的消费者。<br>为了解决这个问题，我们使用basicQos( prefetchCount = 1)方法，来限制RabbitMQ只发不超过1条的消息给同一个消费者。当消息处理完毕后，有了反馈，才会进行第二次发送。还有一点需要注意，使用公平分发，必须关闭自动应答，改为手动应答。<br>设置,只需要改动三个地方<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 同一时刻服务器只会发一条消息给消费者,默认是0，就算轮询的模式</span><br><span class="line">channel.basicQos(1);</span><br><span class="line">// 监听队列，false表示手动返回完成状态，true表示自动确认	</span><br><span class="line">//只要消息从队列中获取，无论消费者获取到消息后是否成功消息，都认为是消息已经成功消费。</span><br><span class="line">channel.basicConsume(QUEUE_NAME, false, consumer);</span><br><span class="line">//开启手动确认</span><br><span class="line">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);</span><br></pre></td></tr></table></figure></p>
<h2 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h2><p>创建消息生产这，并把消息把固定到交换机上,直接放代码吧<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Send &#123;</span><br><span class="line">    private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接以及mq通道</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明exchange</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);</span><br><span class="line"></span><br><span class="line">        // 消息内容</span><br><span class="line">        String message = &quot;Hello World!&quot;;</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes());</span><br><span class="line">        System.out.println(&quot; [x] Sent &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候再创建两个消息队列，且都绑定在交换机上,如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Recv1 &#123;</span><br><span class="line">    private final static String QUEUE_NAME = &quot;test_queue_work1&quot;; //另一个Recv2写成test_queue_work2</span><br><span class="line">    private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;;</span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接以及mq通道</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        // 声明队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line">        // 绑定队列到交换机</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);</span><br><span class="line">        // 同一时刻服务器只会发一条消息给消费者</span><br><span class="line">        channel.basicQos(1);</span><br><span class="line">        // 定义队列的消费者</span><br><span class="line">        QueueingConsumer consumer = new QueueingConsumer(channel);</span><br><span class="line">        // 监听队列，手动返回完成</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, false, consumer);</span><br><span class="line">        // 获取消息</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = new String(delivery.getBody());</span><br><span class="line">            System.out.println(&quot; [Recv1] Received &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line">            Thread.sleep(10);</span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候启动sender和Recv1、Recv2,就能看见两个消息队列的监听同时打印出 “hello world!”</p>
<h2 id="主题模式（匹配符模式）"><a href="#主题模式（匹配符模式）" class="headerlink" title="主题模式（匹配符模式）"></a>主题模式（匹配符模式）</h2><p>匹配符模式与订阅模式基本相同，只是再发送消息和接收消息添加了routeKey得规则<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Sender &#123;</span><br><span class="line">    public static final String EXCHANGE_NAME = &quot;test_exchange_topic&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        //获取连接通道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        //生命交换机名称  和  类型</span><br><span class="line">        channel.exchangeDeclare( EXCHANGE_NAME,&quot;topic&quot; );</span><br><span class="line"></span><br><span class="line">        String message = &quot;hello rabbitmq topic theme&quot;;</span><br><span class="line">        channel.basicPublish( EXCHANGE_NAME,&quot;routeKey.1&quot;,null,message.getBytes());</span><br><span class="line">        System.out.println(&quot; topic sender send :[&quot;+message+&quot;]&quot;);</span><br><span class="line">        //关闭通道和连接</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Recv1 &#123;</span><br><span class="line">    private final static String QUEUE_NAME = &quot;test_queue_topic_work_1&quot;;</span><br><span class="line"></span><br><span class="line">    private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        // 获取到连接以及mq通道</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line"></span><br><span class="line">        // 绑定队列到交换机</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;routeKey.*&quot;);</span><br><span class="line"></span><br><span class="line">        // 同一时刻服务器只会发一条消息给消费者</span><br><span class="line">        channel.basicQos(1);</span><br><span class="line"></span><br><span class="line">        // 定义队列的消费者</span><br><span class="line">        QueueingConsumer consumer = new QueueingConsumer(channel);</span><br><span class="line">        // 监听队列，手动返回完成</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, false, consumer);</span><br><span class="line"></span><br><span class="line">        // 获取消息</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = new String(delivery.getBody());</span><br><span class="line">            System.out.println(&quot; [topic Receiver 1] Received &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line">            Thread.sleep(10);</span><br><span class="line"></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Recv2 &#123;</span><br><span class="line">    private final static String QUEUE_NAME = &quot;test_queue_topic_work_2&quot;;</span><br><span class="line"></span><br><span class="line">    private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        // 获取到连接以及mq通道</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line"></span><br><span class="line">        // 绑定队列到交换机</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;*.*&quot;);</span><br><span class="line"></span><br><span class="line">        // 同一时刻服务器只会发一条消息给消费者</span><br><span class="line">        channel.basicQos(1);</span><br><span class="line"></span><br><span class="line">        // 定义队列的消费者</span><br><span class="line">        QueueingConsumer consumer = new QueueingConsumer(channel);</span><br><span class="line">        // 监听队列，手动返回完成</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, false, consumer);</span><br><span class="line"></span><br><span class="line">        // 获取消息</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = new String(delivery.getBody());</span><br><span class="line">            System.out.println(&quot; [topic Receiver 2] Received &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line">            Thread.sleep(10);</span><br><span class="line"></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, “routeKey.<em>“);表示得过滤规则，满足 routeKey.</em>得key得队列才会接收到，#表示得是一个或多个字符，而*表示得是一个字符</p>
<h1 id="spring-boot-使用rabbitmq"><a href="#spring-boot-使用rabbitmq" class="headerlink" title="spring boot 使用rabbitmq"></a>spring boot 使用rabbitmq</h1><p>新建一个spring boot项目，引入依赖包和配置端口和上面一样<br>创建redis的配置文件，这里直接贴上代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class TopicRabbitConfig &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 简单模式下的消息队列配置，默认是按劳分配得队列获取</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue helloQueue() &#123;</span><br><span class="line">        return new Queue( &quot;hello&quot; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//---------------------分割线   主题模式--------------------------------//</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 定义两个消息队列</span><br><span class="line">     */</span><br><span class="line">    private final static String message = &quot;q_topic_message&quot;;</span><br><span class="line">    private final static String messages = &quot;q_topic_messages&quot;;</span><br><span class="line">    private final static String exchange = &quot;topic_exchange&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue queueMessage() &#123;</span><br><span class="line">        return new Queue( TopicRabbitConfig.message );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue queueMessages() &#123;</span><br><span class="line">        return new Queue( TopicRabbitConfig.messages );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 声明一个Topic类型的交换机</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    TopicExchange exchange() &#123;</span><br><span class="line">        return new TopicExchange( exchange );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * queueMessage绑定到交换机上，并设置匹配得规则</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeMessage(Queue queueMessage,TopicExchange exchange) &#123;</span><br><span class="line">        return BindingBuilder.bind( queueMessage ).to( exchange ).with( &quot;topic.message&quot; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * queueMessage绑定到交换机上，并设置匹配得规则</span><br><span class="line">     * - 是匹配一个或多个词   *只匹配一个</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeMessages(Queue queueMessages,TopicExchange exchange) &#123;</span><br><span class="line">        return BindingBuilder.bind( queueMessages ).to( exchange ).with( &quot;topic.-&quot; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //------------------------分割线     订阅模式----------------------------------//</span><br><span class="line"></span><br><span class="line">    //订阅模式下得配置与主题模式基本相同，区别是不添加匹配规则</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue aMessage() &#123;</span><br><span class="line">        return new Queue( &quot;q_fanout_A&quot; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue bMessage() &#123;</span><br><span class="line">        return new Queue( &quot;q_fanout_B&quot; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue cMessage() &#123;</span><br><span class="line">        return new Queue( &quot;q_fanout_C&quot; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 定义交换机</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    FanoutExchange fanoutExchange() &#123;</span><br><span class="line">        return new FanoutExchange( &quot;fanout_exchange&quot; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将交换机和队列绑定</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeA(Queue aMessage,FanoutExchange fanoutExchange) &#123;</span><br><span class="line">        return BindingBuilder.bind( aMessage ).to( fanoutExchange );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeB(Queue bMessage,FanoutExchange fanoutExchange) &#123;</span><br><span class="line">        return BindingBuilder.bind( bMessage ).to( fanoutExchange );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeC(Queue cMessage,FanoutExchange fanoutExchange) &#123;</span><br><span class="line">        return BindingBuilder.bind( cMessage ).to( fanoutExchange );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面创建不同的类型的消息发送和消息接收者<br>消费者默认按劳分配，不是平均分配,主要的模式配置其实都在配置类中完成。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Sender &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    public void send() &#123;</span><br><span class="line">        String context = &quot;hello &quot; + new Date();</span><br><span class="line">        System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">        // 设置  routeKey,简单模式下，这个就是队列名</span><br><span class="line">        this.rabbitTemplate.convertAndSend(&quot;hello&quot;, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Component</span><br><span class="line">@RabbitListener(queues = &quot;hello&quot;)</span><br><span class="line">public class Receiver1 &#123;</span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public void process(String hello) &#123;</span><br><span class="line">        System.out.println(&quot;Receiver : &quot; + hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>rabbit</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot log4j记录日志</title>
    <url>/2019/08/22/spring-boot-log4j%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="spring-boot-集成日志"><a href="#spring-boot-集成日志" class="headerlink" title="spring boot 集成日志"></a>spring boot 集成日志</h1><p>spring boot 框架本身依赖 spring-boot-starter 中包含的就有logback,如果我们引入log4j或则log4j2的时候，为了必变jar报冲突，需要排除该包的依赖<br>我是用的是grdle构建的项目，如下配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	dependencies&#123;</span><br><span class="line">	//其他的省略</span><br><span class="line">	compile group: &apos;org.springframework.boot&apos;, name: &apos;spring-boot-starter-log4j&apos;, version: &apos;1.3.8.RELEASE&apos;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	configurations &#123;</span><br><span class="line">        all*.exclude group: &apos;org.springframework.boot&apos;, module: &apos;spring-boot-starter-logging&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在resource目录下创建log4j.properties文件,按需求配置log的输出路径和级别，这里不介绍太多<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># LOG4J配置,控制台的输出 、</span><br><span class="line"># 日志输出级别 info, appender为控制台输出stdout</span><br><span class="line">#log4j.rootCategory=INFO, stdout</span><br><span class="line"># 控制台输出</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; %5p %c&#123;1&#125;:%L - %m%n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#输出到文件里面</span><br><span class="line">log4j.rootCategory=INFO, stdout, file</span><br><span class="line"># root日志输出</span><br><span class="line">log4j.appender.file=org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">#默认的路径是在根目录下 + logs/all.log ,启动时会自动创建目录和文件，在linux下还未测试</span><br><span class="line">log4j.appender.file.file=logs/all.log</span><br><span class="line">log4j.appender.file.DatePattern=&apos;.&apos;yyyy-MM-dd</span><br><span class="line">log4j.appender.file.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; %5p %c&#123;1&#125;:%L - %m%n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># com.cloud.controller包下的日志配置</span><br><span class="line">log4j.category.com.cloud.controller=DEBUG, controller</span><br><span class="line"># com.cloud.controller下的日志输出</span><br><span class="line">log4j.appender.controller=org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">log4j.appender.controller.file=logs/my.log</span><br><span class="line">log4j.appender.controller.DatePattern=&apos;.&apos;yyyy-MM-dd</span><br><span class="line">log4j.appender.controller.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.controller.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; %5p %c&#123;1&#125;:%L ---- %m%n</span><br></pre></td></tr></table></figure></p>
<p>此时启动项目，控制台会打印出日志信息，并在设置下的日志文件路径创建日志文件，记录日志信息。</p>
<h1 id="使用AOP记录请求到日志中"><a href="#使用AOP记录请求到日志中" class="headerlink" title="使用AOP记录请求到日志中"></a>使用AOP记录请求到日志中</h1><p>AOP是Spring框架中的一个重要内容，是对既有的一个程序定义切入点，在切入的前后执行不同的内容。在项目中引入AOP的依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// aop切面 @Aspect</span><br><span class="line">       compile group: &apos;org.springframework.boot&apos;, name: &apos;spring-boot-starter-aop&apos;, version: &apos;2.1.6.RELEASE&apos;</span><br></pre></td></tr></table></figure></p>
<p>在完成了引入AOP依赖包后，不需要去做其他配置。不需要在程序主类中增加@EnableAspectJAutoProxy来启用，默认就是已启用。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实现AOP的切面主要有以下几个注解：</span><br><span class="line">使用@Aspect注解将一个java类定义为切面类</span><br><span class="line">使用@Pointcut定义一个切入点，可以是一个规则表达式，比如下例中某个package下的所有函数，也可以是一个注解等。</span><br><span class="line">根据需要在切入点不同位置的切入内容</span><br><span class="line">使用@Before在切入点开始处切入内容</span><br><span class="line">使用@After在切入点结尾处切入内容</span><br><span class="line">使用@AfterReturning在切入点return内容之后切入内容（可以用来对处理返回值做一些加工处理）</span><br><span class="line">使用@Around在切入点前后切入内容，并自己控制何时执行切入点自身的内容</span><br><span class="line">使用@AfterThrowing用来处理当切入内容部分抛出异常之后的处理逻辑</span><br><span class="line">使用@Order(i)注解来标识切面的优先级。i的值越小，优先级越高</span><br><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class WebLogAspect &#123;</span><br><span class="line"></span><br><span class="line">    private Logger logger = Logger.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">   @Pointcut(&quot;execution(public * com.cloud.controller..*.*(..))&quot;)</span><br><span class="line">    public void webLog()&#123;&#125;</span><br><span class="line"></span><br><span class="line">       @Before(&quot;webLog()&quot;)</span><br><span class="line">    public void doBefore(JoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        // 接收到请求，记录请求内容</span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line"></span><br><span class="line">        // 记录下请求内容</span><br><span class="line">        logger.info(&quot;URL : &quot; + request.getRequestURL().toString());</span><br><span class="line">        logger.info(&quot;HTTP_METHOD : &quot; + request.getMethod());</span><br><span class="line">        logger.info(&quot;IP : &quot; + request.getRemoteAddr());</span><br><span class="line">        logger.info(&quot;CLASS_METHOD : &quot; + joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName());</span><br><span class="line">        logger.info(&quot;ARGS : &quot; + Arrays.toString(joinPoint.getArgs()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;webLog()&quot;)</span><br><span class="line">    public void doAfterReturning(Object ret) throws Throwable &#123;</span><br><span class="line">        // 处理完请求，返回内容</span><br><span class="line">        logger.info(&quot;RESPONSE : &quot; + ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候启动服务，并调用controller下的服务，就会在日志中记录请求和返回的信息（实际中项目记录我们是保存在数据库的）</p>
<h1 id="日志记录存放到mongodb"><a href="#日志记录存放到mongodb" class="headerlink" title="日志记录存放到mongodb"></a>日志记录存放到mongodb</h1><p>添加mongodb的驱动依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// mongodb-driver，使用切面蒋日志文件写入Mongodb</span><br><span class="line">     compile group: &apos;org.mongodb&apos;, name: &apos;mongodb-driver&apos;, version: &apos;3.10.2&apos;</span><br></pre></td></tr></table></figure></p>
<p>创建写入的实现类<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MongoAppender extends AppenderSkeleton &#123;</span><br><span class="line">    private MongoClient mongoClient;</span><br><span class="line">    private MongoDatabase mongoDatabase;</span><br><span class="line">    private MongoCollection&lt;BasicDBObject&gt; logsCollection;</span><br><span class="line"></span><br><span class="line">    private  String connectionUrl ;</span><br><span class="line">    private  String databaseName;</span><br><span class="line">    private  String collectionName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void append(LoggingEvent loggingEvent) &#123;</span><br><span class="line">        if(mongoDatabase == null) &#123;</span><br><span class="line">            MongoClientURI connectionString = new MongoClientURI(connectionUrl);</span><br><span class="line">            mongoClient = new MongoClient(connectionString);</span><br><span class="line">            mongoDatabase = mongoClient.getDatabase(databaseName);</span><br><span class="line">            logsCollection = mongoDatabase.getCollection(collectionName, BasicDBObject.class);</span><br><span class="line">        &#125;</span><br><span class="line">        logsCollection.insertOne((BasicDBObject) loggingEvent.getMessage());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        if(mongoClient != null) &#123;</span><br><span class="line">            mongoClient.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean requiresLayout() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>修改存放到mongodb的数据类型为BasicDBObject<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Order(1)</span><br><span class="line">@Component</span><br><span class="line">public class WebLogAspect &#123;</span><br><span class="line">    private Logger logger = Logger.getLogger(&quot;mongodb&quot;);</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;execution(public * com.cloud.controller..*.*(..))&quot;)</span><br><span class="line">    public void webLog()&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Before(&quot;webLog()&quot;)</span><br><span class="line">    public void doBefore(JoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        // 获取HttpServletRequest</span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line">        // 获取要记录的日志内容</span><br><span class="line">        BasicDBObject logInfo = getBasicDBObject(request, joinPoint);</span><br><span class="line">        logger.info(logInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private BasicDBObject getBasicDBObject(HttpServletRequest request, JoinPoint joinPoint) &#123;</span><br><span class="line">        // 基本信息</span><br><span class="line">        BasicDBObject r = new BasicDBObject();</span><br><span class="line">        r.append(&quot;requestURL&quot;, request.getRequestURL().toString());</span><br><span class="line">        r.append(&quot;requestURI&quot;, request.getRequestURI());</span><br><span class="line">        r.append(&quot;queryString&quot;, request.getQueryString());</span><br><span class="line">        r.append(&quot;remoteAddr&quot;, request.getRemoteAddr());</span><br><span class="line">        r.append(&quot;remoteHost&quot;, request.getRemoteHost());</span><br><span class="line">        r.append(&quot;remotePort&quot;, request.getRemotePort());</span><br><span class="line">        r.append(&quot;localAddr&quot;, request.getLocalAddr());</span><br><span class="line">        r.append(&quot;localName&quot;, request.getLocalName());</span><br><span class="line">        r.append(&quot;method&quot;, request.getMethod());</span><br><span class="line">        r.append(&quot;headers&quot;, getHeadersInfo(request));</span><br><span class="line">        r.append(&quot;parameters&quot;, request.getParameterMap());</span><br><span class="line">        r.append(&quot;classMethod&quot;, joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName());</span><br><span class="line">        r.append(&quot;args&quot;, Arrays.toString(joinPoint.getArgs()));</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, String&gt; getHeadersInfo(HttpServletRequest request) &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        Enumeration headerNames = request.getHeaderNames();</span><br><span class="line">        while (headerNames.hasMoreElements()) &#123;</span><br><span class="line">            String key = (String) headerNames.nextElement();</span><br><span class="line">            String value = request.getHeader(key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在 log4j.properties配置mongodb的参数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mongodb输出</span><br><span class="line">log4j.logger.mongodb=INFO, mongodb</span><br><span class="line">#写入的实现类全路径</span><br><span class="line">log4j.appender.mongodb=com.cloud.config.MongoAppender</span><br><span class="line">#路径</span><br><span class="line">log4j.appender.mongodb.connectionUrl=mongodb://47.102.99.95:27017</span><br><span class="line">#数据库名称</span><br><span class="line">log4j.appender.mongodb.databaseName=cloud</span><br><span class="line">#mongodb中集合名称</span><br><span class="line">log4j.appender.mongodb.collectionName=logs_request</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>log4j</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot 创建定时任务</title>
    <url>/2019/08/19/spring-boot-%E5%88%9B%E5%BB%BA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="使用注解-Scheduled创建定时任务"><a href="#使用注解-Scheduled创建定时任务" class="headerlink" title="使用注解@Scheduled创建定时任务"></a>使用注解@Scheduled创建定时任务</h1><p>@Scheduled默认创建的线程是单线程，任务的执行会受到上一个任务的影响，创建定时任务也比较简单<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Configuration      //1.主要用于标记配置类，兼备Component的效果。</span><br><span class="line">@EnableScheduling   // 2.开启定时任务</span><br><span class="line">public class ScheduledTask &#123;</span><br><span class="line">    //3.添加定时任务</span><br><span class="line">    @Scheduled(cron = &quot;0/5 * * * * ?&quot;)</span><br><span class="line">    //或直接指定时间间隔，例如：5秒</span><br><span class="line">    //@Scheduled(fixedRate=5000)</span><br><span class="line">    private void configureTasks() &#123;</span><br><span class="line">        System.err.println(&quot;执行静态定时任务时间: &quot; + LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Cron的表达式为 秒（0-59） 分（0~59）时（0~23）日（0~31）的某天，需计算月（0~11）周几（ 可填1-7 或 SUN/MON/TUE/WED/THU/FRI/SAT）<br>“0/5 <em> </em> <em> </em> ?”可以解析成 每5秒执行一次，其他不指定，此时开启application,控制台没隔5秒打印一次</p>
<h1 id="基于接口的定时任务"><a href="#基于接口的定时任务" class="headerlink" title="基于接口的定时任务"></a>基于接口的定时任务</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Configuration      //1.主要用于标记配置类，兼备Component的效果。</span><br><span class="line">@EnableScheduling   // 2.开启定时任务</span><br><span class="line">public class DynamicScheduleTask implements SchedulingConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123;</span><br><span class="line">        taskRegistrar.addTriggerTask(</span><br><span class="line">                //1.添加任务内容(Runnable),匿名</span><br><span class="line">                () -&gt; System.out.println(&quot;执行动态定时任务: &quot; + LocalDateTime.now().toLocalTime()),</span><br><span class="line">                //2.设置执行周期(Trigger)</span><br><span class="line">                triggerContext -&gt; &#123;</span><br><span class="line">                    return new CronTrigger(&quot;0/5 * * * * ?&quot;).nextExecutionTime(triggerContext);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多线程的定时任务"><a href="#多线程的定时任务" class="headerlink" title="多线程的定时任务"></a>多线程的定时任务</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@EnableScheduling   // 1.开启定时任务</span><br><span class="line">@EnableAsync        // 2.开启多线程</span><br><span class="line">public class MultiThreadScheduleTask &#123;</span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    @Scheduled(fixedDelay = 1000)  //间隔1秒</span><br><span class="line">    public void first() throws InterruptedException &#123;</span><br><span class="line">        System.out.println(&quot;第一个定时任务开始 : &quot; + LocalDateTime.now().toLocalTime() + &quot;\r\n线程 : &quot; + Thread.currentThread().getName());</span><br><span class="line">        System.out.println();</span><br><span class="line">        Thread.sleep(1000 * 10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    @Scheduled(fixedDelay = 2000)</span><br><span class="line">    public void second() &#123;</span><br><span class="line">        System.out.println(&quot;第二个定时任务开始 : &quot; + LocalDateTime.now().toLocalTime() + &quot;\r\n线程 : &quot; + Thread.currentThread().getName());</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个定时任务随着时间的增加不断的增加线程，这肯定会消耗大量的资源，因此在配置多线程的定时任务时，常常需要设置一个线程池来避免资源消耗过多<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableAsync</span><br><span class="line">@Configuration</span><br><span class="line">public class TaskPoolConfig &#123;</span><br><span class="line">    @Bean(&quot;taskExecutor&quot;)</span><br><span class="line">    public Executor taskExecutor() &#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(10);</span><br><span class="line">        executor.setMaxPoolSize(20);</span><br><span class="line">        executor.setQueueCapacity(200);</span><br><span class="line">        executor.setKeepAliveSeconds(60);</span><br><span class="line">        executor.setThreadNamePrefix(&quot;taskExecutor-&quot;);</span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(true);//设置线程在任务执行完之后才x释放</span><br><span class="line">        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        return executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用Future来获取Runable的执行结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class Task &#123;</span><br><span class="line">    public static Random random = new Random();</span><br><span class="line">    @Async(&quot;taskExecutor&quot;)</span><br><span class="line">    public Future&lt;String&gt; run() throws Exception &#123;</span><br><span class="line">        long sleep = random.nextInt(10000);</span><br><span class="line">        log.info(&quot;开始任务，需耗时：&quot; + sleep + &quot;毫秒&quot;);</span><br><span class="line">        Thread.sleep(sleep);</span><br><span class="line">        log.info(&quot;完成任务&quot;);</span><br><span class="line">        return new AsyncResult&lt;&gt;(&quot;test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义超时时间并释放线程<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class ApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Task task;</span><br><span class="line">    @Test</span><br><span class="line">    public void test() throws Exception &#123;</span><br><span class="line">        Future&lt;String&gt; futureResult = task.run();</span><br><span class="line">        String result = futureResult.get(5, TimeUnit.SECONDS);</span><br><span class="line">        log.info(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>schedule</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot flyway管理数据库版本</title>
    <url>/2019/08/18/spring-boot-flyway%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="使用flyway管理数据库版本"><a href="#使用flyway管理数据库版本" class="headerlink" title="使用flyway管理数据库版本"></a>使用flyway管理数据库版本</h1><p>Flyway是一个简单开源数据库版本控制器（约定大于配置），主要提供migrate、clean、info、validate、baseline、repair等命令。它支持SQL（PL/SQL、T-SQL）方式和Java方式，支持命令行客户端等，还提供一系列的插件支持（Maven、Gradle、SBT、ANT等）。<br>更多用法详情，flyway的官方网站：<a href="https://flywaydb.org/，" target="_blank" rel="noopener">https://flywaydb.org/，</a><br>因为我们项目是用的flyway来管理数据库版本的，这样子每次更新数据库设计的时候就能对比出表之间的变化，然后我也研究了下spring boot 和flyway的用法。我创建用的项目是gradle的多模块。如果你使用的是maven也可以当作参考<br>第一步当然是引入fayway的依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// flyway</span><br><span class="line">compile group: &apos;org.flywaydb&apos;, name: &apos;flyway-core&apos;, version: &apos;4.1.2</span><br></pre></td></tr></table></figure></p>
<p>flyway的默认读取路径是resource的 db/migration,若果你的路径不一样，那就要在application.properties中写入 flyway.locations指明你的文件路径,在db/migration文件内创建文件 V1__Base_version.sql<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS user ;</span><br><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;,</span><br><span class="line">  `name` varchar(20) NOT NULL COMMENT &apos;姓名&apos;,</span><br><span class="line">  `age` int(5) DEFAULT NULL COMMENT &apos;年龄&apos;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure></p>
<p>这个时候启动Application就能发现数据库中自动创建了实体表，如果你的数据中已经存在了表，只要加上flyway.baselineOnMigrate=true加上这句就阔以喽。<br>下面是flyway的一些常用配置，可以根据具体使用配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 设定 flyway 属性</span><br><span class="line">flyway.enabled = true</span><br><span class="line"># 启用或禁用 flyway</span><br><span class="line">flyway.locations =classpath:/db.migration</span><br><span class="line"># 设定 SQL 脚本的目录,多个路径使用逗号分隔, 比如取值为 classpath:db/migration,filesystem:/sql-migrations</span><br><span class="line">flyway.baselineOnMigrate=true</span><br><span class="line"># 如果指定 schema 包含了其他表,但没有 flyway schema history 表的话, 在执行 flyway migrate 命令之前, 必须先执行 flyway baseline 命令.</span><br><span class="line"># 设置 spring.flyway.baseline-on-migrate 为 true 后, flyway 将在需要 baseline 的时候, 自动执行一次 baseline.</span><br><span class="line">flyway.baselineVersion=1</span><br><span class="line"># 指定 baseline 的版本号,缺省值为 1, 低于该版本号的 SQL 文件, migrate 的时候被忽略.</span><br><span class="line">#spring.flyway.encoding=</span><br><span class="line"># Encoding of SQL migrations (default: UTF-8)</span><br><span class="line">flyway.table=flyway_schema_history_myapp</span><br><span class="line"># 设定 flyway 的 metadata 表名, 缺省为 flyway_schema_history</span><br><span class="line">flyway.outOfOrder=true</span><br><span class="line"># 开发环境最好开启 outOfOrder, 生产环境关闭 outOfOrder .</span><br><span class="line">#spring.flyway.schemas=</span><br><span class="line">需要 flyway 管控的 schema list, 缺省的话, 使用的时 dbsource.connection直连上的那个 schema, 可以指定多个schema, 但仅会在第一个schema下建立 metadata 表, 也仅在第一个schema应用migration sql 脚本. 但flyway Clean 命令会依次在这些schema下都执行一遍.</span><br></pre></td></tr></table></figure></p>
<h1 id="第二种使用flyway的方法"><a href="#第二种使用flyway的方法" class="headerlink" title="第二种使用flyway的方法"></a>第二种使用flyway的方法</h1><p>项目结构如下图<br><img src="/2019/08/18/spring-boot-flyway管理数据库版本/struct.png" alt><br>flyway在gradle中的使用。官方文档中有实例，这里我贴出我的代码,首先flyway的依赖和上面相同，然后再再根目录下创建gradle.properties文件，再里面配置数据源信息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//gradle.properties内</span><br><span class="line"># ####################### flyway ##############################</span><br><span class="line">flyway_driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">flyway_url=jdbc:mysql://localhost:3306/weixy?useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">flyway_user=root</span><br><span class="line">flyway_password=123456</span><br></pre></td></tr></table></figure></p>
<p>然后在entity的模块的build中添加<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: &apos;org.springframework.boot&apos;</span><br><span class="line">apply plugin: &apos;org.flywaydb.flyway&apos;</span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        //使用的仓库优先级</span><br><span class="line">        mavenLocal()</span><br><span class="line">        maven &#123; url &quot;http://maven.aliyun.com/nexus/content/groups/public&quot; &#125;</span><br><span class="line">        maven &#123; url &quot;http://repo.spring.io/snapshot&quot; &#125;</span><br><span class="line">        maven &#123; url &quot;http://repo.spring.io/milestone&quot; &#125;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(group: &apos;org.flywaydb&apos;, name: &apos;flyway-gradle-plugin&apos;, version: &quot;4.1.2&quot;)</span><br><span class="line">        classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:1.4.5.RELEASE&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">flyway&#123;</span><br><span class="line">    driver = &quot;$&#123;flyway_driver&#125;&quot;</span><br><span class="line">    url = &quot;$flyway_url&quot;</span><br><span class="line">    user = &quot;$flyway_user&quot;</span><br><span class="line">    password = &quot;$flyway_password&quot;</span><br><span class="line">    //flyway发布版本记录的表名称</span><br><span class="line">    table = &apos;flyway_version&apos;</span><br><span class="line">    locations =&apos;db/migration&apos;</span><br><span class="line">//    locations = &apos;db/migrations&apos;</span><br><span class="line">    baselineOnMigrate=true</span><br><span class="line">    //</span><br><span class="line">    //sqlMigrationPrefix = &apos;V&apos;</span><br><span class="line">    // 禁止flywayClean，在生产环境中非常重要</span><br><span class="line">    cleanDisabled = false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候刷新gradle ,点击flyway下的<br><img src="/2019/08/18/spring-boot-flyway管理数据库版本/gradle.png" alt></p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>flyway</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot连接mongodb</title>
    <url>/2019/08/18/spring-boot%E8%BF%9E%E6%8E%A5mongodb/</url>
    <content><![CDATA[<h1 id="linux-centos7-安装mongodb"><a href="#linux-centos7-安装mongodb" class="headerlink" title="linux(centos7)安装mongodb"></a>linux(centos7)安装mongodb</h1><p>我是在linux获取安装包，可以去官网下载对应的安装包。官网地址:<a href="https://www.mongodb.com/download-center?jmp=nav#community" target="_blank" rel="noopener">https://www.mongodb.com/download-center?jmp=nav#community</a><br>我是安装在目录路径为 /usr/local/momgodb 下。<br>首先切换路径<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/local/momgodb</span><br><span class="line">//下载安装包</span><br><span class="line">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.0.tgz</span><br><span class="line">//下载完成之后解压缩</span><br><span class="line">tar zxvf mongodb-linux-x86_64-4.0.0.tgz</span><br><span class="line">//解压后的文件名重命名为（mongodb），这个看你自己的喜好，可以不改</span><br><span class="line">mv mongodb-linux-x86_64-4.0.0 mongodb</span><br><span class="line">//修改环境的配置变量</span><br><span class="line">vim /etc/profile</span><br><span class="line">//先按i进入文本编辑的insert模式，编辑完成后先 esc退出编辑，再:wq保存编辑,编辑类容如下</span><br><span class="line">#Mongodb</span><br><span class="line">export PATH=/usr/local/mongodb/mongodb/bin:$PATH</span><br><span class="line">export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL</span><br><span class="line">//保存完毕后，使配置文件生效</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">//创建数据库目录</span><br><span class="line"> cd /usr/mongodb/mongodb</span><br><span class="line">$ touch mongodb.conf</span><br><span class="line">$ mkdir db</span><br><span class="line">$ mkdir log</span><br><span class="line">$ cd log</span><br><span class="line">$ touch mongodb.log</span><br><span class="line"></span><br><span class="line">//修改mongodb的启动配置</span><br><span class="line">vim /usr/local/mongodb/mongodb/mongodb.conf</span><br><span class="line">//再配置文件中添加一下内容</span><br><span class="line">port=27017 #端口</span><br><span class="line">dbpath= /usr/local/mongodb/mongodb/db #数据库存文件存放目录</span><br><span class="line">logpath= /usr/local/mongodb/mongodb/log/mongodb.log #日志文件存放路径</span><br><span class="line">logappend=true #使用追加的方式写日志</span><br><span class="line">fork=true #以守护进程的方式运行，创建服务器进程</span><br><span class="line">maxConns=100 #最大同时连接数</span><br><span class="line">noauth=true #不启用验证</span><br><span class="line">journal=true #每次写入会记录一条操作日志（通过journal可以重新构造出写入的数据）。</span><br><span class="line">#即使宕机，启动时wiredtiger会先将数据恢复到最近一次的checkpoint点，然后重放后续的journal日志来恢复。</span><br><span class="line">storageEngine=wiredTiger  #存储引擎有mmapv1、wiretiger、mongorocks</span><br><span class="line">bind_ip = 0.0.0.0  #这样就可外部访问了，例如从win10中去连虚拟机中的MongoDB</span><br><span class="line">//上述文件配置完成以后，就可以以这个配置文件来启动mongodb</span><br><span class="line"> mongod --config /usr/local/mongodb/mongodb/mongodb.conf</span><br></pre></td></tr></table></figure></p>
<h2 id="设置mongondb的开启自启动"><a href="#设置mongondb的开启自启动" class="headerlink" title="设置mongondb的开启自启动"></a>设置mongondb的开启自启动</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//切换目录，创建服务的方式开机自启动 </span><br><span class="line">cd /lib/systemd/system</span><br><span class="line">//编辑文件（这个时候会创建这个文件）</span><br><span class="line">vi mongodb.service</span><br><span class="line">//添加一下文件，注意安装的路径不要写错了</span><br><span class="line">	[Unit]  </span><br><span class="line">    Description=mongodb  </span><br><span class="line">    After=network.target remote-fs.target nss-lookup.target  </span><br><span class="line">  </span><br><span class="line">    [Service]  </span><br><span class="line">    Type=forking  </span><br><span class="line">    RuntimeDirectory=mongodb</span><br><span class="line">    RuntimeDirectoryMode=0751</span><br><span class="line">    PIDFile=/var/run/mongodb/mongod.pid</span><br><span class="line">    ExecStart=/usr/local/momgodb/mongodb/bin/mongod --config /usr/local/mongodb/momgodb/mongodb.conf  </span><br><span class="line">    ExecStop=/usr/local/momgodb/mongodb/bin/mongod --shutdown /usr/local/mongodb/momgodb/mongodb.conf  </span><br><span class="line">    PrivateTmp=false  </span><br><span class="line">  </span><br><span class="line">    [Install]  </span><br><span class="line">    WantedBy=multi-user.target</span><br><span class="line">	</span><br><span class="line">/// 设置mongodb.service权限</span><br><span class="line">chmod 754 mongodb.service</span><br><span class="line">#启动服务</span><br><span class="line">systemctl start mongodb.service</span><br><span class="line">#关闭服务</span><br><span class="line">systemctl stop mongodb.service</span><br><span class="line">#开机启动</span><br><span class="line">systemctl enable mongodb.service</span><br><span class="line"></span><br><span class="line">//mongodb.service启动测试,你重启下服务器试试呀~，通过工具连接判断是否生效</span><br></pre></td></tr></table></figure>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//查看mongodb进程</span><br><span class="line">ps aux |grep mongodb</span><br><span class="line">//关闭mongodb服务</span><br><span class="line">sudo kill pid(你查出来的进程pid)</span><br></pre></td></tr></table></figure>
<p>使用mongodb的时候经常需要设置密码和用户，只需要注释调启动配置的noauth = true，再重启之前需要先添加用户信息来进行验证<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//使用admin数据库</span><br><span class="line">use admin</span><br><span class="line">//给admin数据库添加管理员用户名和密码，用户名和密码请自行设置</span><br><span class="line">db.createUser(&#123;user:&quot;admin&quot;,pwd:&quot;123456&quot;,roles:[&quot;root&quot;]&#125;)</span><br><span class="line">//验证是否成功，返回1则代表成功</span><br><span class="line">db.auth(&quot;admin&quot;, &quot;123456&quot;)</span><br><span class="line">//切换到要设置的数据库,以test为例</span><br><span class="line">use test</span><br><span class="line">//为test创建用户,用户名和密码请自行设置。</span><br><span class="line">db.createUser(&#123;user: &quot;test&quot;, pwd: &quot;123456&quot;, roles: [&#123; role: &quot;dbOwner&quot;, db: &quot;test&quot; &#125;]&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这里可以使用可视化连接工具,我使用的是robo 3t，安装方法比较简单，就不赘述喽</p>
<h1 id="spring-boot-连接mongodb是先上传、下载、删除的功能"><a href="#spring-boot-连接mongodb是先上传、下载、删除的功能" class="headerlink" title="spring boot 连接mongodb是先上传、下载、删除的功能"></a>spring boot 连接mongodb是先上传、下载、删除的功能</h1><p>首先引入连接mongodb的依赖  compile group: ‘org.springframework.boot’, name: ‘spring-boot-starter-data-mongodb’, version: ‘2.1.4.RELEASE’,<br>此时mongodb在注入了 MongoTemplate 和GridFsTemplate 。编写测试用例..<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/mongodb&quot;)</span><br><span class="line">public class MongodbController &#123;</span><br><span class="line"></span><br><span class="line">    //简单的Collection存储对象</span><br><span class="line">    @Autowired</span><br><span class="line">    MongoTemplate mongotemplate;</span><br><span class="line"></span><br><span class="line">    // 获得SpringBoot提供的mongodb的GridFS对象</span><br><span class="line">    @Autowired</span><br><span class="line">    private GridFsTemplate gridFsTemplate;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/test&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public OperateResult home() &#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setUsername(&quot;test&quot;);</span><br><span class="line">        user.setPassword(&quot;test&quot;);</span><br><span class="line">        user.setEmail(&quot;test&quot;);</span><br><span class="line">        user.setPhone(&quot;test&quot;);</span><br><span class="line">        user.setQuestion(&quot;test&quot;);</span><br><span class="line">        user.setAnswer(&quot;test&quot;);</span><br><span class="line">        user.setRole(0);</span><br><span class="line">        user.setId(&quot;test&quot;);</span><br><span class="line">        user.setCreateTime(new Date());</span><br><span class="line">        user.setCreateBy(0L);</span><br><span class="line">        user.setLastModifiedTime(new Date());</span><br><span class="line">        user.setLastModifiedBy(&quot;test&quot;);</span><br><span class="line">        mongotemplate.save( user );</span><br><span class="line">        return OperateResult.operationSuccess( &quot;save1&quot; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/fileSave&quot;)</span><br><span class="line">    public OperateResult saveFile(@RequestParam(&quot;file&quot;)MultipartFile file)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String fileName = file.getOriginalFilename();</span><br><span class="line">            // 获得文件输入流</span><br><span class="line">            InputStream ins = file.getInputStream();</span><br><span class="line">            // 获得文件类型</span><br><span class="line">            String contentType = file.getContentType();</span><br><span class="line">            GridFSFile gridFSFile = gridFsTemplate.store(ins, fileName, contentType);</span><br><span class="line">            FileInfo fileInfo = new FileInfo();</span><br><span class="line">            fileInfo.setFileName(&quot;&quot;);</span><br><span class="line">            fileInfo.setFileType(&quot;&quot;);</span><br><span class="line">            fileInfo.setFileId(&quot;&quot;);</span><br><span class="line">            fileInfo.setCreator(&quot;&quot;);</span><br><span class="line">            return OperateResult.operationSuccess( &quot;存文件成功&quot; );</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return OperateResult.operationFailure( e.getMessage() );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/downFile&quot;)</span><br><span class="line">    public void downloadFile(@RequestParam(name = &quot;file_id&quot;) String fileId,HttpServletRequest request,HttpServletResponse response) throws Exception &#123;</span><br><span class="line">        Query query = Query.query( Criteria.where(&quot;_id&quot;).is(fileId));</span><br><span class="line">        GridFSDBFile gfsfile = gridFsTemplate.findOne(query);</span><br><span class="line">        if (gfsfile == null) &#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String fileName = gfsfile.getFilename().replace(&quot;,&quot;, &quot;&quot;);</span><br><span class="line">        //处理中文文件名乱码</span><br><span class="line">        if (request.getHeader(&quot;User-Agent&quot;).toUpperCase().contains(&quot;MSIE&quot;) ||</span><br><span class="line">                request.getHeader(&quot;User-Agent&quot;).toUpperCase().contains(&quot;TRIDENT&quot;)</span><br><span class="line">                || request.getHeader(&quot;User-Agent&quot;).toUpperCase().contains(&quot;EDGE&quot;)) &#123;</span><br><span class="line">            fileName = java.net.URLEncoder.encode(fileName, &quot;UTF-8&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //非IE浏览器的处理：</span><br><span class="line">            fileName = new String(fileName.getBytes(&quot;UTF-8&quot;), &quot;ISO-8859-1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 通知浏览器进行文件下载</span><br><span class="line">        response.setContentType(gfsfile.getContentType());</span><br><span class="line">        response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=\&quot;&quot; + fileName + &quot;\&quot;&quot;);</span><br><span class="line">        gfsfile.writeTo(response.getOutputStream());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/deleteFile&quot;)</span><br><span class="line">    public OperateResult deleteFile(String fileId)&#123;</span><br><span class="line">        Query query = Query.query(Criteria.where(&quot;_id&quot;).is(fileId));</span><br><span class="line">        // 查询单个文件</span><br><span class="line">        GridFSDBFile gfsfile = gridFsTemplate.findOne(query);</span><br><span class="line">        if (gfsfile == null) &#123;</span><br><span class="line">            return OperateResult.operationFailure( &quot;没有找到文件&quot; );</span><br><span class="line">        &#125;</span><br><span class="line">        gridFsTemplate.delete(query);</span><br><span class="line">        return OperateResult.operationSuccess( &quot;删除成功&quot; );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot redis</title>
    <url>/2019/08/10/spring-boot-redis/</url>
    <content><![CDATA[<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;Springboot整合Redis有两种方式，分别是Jedis和RedisTemplate,Jedis是Redis官方推荐的面向Java的操作Redis的客户端，而RedisTemplate是SpringDataRedis中对JedisApi的高度封装。其实在Springboot的官网上我们也能看到，官方现在推荐的是SpringDataRedis形式，相对于Jedis来说可以方便地更换Redis的Java客户端，其比Jedis多了自动管理连接池的特性，方便与其他Spring框架进行搭配使用如：SpringCache。<br>我的spring boot 版本是1.4.5，所以和spring boot 2.x可能会有些不一样</p>
<h1 id="spring-boot-1-x-引入redis连接"><a href="#spring-boot-1-x-引入redis连接" class="headerlink" title="spring boot 1.x 引入redis连接"></a>spring boot 1.x 引入redis连接</h1><p>首先引入redis的依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//redis</span><br><span class="line">      compile group: &apos;org.springframework.data&apos;, name: &apos;spring-data-redis&apos;, version: &apos;1.7.2.RELEASE&apos;</span><br><span class="line">      // jedis</span><br><span class="line">      compile group: &apos;redis.clients&apos;, name: &apos;jedis&apos;, version: &apos;2.9.0&apos;</span><br></pre></td></tr></table></figure></p>
<p>在application.properties中配置redis的设置和链接地址<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># REDIS (RedisProperties)</span><br><span class="line"># Redis数据库索引（默认为0）</span><br><span class="line">spring.redis.database=0</span><br><span class="line"># Redis服务器地址</span><br><span class="line">spring.redis.host=xx.xxx.xx.xx</span><br><span class="line"># Redis服务器连接端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line">#客户端超时时间单位是毫秒 默认是2000</span><br><span class="line">spring.redis.timeout=10000</span><br><span class="line">#最大空闲数</span><br><span class="line">spring.redis.maxIdle=300</span><br><span class="line">#连接池的最大数据库连接数。设为0表示无限制,如果是jedis 2.4以后用redis.maxTotal</span><br><span class="line">#redis.maxActive=600</span><br><span class="line">#控制一个pool可分配多少个jedis实例,用来替换上面的redis.maxActive,如果是jedis 2.4以后用该属性</span><br><span class="line">spring.redis.maxTotal=1000</span><br><span class="line">#最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。</span><br><span class="line">spring.redis.maxWaitMillis=1000</span><br><span class="line">#连接的最小空闲时间 默认1800000毫秒(30分钟)</span><br><span class="line">spring.redis.minEvictableIdleTimeMillis=300000</span><br><span class="line">#每次释放连接的最大数目,默认3</span><br><span class="line">spring.redis.numTestsPerEvictionRun=1024</span><br><span class="line">#逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1</span><br><span class="line">spring.redis.timeBetweenEvictionRunsMillis=30000</span><br><span class="line">#是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个</span><br><span class="line">spring.redis.testOnBorrow=true</span><br><span class="line">#在空闲时检查有效性, 默认false</span><br></pre></td></tr></table></figure></p>
<p>在spring b00t 1.0中，编写简单的测试用例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">	private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">	@Test</span><br><span class="line">	public void test() throws Exception &#123;</span><br><span class="line">		// 保存字符串</span><br><span class="line">		stringRedisTemplate.opsForValue().set(&quot;aaa&quot;, &quot;111&quot;);</span><br><span class="line">		Assert.assertEquas(&quot;111&quot;, stringRedisTemplate.opsForValue().get(&quot;aaa&quot;));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>用redisDesktopManager打开redis就会看见redis中存入了一个key-value的数据<br><img src="/2019/08/10/spring-boot-redis/aaa.png" alt><br>通过上面这段极为简单的测试案例演示了如何通过自动配置的StringRedisTemplate对象进行Redis的读写操作，该对象从命名中就可注意到支持的是String类型。如果有使用过spring-data-redis的开发者一定熟悉RedisTemplate&lt;K, V&gt;接口，StringRedisTemplate就相当于RedisTemplate&lt;String, String&gt;的实现。</p>
<h2 id="redis存放对象RedisTemplate"><a href="#redis存放对象RedisTemplate" class="headerlink" title="redis存放对象RedisTemplate"></a>redis存放对象RedisTemplate</h2><p>除了String类型，实经常会在Redis中存储对象，这时候我们就会想是否可以使用类似RedisTemplate&lt;String, User&gt;来初始化并进行操作。但是Spring Boot并不支持直接使用，需要我们自己实现RedisSerializer<t>接口来对传入对象进行序列化和反序列化<br>所以序列化和反序列化的方法需要我们重写,首先创建一个需要存储的对象，这里我就直接使用User这个对象<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User extends BaseEntity implements Serializable &#123;</span><br><span class="line">    @Column</span><br><span class="line">    private String username;</span><br><span class="line">    @Column</span><br><span class="line">    private String password;</span><br><span class="line">//get set 省略</span><br></pre></td></tr></table></figure></t></p>
<p>这个配置类非必要，如过出现了jedis connect refused，排除了redis 配置的 #bind 127.0.0.1 等配置问题仍然无效, 这个配置可能有用，这个是指定jedis的链接地址和端口，默认的是连接本地的127.0.0.1：6379<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@PropertySource(value = &quot;classpath:/application.properties&quot;)</span><br><span class="line">public class JedisRedisConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.redis.host&#125;&quot;)</span><br><span class="line">    private  String host;</span><br><span class="line">    @Value(&quot;$&#123;spring.redis.password&#125;&quot;)</span><br><span class="line">    private  String password;</span><br><span class="line">    @Value(&quot;$&#123;spring.redis.port&#125;&quot;)</span><br><span class="line">    private  int port;</span><br><span class="line">    @Value(&quot;$&#123;spring.redis.timeout&#125;&quot;)</span><br><span class="line">    private  int timeout;</span><br><span class="line">    @Bean</span><br><span class="line">    JedisConnectionFactory jedisConnectionFactory() &#123;</span><br><span class="line">        JedisConnectionFactory factory = new JedisConnectionFactory();</span><br><span class="line">        factory.setHostName(host);</span><br><span class="line">        factory.setPort(port);</span><br><span class="line">        factory.setTimeout(timeout); //设置连接超时时间</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自定义redis的对象序列化和反序列化方法RedisObjectSerializer<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RedisObjectSerializer implements RedisSerializer&lt;Object&gt; &#123;</span><br><span class="line">    private Converter&lt;Object, byte[]&gt; serializer = new SerializingConverter();</span><br><span class="line">    private Converter&lt;byte[], Object&gt; deserializer = new DeserializingConverter();</span><br><span class="line"></span><br><span class="line">    static final byte[] EMPTY_ARRAY = new byte[0];</span><br><span class="line"></span><br><span class="line">    public Object deserialize(byte[] bytes) &#123;</span><br><span class="line">        if (isEmpty(bytes)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            return deserializer.convert(bytes);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            throw new SerializationException(&quot;Cannot deserialize&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public byte[] serialize(Object object) &#123;</span><br><span class="line">        if (object == null) &#123;</span><br><span class="line">            return EMPTY_ARRAY;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            return serializer.convert(object);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            return EMPTY_ARRAY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isEmpty(byte[] data) &#123;</span><br><span class="line">        return (data == null || data.length == 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后是RedisTemplate实例方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    JedisConnectionFactory jedisConnectionFactory() &#123;</span><br><span class="line">        return new JedisConnectionFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;();</span><br><span class="line">        template.setConnectionFactory(jedisConnectionFactory());</span><br><span class="line">        template.setKeySerializer(new StringRedisSerializer());</span><br><span class="line">        template.setValueSerializer(new RedisObjectSerializer());</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后运行测试用例实现redis的存储，(这里我遇见了一个问题，默认的序列化后对象在redis中是乱码的,因为我们项目中的对象是以JSON的格式存储到redis中的，等我继续研究哦)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired(required = true)</span><br><span class="line">   private RedisTemplate redisTemplate;</span><br><span class="line">   @Test</span><br><span class="line">   public void testSave()&#123;</span><br><span class="line">// 保存对象</span><br><span class="line">       User user = new User();</span><br><span class="line">       user.setUsername(&quot;1&quot;);</span><br><span class="line">       user.setPassword(&quot;2&quot;);</span><br><span class="line">       redisTemplate.opsForValue().set(user.getUsername(), user);</span><br><span class="line">	//获取对象并发现返回的对象结果正确</span><br><span class="line">       Object object = redisTemplate.opsForValue().get( &quot;1&quot; );</span><br><span class="line">       System.out.println(object.toString());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>emmm,我有了一个猥琐的想法，可以使用fastjson将对象转成JSON,在使用stringRedisTemplate将json存放到redis中，想到就试了试<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">   private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"> @Test</span><br><span class="line">   public void testString()&#123;</span><br><span class="line">       User user = new User();</span><br><span class="line">       user.setUsername(&quot;1&quot;);</span><br><span class="line">       user.setPassword(&quot;2&quot;);</span><br><span class="line">       stringRedisTemplate.opsForValue().set( user.getUsername(),user.toString() );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候的确redis内存放的是JSON字符<br><img src="/2019/08/10/spring-boot-redis/bbb.png" alt><br>but…..,然后发现了在redis的序列化的时候其实是可以指定序列化的方式的,所以如果不需要自定义特殊的序列化方式，就直接使用jackson,对了配置文件也只写着一个就行了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">  public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">      RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;();</span><br><span class="line">      template.setConnectionFactory(jedisConnectionFactory());</span><br><span class="line"></span><br><span class="line">      //jackson的序列方式</span><br><span class="line">      Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">      ObjectMapper om = new ObjectMapper();</span><br><span class="line">      om.setVisibility( PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">      om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">      jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">      //string的序列方式</span><br><span class="line">      StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();</span><br><span class="line">      //key值按String的方式</span><br><span class="line">      template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">      //value 以json的方式</span><br><span class="line">      template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">      template.afterPropertiesSet();</span><br><span class="line">      return template;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="spring-boot-1-x-redis-的注解使用"><a href="#spring-boot-1-x-redis-的注解使用" class="headerlink" title="spring boot 1.x  redis 的注解使用"></a>spring boot 1.x  redis 的注解使用</h1><p>spring boot 使用注解的方式开启缓存，首先是配置缓存的配置文件类<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableCaching</span><br><span class="line">public class CacheConfig extends CachingConfigurerSupport &#123;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;rawtypes&quot;)</span><br><span class="line">    @Bean</span><br><span class="line">    public CacheManager cacheManager(RedisTemplate redisTemplate) &#123;</span><br><span class="line">        RedisCacheManager rcm = new RedisCacheManager( redisTemplate );</span><br><span class="line">        // 多个缓存的名称,目前只定义了一个</span><br><span class="line">        rcm.setCacheNames( Arrays.asList( &quot;thisredis&quot; ) );</span><br><span class="line">        //设置缓存过期时间(秒)</span><br><span class="line">        rcm.setDefaultExpiration( 600 );</span><br><span class="line">        return rcm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">        StringRedisTemplate template = new StringRedisTemplate( factory );</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer( Object.class );</span><br><span class="line">        ObjectMapper om = new ObjectMapper();</span><br><span class="line">        om.setVisibility( PropertyAccessor.ALL,JsonAutoDetect.Visibility.ANY );</span><br><span class="line">        om.enableDefaultTyping( ObjectMapper.DefaultTyping.NON_FINAL );</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper( om );</span><br><span class="line">        template.setValueSerializer( jackson2JsonRedisSerializer );</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//这个是因为默认的JedisConnectionFactory是本地的redis,我链接的是我服务器上的配置，所以要手动配置一下</span><br><span class="line">    @Bean</span><br><span class="line">    JedisConnectionFactory jedisConnectionFactory() &#123;</span><br><span class="line">        JedisConnectionFactory factory = new JedisConnectionFactory();</span><br><span class="line">        factory.setHostName(&quot;xx.xxx.xx.xx&quot;);</span><br><span class="line">        factory.setPort(6379);</span><br><span class="line">        factory.setTimeout(0); //设置连接超时时间</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候启动服务就没有问题，接下来就编写缓存的方法还有测试类,这个方法指定了缓存名称，key是自定义的key值，condition 是配置当id不为3的时候将方法放入缓存中。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Cacheable(value = &quot;thisredis&quot;,key=&quot;&apos;users_&apos;+#id&quot;，condition=&quot;#id!=3&quot;)</span><br><span class="line">   public String getUser(int id) &#123;</span><br><span class="line">       System.out.println( &quot;Method executed..&quot; );</span><br><span class="line">       if (id == 1) &#123;</span><br><span class="line">           return &quot;User 1&quot;;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return &quot;User 2&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">@CacheEvict(value=&quot;thisredis&quot;, key=&quot;&apos;users_&apos;+#id&quot;,condition=&quot;#id!=1&quot;)</span><br><span class="line">   @PostMapping(&quot;/delUser&quot;)</span><br><span class="line">   public void delUser(Integer id) &#123;</span><br><span class="line">       // 删除user</span><br><span class="line">	System.out.pringln(&quot;缓存删除&quot;)；</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th style="text-align:left">描述</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>methodName</td>
<td style="text-align:left">当前方法名</td>
<td style="text-align:center">#root.methodName</td>
</tr>
<tr>
<td>targetClass</td>
<td style="text-align:left">当前被调用的对象的class</td>
<td style="text-align:center">#root.targetClass</td>
</tr>
<tr>
<td>caches</td>
<td style="text-align:left">当前被调用的方法使用的Cache</td>
<td style="text-align:center">#root.caches[0].name</td>
</tr>
</tbody>
</table>
<p>编写测试用例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();</span><br><span class="line">       ctx.register( CacheConfig.class );</span><br><span class="line">       ctx.refresh();</span><br><span class="line">       User user = ctx.getBean(User.class);</span><br><span class="line">       System.out.println(user.getUser( 1 ));</span><br><span class="line">       System.out.println(user.getUser( 1 ));</span><br><span class="line">       System.out.println(user.getUser( 2 ));</span><br><span class="line">       ctx.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>在getUser方面里面添加断点，可以发现在第二次调用user.getUser( 1 )时没有进入断点，而在调用user.getUser( 2 )进入了断点，因为在第二次user.getUser( 1) 的时候数据是从缓存中取出的，而调用delUser的时候会删除缓存区中key相同的数据</p>
<p>​    </p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>linux redis 安装</title>
    <url>/2019/08/08/linuz-redis-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#下载文件或者传到centos</span><br><span class="line">wget http://download.redis.io/releases/redis-5.0.3.tar.gz</span><br><span class="line">#解压文件</span><br><span class="line">tar -zxvf redis-5.0.3.tar.gz</span><br><span class="line">#cd切换到redis解压目录下，执行编译</span><br><span class="line">cd redis-5.0.3</span><br><span class="line">#编译</span><br><span class="line">make</span><br><span class="line">#安装并指定安装目录</span><br><span class="line">make install PREFIX=/usr/local/redis</span><br><span class="line">#修改 redis.conf 文件</span><br><span class="line"> vi redis.confno</span><br><span class="line"> //修改内容为daemonize no 改为 daemonize yes</span><br><span class="line"> //		   bind 127.0.0.0 改为bind 0.0.0.0</span><br><span class="line"> //        protected mode yes 改为 no</span><br><span class="line">#指定配置文件启动 </span><br><span class="line">./redis-server redis.conf</span><br><span class="line">#添加开机启动服务</span><br><span class="line">vi /etc/systemd/system/redis.service</span><br><span class="line">//内容为</span><br><span class="line">	[Unit]</span><br><span class="line">	Description=redis-server</span><br><span class="line">	After=network.target</span><br><span class="line">	[Service]</span><br><span class="line">	Type=forking</span><br><span class="line">	ExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/bin/redis.conf</span><br><span class="line">	PrivateTmp=true</span><br><span class="line">	[Install]</span><br><span class="line">	WantedBy=multi-user.target</span><br><span class="line">#设置开机启动</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start redis.service</span><br><span class="line">systemctl enable redis.service</span><br><span class="line">#创建 redis 命令软链接</span><br><span class="line">ln -s /usr/local/redis/bin/redis-cli /usr/bin/redis</span><br><span class="line"></span><br><span class="line">#服务操作命令</span><br><span class="line">systemctl start redis.service   #启动redis服务</span><br><span class="line">systemctl stop redis.service   #停止redis服务</span><br><span class="line">systemctl restart redis.service   #重新启动服务</span><br><span class="line">systemctl status redis.service   #查看服务当前状态</span><br><span class="line">systemctl enable redis.service   #设置开机自启动</span><br><span class="line">systemctl disable redis.service   #停止开机自启动</span><br><span class="line">#其他常用命令</span><br><span class="line">pkill redis  //停止redis</span><br><span class="line">卸载redis：</span><br><span class="line">rm -rf /usr/local/redis //删除安装目录</span><br><span class="line">rm -rf /usr/bin/redis-* //删除所有redis相关命令脚本</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linx</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql解决乱码</title>
    <url>/2019/08/05/mysql%E8%A7%A3%E5%86%B3%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<h1 id="解决数据在MYSQL中文乱码的问题"><a href="#解决数据在MYSQL中文乱码的问题" class="headerlink" title="解决数据在MYSQL中文乱码的问题"></a>解决数据在MYSQL中文乱码的问题</h1><p>@nbsp;@nbsp;@nbsp;@nbsp;最近自己在往阿里云服务器的数据库写数据的时候发现了中文乱码的问题<br>第一反应就编码格式不对，改成了utf还是乱码~~~唉,其实解决并不复杂</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//首先编辑mysql的文件</span><br><span class="line">vi /etc/my.cnf</span><br><span class="line">//在[mysql]下添加</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br><span class="line">//在[client]下添加</span><br><span class="line">default-character-set=utf8</span><br><span class="line">//然后 esc  </span><br><span class="line">//:wq  退出并保存</span><br><span class="line">退出以后重启mysql</span><br><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot xml格式消息转换</title>
    <url>/2019/08/05/spring-boot%E5%9B%9B/</url>
    <content><![CDATA[<h1 id="消息转换器（Message-Converter）"><a href="#消息转换器（Message-Converter）" class="headerlink" title="消息转换器（Message Converter）"></a>消息转换器（Message Converter）</h1><p>在spring boot中出路HTTP请求的实现使用的是spring MVC 。而在Spring MVC中有一个消息转换器这个概念，它主要负责处理各种不同格式的请求数据进行处理，并包转换成对象，以提供更好的编程体验。<br>在Spring MVC中定义了HttpMessageConverter接口，抽象了消息转换器对类型的判断、对读写的判断与操作，具体可见如下定义：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface HttpMessageConverter&lt;T&gt; &#123;</span><br><span class="line">    boolean canRead(Class&lt;?&gt; clazz, @Nullable MediaType mediaType);</span><br><span class="line">    boolean canWrite(Class&lt;?&gt; clazz, @Nullable MediaType mediaType);</span><br><span class="line">    List&lt;MediaType&gt; getSupportedMediaTypes();</span><br><span class="line">    T read(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException;</span><br><span class="line">    void write(T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>HTTP请求的Content-Type有各种不同格式定义，如果要支持Xml格式的消息转换，就必须要使用对应的转换器。Spring MVC中默认已经有一套采用Jackson实现的转换器MappingJackson2XmlHttpMessageConverter。<br>常用的HTTP请求中header传输MediaType 类型，常用的是application/json，application/xml.前后端传输数据常用格式是json,但也有接口之间采用的是XML的方式传输数据<br>传统的Spring应用中，我们可以通过如下配置加入对Xml格式数据的消息转换实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MessageConverterConfig1 extends WebMvcConfigurerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;</span><br><span class="line">        Jackson2ObjectMapperBuilder builder = Jackson2ObjectMapperBuilder.xml();</span><br><span class="line">        builder.indentOutput(true);</span><br><span class="line">        converters.add(new MappingJackson2XmlHttpMessageConverter(builder.build()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而在springboot应用中，只需要加入jackson-dataformat-xml依赖，Spring Boot就会自动引入MappingJackson2XmlHttpMessageConverter的实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile group: &apos;com.fasterxml.jackson.dataformat&apos;, name: &apos;jackson-dataformat-xml&apos;, version: &apos;2.9.8&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="建立实体和XML的转换关系"><a href="#建立实体和XML的转换关系" class="headerlink" title="建立实体和XML的转换关系"></a>建立实体和XML的转换关系</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@JacksonXmlRootElement(localName = &quot;XmlPojo&quot;)</span><br><span class="line">public class XmlPojo &#123;</span><br><span class="line">    @JacksonXmlProperty(localName = &quot;message1&quot;)</span><br><span class="line">    private String message1;</span><br><span class="line">    @JacksonXmlProperty(localName = &quot;message2&quot;)</span><br><span class="line">    private Integer message2;</span><br><span class="line">	//get、set方式省略</span><br></pre></td></tr></table></figure>
<p>这个实体转成XML的对应关系为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;XmlPojo&gt;</span><br><span class="line">    &lt;message1&gt;*&lt;/message1&gt;</span><br><span class="line">    &lt;message2&gt;*&lt;/message2&gt;</span><br><span class="line">&lt;/XmlPojo&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="请求于接收XML格式的数据"><a href="#请求于接收XML格式的数据" class="headerlink" title="请求于接收XML格式的数据"></a>请求于接收XML格式的数据</h2><p>XML格式的消息发送,我使用的是postman工具发起的请求，在header中指定数据类型 Content-Type: application/xml，发送的数据为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;XmlPojo&gt;</span><br><span class="line">    &lt;message1&gt;message1&lt;/message1&gt;</span><br><span class="line">    &lt;message2&gt;2&lt;/message2&gt;</span><br><span class="line">&lt;/XmlPojo&gt;</span><br></pre></td></tr></table></figure></p>
<p>接收参数并返回XML。consumes = MediaType.APPLICATION_XML_VALUE,produces = MediaType.APPLICATION_XML_VALUE<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@PostMapping(value = &quot;/xmlTest2&quot;,consumes = MediaType.APPLICATION_XML_VALUE,</span><br><span class="line">        produces = MediaType.APPLICATION_XML_VALUE)</span><br><span class="line">public XmlPojo xmlTest2(@RequestBody XmlPojo xml)&#123;</span><br><span class="line">    return xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>gradleThree</title>
    <url>/2019/07/28/gradleThree/</url>
    <content><![CDATA[<h1 id="Task任务"><a href="#Task任务" class="headerlink" title="Task任务"></a>Task任务</h1><h2 id="task任务定义"><a href="#task任务定义" class="headerlink" title="task任务定义"></a>task任务定义</h2><p>在gradle文件中定义task的方法有两种，如下。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//直接定义task</span><br><span class="line">task hello1(group: &apos;immoc&apos;,description: &apos;hellostudy&apos;)&#123;</span><br><span class="line">    println &quot;hello1&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//通过TaskContainer 创建task</span><br><span class="line">this.tasks.create(name: &apos;hello2&apos;)&#123;</span><br><span class="line">    setGroup(&apos;immoc&apos;);</span><br><span class="line">    setDescription(&apos;hellostudy&apos;)</span><br><span class="line">    println &quot;hello2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在执行gradle clean时，两个任务都会配置阶段运行。配置task在运行阶段而不是配置阶段,doFirst和doLast，可以监听任务执行的时长，代码如下、<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task test()&#123;&#125;</span><br><span class="line">def startBuildTime ,endBuildTime;</span><br><span class="line">//计算构建的时常</span><br><span class="line">this.afterEvaluate &#123;Project project-&gt;</span><br><span class="line">    //保证配置阶段完成</span><br><span class="line">    def preBuildTask = project.tasks.findByName(&apos;test&apos;)</span><br><span class="line">    preBuildTask.doFirst &#123;</span><br><span class="line">        startBuildTime =System.currentTimeMillis();</span><br><span class="line">        println &quot;start time is $&#123;startBuildTime&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    def buildTask = project.tasks.findByName(&apos;test&apos;)</span><br><span class="line">    buildTask.doLast &#123;</span><br><span class="line">        endBuildTime = System.currentTimeMillis();</span><br><span class="line">        println &quot;end time is $&#123;endBuildTime&#125;&quot;</span><br><span class="line">        println &quot;cost time is $&#123;endBuildTime- startBuildTime&#125;ms&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="task的执行顺序"><a href="#task的执行顺序" class="headerlink" title="task的执行顺序"></a>task的执行顺序</h2><p>task的执行顺序可以分成三种：dependsOn强依赖的方式、通过task输入输出指定、通过API指定顺序<br>强依赖的方式执行顺序,先执行依赖的task<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> task taskX()&#123;doLast &#123; println &quot;task x&quot;&#125;&#125;</span><br><span class="line">task taskY()&#123;doLast &#123; println &quot;task y&quot; &#125;&#125;</span><br><span class="line">task taskZ(dependsOn: [taskX,taskY])&#123;</span><br><span class="line">    doLast &#123;println &quot;task z&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line">另一种指定依赖写法</span><br><span class="line">taskZ.denpendsOn(taskX,taskY)</span><br></pre></td></tr></table></figure></p>
<p>另一种动态的指定执行顺序的方法,调用dependsOn方法动态添加依赖，注意被依赖的方法要定义在需要引用的task之前<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// &lt;&lt;等同于 doLast,不在编译期执行</span><br><span class="line">task lib1 &lt;&lt; &#123;</span><br><span class="line">    println &quot;lib1&quot;</span><br><span class="line">&#125;</span><br><span class="line">task lib2 &lt;&lt; &#123;</span><br><span class="line">    println &quot;lib2&quot;</span><br><span class="line">&#125;</span><br><span class="line">task noLib  &lt;&lt; &#123;</span><br><span class="line">    println &quot;noLib&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task testLib &#123;</span><br><span class="line">//    添加前缀名为lib的依赖</span><br><span class="line">    dependsOn this.tasks.findAll &#123;</span><br><span class="line">        task-&gt;return task.name.startsWith(&apos;lib&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println &apos;test&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="task-的输入和输出"><a href="#task-的输入和输出" class="headerlink" title="task 的输入和输出"></a>task 的输入和输出</h2><p>//TODO </p>
<h2 id="task的指定顺序"><a href="#task的指定顺序" class="headerlink" title="task的指定顺序"></a>task的指定顺序</h2><p>使用mustRunAfter 来指定任务的执行顺序,控制台输入gradle task1 task3 task2，可以发现任务执行顺序是1、2、3<br>如果使用的是shouldRunAfter 执行顺序不是强制性<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task task1&#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println &quot;task1&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task task2&#123;</span><br><span class="line">    mustRunAfter task1</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println &quot;task2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task task3&#123;</span><br><span class="line">    mustRunAfter task2</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println &quot;task3&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="task自定义和配置"><a href="#task自定义和配置" class="headerlink" title="task自定义和配置"></a>task自定义和配置</h2><p>在定义task的时候可以设置task的分组和描述，idea中gradle中的任务就是按分组分类，默认为other下的task<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task helloTask&#123;</span><br><span class="line">    println &quot;helloTask&quot;</span><br><span class="line">&#125;</span><br><span class="line">//通过TaskContainer创建任务</span><br><span class="line">this.tasks.create(name: &apos;helloTask2&apos;)&#123;</span><br><span class="line">	//给任务添加属性</span><br><span class="line">	setGroup(&quot;gradle&quot;)</span><br><span class="line">    setDescription(&quot;helloTask2&quot;)</span><br><span class="line">    println &quot;helloTask2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置资源文件夹</span><br><span class="line">sourceSets&#123;</span><br><span class="line">	main &#123;</span><br><span class="line">		groovy &#123;</span><br><span class="line">			others&#123;</span><br><span class="line">				srcDir &apos;src/main/others&apos;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>java工具</tag>
        <tag>gradle，groovy</tag>
      </tags>
  </entry>
  <entry>
    <title>groovy-learn（三）</title>
    <url>/2019/05/22/groovy-learn%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="groovy的高级操作"><a href="#groovy的高级操作" class="headerlink" title="groovy的高级操作"></a>groovy的高级操作</h1><h2 id="对json的操作"><a href="#对json的操作" class="headerlink" title="对json的操作"></a>对json的操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//列表转换成Json</span><br><span class="line">def list = [new Person(name: &apos;david&apos;,age: 13),new Person(name: &apos;jane&apos;,age: 43)]</span><br><span class="line">println JsonOutput.toJson(list)</span><br><span class="line"></span><br><span class="line">//转换Object</span><br><span class="line">def jsonSlpuer = new JsonSlurper()</span><br><span class="line">//jsonSlpuer.parse()</span><br><span class="line"></span><br><span class="line">//模拟发送请求和数据转换</span><br><span class="line">def getNetworkDate(String url)&#123;</span><br><span class="line">    //发送http请求</span><br><span class="line">    def connection = new URL(url).openConnection()</span><br><span class="line">    connection.setRequestMethod(&quot;GET&quot;)</span><br><span class="line">    connection.connect()</span><br><span class="line">    def response = connection.content.text</span><br><span class="line">    //将json转对象</span><br><span class="line">    def jsonSlpuer = new JsonSlurper()</span><br><span class="line">    return jsonSlpuer.parseText(response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def response = getNetworkDate(&apos;&apos;)</span><br><span class="line">println response.data.head.name</span><br></pre></td></tr></table></figure>
<h1 id="groovy对xml文件的处理"><a href="#groovy对xml文件的处理" class="headerlink" title="groovy对xml文件的处理"></a>groovy对xml文件的处理</h1><p>解析XML文件<br><img src="/2019/05/22/groovy-learn（三）/xmlString.png" alt><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def xml = &apos;&apos;&apos; &apos;&apos;&apos;</span><br><span class="line">def xmlSluper = new XmlSlurper()</span><br><span class="line">def result = xmlSluper.parseText(xml)</span><br><span class="line">println result.value.books[0].book[0].title.text()</span><br><span class="line">println result.value.books[0].book[0].@avaliable</span><br><span class="line"></span><br><span class="line">//根据作者赛筛选数据</span><br><span class="line">def bookList = []</span><br><span class="line">result.value.books.each&#123; books-&gt;</span><br><span class="line">    books.book.each&#123; book-&gt;</span><br><span class="line">        def author = book.author.text()</span><br><span class="line">        if(author.equals(&quot;李刚&quot;))&#123;</span><br><span class="line">            bookList.add(book.title.text())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//深层遍历</span><br><span class="line">def titles = result.depthFirst().findAll &#123;book-&gt;</span><br><span class="line">    return book.author.text() == &apos;李刚&apos;? true :false</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//创建XML</span><br><span class="line">def sw = new StringWriter()</span><br><span class="line">def xmlBuilder = new MarkupBuilder(sw)</span><br><span class="line">xmlBuilder.langs(type:&apos;current&apos;)&#123;</span><br><span class="line">    language(flavor:&apos;static&apos;)</span><br><span class="line">    language(flavor:&apos;public&apos;)</span><br><span class="line">    language(flavor:&apos;private&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println sw</span><br></pre></td></tr></table></figure></p>
<h1 id="groovy-对文件的处理"><a href="#groovy-对文件的处理" class="headerlink" title="groovy 对文件的处理"></a>groovy 对文件的处理</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//读取文件</span><br><span class="line">def file = new File(&apos;../../helloGroovy.iml&apos;)</span><br><span class="line">file.eachLine &#123;line-&gt;</span><br><span class="line">    println line</span><br><span class="line">&#125;</span><br><span class="line">打印出全部的文件信息</span><br><span class="line">println file.text</span><br><span class="line">打印一部分文件的信息</span><br><span class="line">def  reader = file.withReader &#123;reader-&gt;</span><br><span class="line">    char[] buffer = new char[100]</span><br><span class="line">    reader.read(buffer)</span><br><span class="line">    return buffer</span><br><span class="line">&#125;</span><br><span class="line">println reader</span><br><span class="line"></span><br><span class="line">def copy(String sourcePath,String destationPath)&#123;</span><br><span class="line">    def desFile = new File(destationPath)</span><br><span class="line">    if(!desFile.exists())&#123;</span><br><span class="line">        desFile.createNewFile()</span><br><span class="line">    &#125;</span><br><span class="line">    //copy</span><br><span class="line">    new File(sourcePath).withReader &#123;reader-&gt;</span><br><span class="line">        def lines = reader.readLines()</span><br><span class="line">        desFile.withWriter &#123;writer-&gt;</span><br><span class="line">            lines.each &#123;line-&gt;</span><br><span class="line">                writer.append(line)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br><span class="line">def copy = copy(&apos;../../helloGroovy.iml&apos;,&apos;../../helloGroovy2.iml&apos;)</span><br><span class="line">//测试存/读取对象</span><br><span class="line">def saveObject(Object obj,String path)&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        def desFile = new File(path)</span><br><span class="line">        if(!desFile.exists())&#123;</span><br><span class="line">            desFile.createNewFile()</span><br><span class="line">        &#125;</span><br><span class="line">        desFile.withObjectOutputStream &#123;out-&gt;</span><br><span class="line">            out.writeObject(obj)</span><br><span class="line">        &#125;</span><br><span class="line">        return true</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">        reutrn false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">def readObject(String path)&#123;</span><br><span class="line">    def obj = null</span><br><span class="line">    try&#123;</span><br><span class="line">        def file = new File(path)</span><br><span class="line">        if(file == null || !file.exists())&#123;return null&#125;</span><br><span class="line">        //文件中读取对象</span><br><span class="line">        file.withObjectInputStream &#123;input-&gt;</span><br><span class="line">            obj=input.readObject()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return obj</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line">def person = new Person(name: &quot;david&quot;,age:17)</span><br><span class="line">//saveObject(person,&apos;../../person.bin&apos;)</span><br><span class="line">def result = (Person)readObject(&apos;../../person.bin&apos;)</span><br><span class="line">println  &quot;name: $&#123;result.name&#125;,age:$&#123;result.age&#125;&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>java工具</tag>
        <tag>gradle，groovy</tag>
      </tags>
  </entry>
  <entry>
    <title>groovy-learn（二）</title>
    <url>/2019/05/20/groovy-learn%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="groovy中的数据结构"><a href="#groovy中的数据结构" class="headerlink" title="groovy中的数据结构"></a>groovy中的数据结构</h1><h2 id="groovy中列表的操作"><a href="#groovy中列表的操作" class="headerlink" title="groovy中列表的操作"></a>groovy中列表的操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//列表</span><br><span class="line">//def list = new ArrayList(); java中定义列表的方式</span><br><span class="line">def list = [1,2,3,4,5]</span><br><span class="line">//println list.class</span><br><span class="line">//println list.size()</span><br><span class="line"></span><br><span class="line">//定义数组的方式</span><br><span class="line">//def array = [1,2,3,4,5] as int[]</span><br><span class="line">//int[] array2 = [1,2,3,4,5]</span><br><span class="line"></span><br><span class="line">//对列表进行排序</span><br><span class="line">def sortList = [5,9,3,5,-2]</span><br><span class="line">//Collections.sort(sortList)</span><br><span class="line">Comparator comparator = &#123;</span><br><span class="line">    a,b-&gt; Math.abs(b)&gt;Math.abs(a) ? 1 :  -1  //比较的逻辑和结果是反的？？？</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(sortList,comparator)</span><br><span class="line">println  sortList</span><br><span class="line"></span><br><span class="line">def strList = [&apos;sd&apos;,&apos;ddqw&apos;,&apos;qwefcf&apos;,&apos;a&apos;]</span><br><span class="line">strList.sort&#123;it-&gt;return it.size()&#125;</span><br><span class="line"></span><br><span class="line">//列表的查找</span><br><span class="line">def findList = [1,6,9,4,11]</span><br><span class="line">//int result = findList.find &#123;</span><br><span class="line">//    return it%2==0</span><br><span class="line">//&#125;</span><br><span class="line">//def result = findList.findAll &#123;</span><br><span class="line">//    return it%2!=0</span><br><span class="line">//&#125;</span><br><span class="line">//def result = findList.min&#123;return Math.abs(it)&#125;</span><br><span class="line">//def result = findList.max&#123;return Math.abs(it)&#125;</span><br><span class="line">//def result = findList.count &#123;return it&gt;10&#125;</span><br><span class="line">//println result</span><br><span class="line"></span><br><span class="line">//list的元素添加</span><br><span class="line">findList.add(8)</span><br><span class="line">findList.leftShift(7)</span><br><span class="line">findList&lt;&lt;13</span><br><span class="line">//println findList</span><br><span class="line"></span><br><span class="line">//list的删除操作</span><br><span class="line">findList.remove(7)//移除下标的元素</span><br><span class="line">findList.remove((java.lang.Object) 7)//移除元素</span><br><span class="line">println findList</span><br></pre></td></tr></table></figure>
<h2 id="groovy中的映射"><a href="#groovy中的映射" class="headerlink" title="groovy中的映射"></a>groovy中的映射</h2><p>map在groovy中的定义<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//map的定义</span><br><span class="line">def colors = [red:&apos;ff00000&apos;,green:&apos;00ff00&apos;,blue:&apos;0000ff&apos;]</span><br><span class="line">//map查询</span><br><span class="line">//println colors[&apos;red&apos;]</span><br><span class="line">//println colors.red</span><br><span class="line">//添加元素</span><br><span class="line">colors.yellow = &apos;ffff00&apos;</span><br><span class="line">//println colors.toMapString( )</span><br><span class="line"></span><br><span class="line">//map的遍历</span><br><span class="line">def stu = [1:[num:&apos;001&apos;,name:&apos;boa&apos;,score:11],</span><br><span class="line">           2:[num:&apos;002&apos;,name:&apos;bob&apos;,score:57],</span><br><span class="line">           3:[num:&apos;003&apos;,name:&apos;boc&apos;,score:89],</span><br><span class="line">           4:[num:&apos;004&apos;,name:&apos;bod&apos;,score:94]</span><br><span class="line">            ]</span><br><span class="line">stu.each &#123;</span><br><span class="line">    def student-&gt;</span><br><span class="line">        println &quot;the key is $&#123;student.key&#125;,the value is $&#123;student.value&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">//直接遍历key ,value</span><br><span class="line">stu.eachWithIndex&#123; key,value,index -&gt;</span><br><span class="line">    println &quot;the key is $&#123;key&#125;,the value is $&#123;value&#125; index is $&#123;index&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//map中的查找</span><br><span class="line">def entry = stu.find &#123;def student -&gt;return student.value.score&gt;60&#125;</span><br><span class="line">//println  entry</span><br><span class="line"></span><br><span class="line">def names = stu.findAll &#123;def student -&gt;return student.value.score&gt;60&#125;.collect &#123;return it.value.name&#125;</span><br><span class="line">//println names</span><br><span class="line"></span><br><span class="line">//map的排序</span><br><span class="line">def sort = stu.sort &#123;def stu1,def stu2 -&gt;</span><br><span class="line">    Number score1 = stu1.value.score</span><br><span class="line">    Number score2 = stu2.value.score</span><br><span class="line">    return score1 == score2 ? 0 :score1&lt;score2? -1: 1</span><br><span class="line">&#125;</span><br><span class="line">println  sort</span><br></pre></td></tr></table></figure></p>
<h2 id="groovy中的范围"><a href="#groovy中的范围" class="headerlink" title="groovy中的范围"></a>groovy中的范围</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//定义范围</span><br><span class="line">def range = 1..10</span><br><span class="line"></span><br><span class="line">println range[0]//获取范围中的元素,取第一个数</span><br><span class="line">println range.contains(7)//判断是否包含某个元素</span><br><span class="line">println range.from//起始值</span><br><span class="line">println range.to//中止值</span><br><span class="line">//遍历</span><br><span class="line">range.each &#123;</span><br><span class="line">    println it</span><br><span class="line">&#125;</span><br><span class="line">//范围的应用</span><br><span class="line">def getGrade(Number number) &#123;</span><br><span class="line">    def result</span><br><span class="line">    switch (number) &#123;</span><br><span class="line">        case 0..60:</span><br><span class="line">            result = &quot;不及格&quot;</span><br><span class="line">            break</span><br><span class="line">        case 61..100:</span><br><span class="line">            result = &quot;及格&quot;</span><br><span class="line">            break</span><br><span class="line">    &#125;</span><br><span class="line">    println result</span><br><span class="line">&#125;</span><br><span class="line">getGrade(71)</span><br></pre></td></tr></table></figure>
<h1 id="groovy中的面向对象类，接口的使用"><a href="#groovy中的面向对象类，接口的使用" class="headerlink" title="groovy中的面向对象类，接口的使用"></a>groovy中的面向对象类，接口的使用</h1><p>创建 new Groovy Class<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 默认为class</span><br><span class="line">// 默认继承groovyObject类</span><br><span class="line">class Person &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Integer age;</span><br><span class="line"></span><br><span class="line">    def increaseAge(Integer year)&#123;</span><br><span class="line">        age += year;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建groovy的脚本 groovy script类型 objectstu<br>操作对象的属性和方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person person = new Person(name: &apos;david&apos;,age: 22)</span><br><span class="line">println &quot;person&apos;s name is $&#123;person.name&#125; .person&apos;s age is $&#123;person.age&#125;&quot;</span><br><span class="line">person.increaseAge(12)</span><br><span class="line">person.play()</span><br><span class="line">person.eat()</span><br></pre></td></tr></table></figure></p>
<p>创建groovy中的接口<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> //接口中的方法只能是public</span><br><span class="line">interface Action &#123;</span><br><span class="line">    def eat()</span><br><span class="line">    def drink()</span><br><span class="line">    def play()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Trait类似Interface,可以定义默认的实现方法，java8中也能配置接口默认实现方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">trait DefaultAction &#123;</span><br><span class="line">    abstract void eat()</span><br><span class="line">    void play()&#123;</span><br><span class="line">        println &quot;play&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h1><p>groovy中方法的调用顺序如图<br><img src="/2019/05/20/groovy-learn（二）/yuan.png" alt><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">println person.cry()</span><br></pre></td></tr></table></figure></p>
<p>会报错groovy.lang.MissingMethodException: No signature of method<br>重写Person类中的invokeMethod方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 一个方法寻找不到调用此方法</span><br><span class="line"> */</span><br><span class="line">    @Override</span><br><span class="line">    Object invokeMethod(String s, Object o) &#123;</span><br><span class="line">        return &quot;method name is $&#123;s&#125;,param is $&#123;o&#125;&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>再次运行程序打印方法名称和参数<br>同理也可以重写methodMissing方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def methodMissing(String name,Object args)&#123;</span><br><span class="line">    return &quot;method2 name is $&#123;name&#125;,param is $&#123;args&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="metaClass的使用"><a href="#metaClass的使用" class="headerlink" title="metaClass的使用"></a>metaClass的使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为类动态新增一个属性 </span><br><span class="line">Person.metaClass.sex = &apos;male&apos;</span><br><span class="line">Person p1 = new Person(name: &apos;jane&apos;,age: 23)</span><br><span class="line">println p1.sex</span><br><span class="line">//为类动态生成方法</span><br><span class="line">Person.metaClass.upper = &#123;-&gt;sex.toUpperCase()&#125;</span><br><span class="line">println p1.upper()</span><br><span class="line">//生成静态方法</span><br><span class="line">Person.metaClass.static.createPerson=&#123;String name,Integer age-&gt;new Person(name:name,age:age)&#125;</span><br><span class="line">Person p2 =  Person.createPerson(&quot;test&quot;,3)</span><br><span class="line">println p2.name+&quot; and &quot;+p2.getAge()</span><br></pre></td></tr></table></figure>
<p>如果想要注入的方法或者属性全局可用<br>在外部的注入方法前添加<br>ExpandMetaClass.enableGlobally()</p>
]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>java工具</tag>
        <tag>gradle，groovy</tag>
      </tags>
  </entry>
  <entry>
    <title>groovy learn（一）</title>
    <url>/2019/05/19/groovy-learn%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="一、groovy-的环境安装"><a href="#一、groovy-的环境安装" class="headerlink" title="一、groovy 的环境安装"></a>一、groovy 的环境安装</h1><p>centos下的安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -s get.sdkman.io | bash</span><br><span class="line">$ source &quot;$HOME/.sdkman/bin/sdkman-init.sh&quot;</span><br><span class="line">$ sdk install groovy</span><br><span class="line">$ groovy -version</span><br></pre></td></tr></table></figure></p>
<p>windows下的安装<br>官网下载安装包后解压，配置环境<br>•新建GROOVY_HOME，值为解压后文件的路径。<br><img src="/2019/05/19/groovy-learn（一）/groovy_home.png" alt><br>•修改PATH，在最后追加<code>%GROOVY_HOME%\bin<br><img src="/2019/05/19/groovy-learn（一）/home.png" alt></code></p>
<p>#二 groovy的基础语法<br>groovy的变量<br><img src="/2019/05/19/groovy-learn（一）/type.png" alt><br>创建.Groovy Script文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package variable</span><br><span class="line">//groovy 中变量最后都会被包装成对象类型</span><br><span class="line">int x = 10</span><br><span class="line">println x.class  //Integer</span><br><span class="line">double  y = 1.14</span><br><span class="line">println y.class  // Double</span><br><span class="line"></span><br><span class="line">//groovy 定义变量的类型,使用def快速定义弱类型,推断数据类型</span><br><span class="line">def x_1 =2</span><br><span class="line">println x_1.class</span><br><span class="line">def y_1 = 3.15</span><br><span class="line">println y_1.class</span><br><span class="line">def name = &apos;david&apos;</span><br><span class="line">println name.class</span><br></pre></td></tr></table></figure></p>
<h1 id="三、groovy中的字符串用法"><a href="#三、groovy中的字符串用法" class="headerlink" title="三、groovy中的字符串用法"></a>三、groovy中的字符串用法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def str = &apos;a \&apos;a\&apos; string &apos;</span><br><span class="line">println str</span><br><span class="line">println str.class</span><br><span class="line"></span><br><span class="line">//三个引号定义的字符串可以指定格式</span><br><span class="line">def thupleStr = &apos;&apos;&apos;\</span><br><span class="line">three </span><br><span class="line">signle </span><br><span class="line">string&apos;&apos;&apos;</span><br><span class="line">println thupleStr</span><br><span class="line">println  thupleStr.class</span><br><span class="line"></span><br><span class="line">//双引号字符串格式,可一再字符串中引用其他字符串，引用其他变量后类型是groovy.runtime.GStringImpl</span><br><span class="line">def name =  &quot;david&quot;</span><br><span class="line">def doubleName = &quot;name: $&#123;thupleStr&#125;&quot;</span><br><span class="line">println doubleName</span><br><span class="line">println doubleName.class</span><br><span class="line"></span><br><span class="line">//双引号中的扩展接受任意的表达式</span><br><span class="line">def sum = &quot;the sum of 2 and 3 equals $&#123;2 + 3&#125;&quot;</span><br><span class="line">println sum</span><br><span class="line"></span><br><span class="line">//测试GString 和String 的转换.编译器转换</span><br><span class="line">def result = echo(sum)</span><br><span class="line">println result</span><br><span class="line">println result.class</span><br><span class="line">String echo(String message)&#123;</span><br><span class="line">    return message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*******字符串String 常用方法 *********************/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def str1 = &quot;justTest&quot;</span><br><span class="line">//println st1.center(9,&apos;a&apos;)//字符串两边填充字符，默认填充空格。先右后左</span><br><span class="line"></span><br><span class="line">//println str1.padLeft(10,&apos;a&apos;)//字符串右侧填充</span><br><span class="line"></span><br><span class="line">//字符串比较</span><br><span class="line">def str2 = &quot;hello&quot;</span><br><span class="line">println str1&gt;str2</span><br><span class="line"></span><br><span class="line">println str2[0]  //获取下标的值</span><br><span class="line">println str2[0..3]  //获取下标范围的值</span><br><span class="line"></span><br><span class="line">println str2.minus(&quot;ello&quot;)   //等同于 石str1 - str2</span><br><span class="line"></span><br><span class="line">println str2.reverse() //字符串反转</span><br><span class="line"></span><br><span class="line">println str2.capitalize()  //首字母大写</span><br></pre></td></tr></table></figure>
<h1 id="四、groovy中的逻辑控制"><a href="#四、groovy中的逻辑控制" class="headerlink" title="四、groovy中的逻辑控制"></a>四、groovy中的逻辑控制</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> package variable</span><br><span class="line">//逻辑控制</span><br><span class="line"></span><br><span class="line">// switch语句</span><br><span class="line"> def x = 1.23</span><br><span class="line"> def result</span><br><span class="line"> switch (x)&#123;</span><br><span class="line">    case &apos;foo&apos;:</span><br><span class="line">        result=&quot;founf foo&quot;</span><br><span class="line">        break</span><br><span class="line">     case &apos;bar&apos;:</span><br><span class="line">         result = &apos;bar&apos;</span><br><span class="line">         break</span><br><span class="line">     case [1.23,5,6,&apos;inList&apos;]: //列表中的结果匹配</span><br><span class="line">         result = &apos;list&apos;</span><br><span class="line">         break</span><br><span class="line">     case 12..30:</span><br><span class="line">         result = &apos;range&apos;</span><br><span class="line">         break</span><br><span class="line">     case Integer:</span><br><span class="line">         result = &apos;integer&apos;</span><br><span class="line">         break</span><br><span class="line">     case BigDecimal:</span><br><span class="line">         result = &apos;bigDecimal&apos;</span><br><span class="line">         break</span><br><span class="line">     default:result = &apos;default&apos;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> println result</span><br><span class="line"></span><br><span class="line">// for循环  计算0-9的和</span><br><span class="line">def sum = 0</span><br><span class="line"> for(i in 0..9)&#123;</span><br><span class="line">     sum+=i</span><br><span class="line"> &#125;</span><br><span class="line"> println &apos;sum:&apos;+sum</span><br><span class="line"></span><br><span class="line"> //对于List中元素循环</span><br><span class="line"> def sum1 = 0</span><br><span class="line"> for(i in [1,2,3,4,5,6,7,8,9])&#123;</span><br><span class="line">     sum1 += i</span><br><span class="line"> &#125;</span><br><span class="line"> println &quot;sum1:&quot;+sum1</span><br><span class="line"></span><br><span class="line">// 对MAP进行循环</span><br><span class="line"> def sum2 =0</span><br><span class="line"> for(i in [&apos;xiaoMing&apos;:1,&apos;xiaoQiang&apos;:2,&apos;xiaoHua&apos;:3])&#123;</span><br><span class="line">     sum2 += i.value</span><br><span class="line"> &#125;</span><br><span class="line"> println &apos;sum2:&apos;+sum2</span><br></pre></td></tr></table></figure>
<h1 id="五、闭包"><a href="#五、闭包" class="headerlink" title="五、闭包"></a>五、闭包</h1><p><img src="/2019/05/19/groovy-learn（一）/close.png" alt></p>
<p>##闭包的定义<br>闭包是代码块。定义如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//*******闭包的定义和参数********</span><br><span class="line">def closure = &#123;println  &quot;close package&quot;&#125;//闭包的定义方式</span><br><span class="line">closure.call()//调用闭包方法的两种方式</span><br><span class="line">//closure()</span><br><span class="line"></span><br><span class="line">def close = &#123;String name -&gt; println &quot;hello $&#123;name&#125;&quot;&#125;//有参数的闭包定义</span><br><span class="line">close(&quot;david&quot;)</span><br><span class="line"></span><br><span class="line">//多个参数</span><br><span class="line">def close1 = &#123;String name,Integer age-&gt; println &quot;hello :$&#123;name&#125;&amp;$&#123;age&#125;&quot;&#125;</span><br><span class="line">close1(&quot;pangpang&quot;,12)</span><br><span class="line"></span><br><span class="line">//闭包方法的隐式参数it</span><br><span class="line">def close2 = &#123; println &quot;hello $&#123;it&#125;&quot;&#125;</span><br><span class="line">close2(&quot;david&quot;)</span><br><span class="line"></span><br><span class="line">//*********闭包的返回值**********</span><br><span class="line">def close3 = &#123; println  &quot;test return $&#123;it&#125;&quot;&#125;</span><br><span class="line">def result = close3(&quot;test&quot;)</span><br><span class="line">println result //闭包方法必定有返回值，默认返回null</span><br></pre></td></tr></table></figure></p>
<h2 id="闭包的用法"><a href="#闭包的用法" class="headerlink" title="闭包的用法"></a>闭包的用法</h2><p><img src="/2019/05/19/groovy-learn（一）/closeuse.png" alt><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//闭包求阶乘</span><br><span class="line">int fab(number)&#123;</span><br><span class="line">    int result = 1</span><br><span class="line">    1.upto(number,&#123;num-&gt;result *=num&#125;)//upto 实现循环阶乘</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">println &quot;向上阶乘：&quot;+fab(5)</span><br><span class="line"></span><br><span class="line">int fab2(int number2)&#123;</span><br><span class="line">    int result = 1</span><br><span class="line">    number2.downto(1,&#123;num-&gt;result *=num&#125;)</span><br><span class="line">    return  result</span><br><span class="line">&#125;</span><br><span class="line">println &quot;向下阶乘：&quot;+fab2(7)</span><br><span class="line"></span><br><span class="line">//累计求和方法,这里的次数由0开始，所以不能用于阶乘的计算</span><br><span class="line">int cal(int number)&#123;</span><br><span class="line">    int sum = 0</span><br><span class="line">    number.times&#123; num-&gt;sum+=num &#125;</span><br><span class="line">    return sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println cal(101) // 计算0-100的结果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//*********字符串在闭包的使用</span><br><span class="line">String str =&quot;string test 1&quot;</span><br><span class="line">str.each &#123;</span><br><span class="line">//    String result -&gt; print result.multiply(2)  //每个字符串输出两次</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查找满主条件的第一个元素</span><br><span class="line">str.find&#123;</span><br><span class="line">    String s-&gt;s.isNumber()  //必须是一个返回布尔类型的闭包</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查找满主条件的所有元素</span><br><span class="line">def list = str.findAll&#123;</span><br><span class="line">    String s -&gt; !s.isNumber()</span><br><span class="line">&#125;</span><br><span class="line">println &quot;列表：&quot;+list.toListString()</span><br><span class="line"></span><br><span class="line">//判断字符串是否满足某个条件</span><br><span class="line">def res = str.any &#123;</span><br><span class="line">    String s-&gt; s.isNumber()</span><br><span class="line">&#125;</span><br><span class="line">println &quot;res:&quot;+res</span><br><span class="line"></span><br><span class="line">//是否每一项满足某个条件</span><br><span class="line">println &quot;every:&quot;+str.every &#123;String s-&gt; s.isNumber()&#125;</span><br><span class="line"></span><br><span class="line">//对字符串中每一项处理</span><br><span class="line">def list2 = str.collect &#123;</span><br><span class="line">    it.toUpperCase()</span><br><span class="line">&#125;</span><br><span class="line">println &quot;list2:&quot;+list2.toListString()</span><br></pre></td></tr></table></figure></p>
<h2 id="闭包的三个重要变量"><a href="#闭包的三个重要变量" class="headerlink" title="闭包的三个重要变量"></a>闭包的三个重要变量</h2><p>this、owner、delegate三个关键字<br>this代表定义闭包的类。<br>owner代表闭包定义处的类或者对象，闭包内部定义闭包中的owner是外层的闭包<br>deleGate 代表任意的对象，默认值就是owner<br>如果在类或者方法中定义闭包，此时this,owner,deleGate是一样的，指向闭包定义处的实例或者类本身<br>如果在闭包中定义闭包，this指向的仍然是闭包处的实例或者类本身，而owner和deleGate指向的最近的闭包对象。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> //定义一个内部类 , 三个变量指向最近的封闭类</span><br><span class="line">class Person&#123;</span><br><span class="line">    def classClosure = &#123;</span><br><span class="line">        println &quot;classClouser this&quot;+this</span><br><span class="line">        println &quot;classClouser this&quot;+owner</span><br><span class="line">        println &quot;classClouser this&quot;+delegate</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    def say()&#123;</span><br><span class="line">        def methodClosure = &#123;</span><br><span class="line">            println &quot;methodClouser this&quot;+this</span><br><span class="line">            println &quot;methodClouser this&quot;+owner</span><br><span class="line">            println &quot;methodClouser this&quot;+delegate</span><br><span class="line">        &#125;</span><br><span class="line">        methodClosure.call()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person person = new Person()</span><br><span class="line">person.classClosure.call()</span><br><span class="line">person.say()</span><br><span class="line"></span><br><span class="line">//在闭包中中定义闭包</span><br><span class="line">def nestClouser = &#123;</span><br><span class="line">    def innerClouser = &#123;</span><br><span class="line">        println &quot;innerClouser this&quot;+this</span><br><span class="line">        println &quot;innerClouser this&quot;+owner</span><br><span class="line">        println &quot;innerClouser this&quot;+delegate</span><br><span class="line">    &#125;</span><br><span class="line">    innerClouser.delegate = person // 修改默认的deleGate.此时deleGate指向person对象</span><br><span class="line"></span><br><span class="line">    innerClouser.call()</span><br><span class="line">&#125;</span><br><span class="line">//this 指向实例本身或者定义处的类，owner和deleGate表示的是距离最近的闭包</span><br><span class="line">nestClouser.call()</span><br></pre></td></tr></table></figure></p>
<h2 id="闭包的委托策略"><a href="#闭包的委托策略" class="headerlink" title="闭包的委托策略"></a>闭包的委托策略</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//委托构造</span><br><span class="line">class Student&#123;</span><br><span class="line">    String name</span><br><span class="line">    def pretty = &#123;</span><br><span class="line">        println &quot;my name is $&#123;name&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String toString()&#123;</span><br><span class="line">        pretty.call()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Teacher&#123;</span><br><span class="line">    String name</span><br><span class="line">&#125;</span><br><span class="line">Student student = new Student(name: &quot;jane&quot;)</span><br><span class="line">Teacher teacher = new Teacher(name: &quot;lay&quot;)</span><br><span class="line">student.toString();</span><br><span class="line">student.pretty.delegate = teacher // 将闭包中的delegate指向teacher</span><br><span class="line">student.pretty.resolveStrategy = Closure.DELEGATE_FIRST  //修改委托策略为 deleGate 默认是owner</span><br><span class="line">student.toString()  //此时会在委托的类中寻找name属性，找不到会回来本身类的内部寻找</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>java工具</tag>
        <tag>gradle，groovy</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle学习（二）</title>
    <url>/2019/05/09/gradleTwo/</url>
    <content><![CDATA[<h1 id="gradle的生命周期"><a href="#gradle的生命周期" class="headerlink" title="gradle的生命周期"></a>gradle的生命周期</h1><p>![][/yilai.png]<br>gradle的生命周期监听<br>gradle 的生命周期主要分为三个阶段：<br>@nesp;@nesp;@nesp;@nesp;项目的初始化阶段，构建Project项目的project对象<br>@nesp;@nesp;@nesp;@nesp;解析所有projiect中的task,并构建task的拓扑图<br>@nesp;@nesp;@nesp;@nesp;执行相关的task和相关的task</p>
<p>项目的目录结构如下图所示<br><img src="/2019/05/09/gradleTwo/content.png" alt><br>全局的build.gradle中添加监听方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//声明gradle脚本自身需要的资源，可以声明的资源包括依赖项、第三方插件、maven仓库地址等</span><br><span class="line">buildscript&#123;&#125;</span><br><span class="line">// 所有子项目的通用配置</span><br><span class="line">subprojects &#123;&#125;</span><br><span class="line">//所有项目的通用配置</span><br><span class="line">allprojects&#123;&#125;</span><br><span class="line"></span><br><span class="line">//初始化阶段后，配置阶段开始前的</span><br><span class="line">this.beforeEvaluate &#123;&#125;</span><br><span class="line"></span><br><span class="line">//配置阶段完成，执行阶段前</span><br><span class="line">this.afterEvaluate &#123;</span><br><span class="line">    println &quot;配置完成&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//gradle生命周期完成之后</span><br><span class="line">this.gradle.buildFinished &#123;</span><br><span class="line">    println &quot;执行完成&quot;</span><br><span class="line">&#125;</span><br><span class="line">在setting.gradle中添加</span><br><span class="line">println &quot;初始化开始&quot;</span><br></pre></td></tr></table></figure></p>
<p>再运行gradle中的task就会打印出上述的打印语句</p>
<h2 id="gradle中的project"><a href="#gradle中的project" class="headerlink" title="gradle中的project"></a>gradle中的project</h2><p>在gradle多项目中，除了根工程，这些Moudle也是gradle的工程，而文件中的build.gradle标志Moudle是gradle项目<br>执行gradle projects命令，可以看见打印出<br><img src="/2019/05/09/gradleTwo/projects.png" alt><br>project以树的结构管理项目，但是项目一般只构建两层<br>gradle的相关API大致可以分为下图中的六部分<br><img src="/2019/05/09/gradleTwo/projects.png" alt></p>
<h3 id="project中的API"><a href="#project中的API" class="headerlink" title="project中的API"></a>project中的API</h3><p>在根project的build中定义打印处所有project的方法，并调用，可以直接在命令窗口上任意运行task，因为都会加载配置文件，执行this.getProjects()在加载配置文件中就运行。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//加载配置文件时会调用</span><br><span class="line">this.getProjects()</span><br><span class="line">//返回所有的project列表</span><br><span class="line">def getProjects()&#123;</span><br><span class="line">    println &quot;--------&quot;</span><br><span class="line">    println &quot;root project&quot;</span><br><span class="line">    println &quot;--------&quot;</span><br><span class="line">    this.getAllprojects().eachWithIndex&#123; Project project, int i -&gt;</span><br><span class="line">        if(i==0)&#123;</span><br><span class="line">            println &quot;rootProject:$&#123;project.name&#125;&quot;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            println &quot;+-- :$&#123;project.name&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同理，还可以定义获取父project和根project的方法，但是这获取父project方法不能再根目录下的build中运行，因为根目录没有父project了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//获取父project的名称</span><br><span class="line">def getParentName = &#123;</span><br><span class="line">    println this.getParent().name</span><br><span class="line">&#125;</span><br><span class="line">//获取根目录的名称</span><br><span class="line">def getRootName =&#123;</span><br><span class="line">    println this.getRootProject().name</span><br><span class="line">&#125;</span><br><span class="line">//相当于设置对应模块的配置，不过通用模块可以在subprojects&#123;&#125;里面配置的</span><br><span class="line">project(&apos;webOne&apos;)&#123;</span><br><span class="line">    Project project-&gt; println project.name</span><br><span class="line">        apply plugin: &apos;io.spring.dependency-management&apos;</span><br><span class="line">        agroup &apos;com.demo&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="属性相关的API"><a href="#属性相关的API" class="headerlink" title="属性相关的API"></a>属性相关的API</h3><p>geadle中的Project中的默认配置如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Project extends Comparable&lt;Project&gt;, ExtensionAware, PluginAware &#123;</span><br><span class="line">	//默认的配置文件名称是build.gradle，</span><br><span class="line">    String DEFAULT_BUILD_FILE = &quot;build.gradle&quot;;</span><br><span class="line">	//默认的路径分割符</span><br><span class="line">    String PATH_SEPARATOR = &quot;:&quot;;</span><br><span class="line">	//gradle的默认输出文件夹</span><br><span class="line">    String DEFAULT_BUILD_DIR_NAME = &quot;build&quot;;</span><br><span class="line">	//配置常量文件名</span><br><span class="line">    String GRADLE_PROPERTIES = &quot;gradle.properties&quot;;</span><br><span class="line">    String SYSTEM_PROP_PREFIX = &quot;systemProp&quot;;</span><br><span class="line">    String DEFAULT_VERSION = &quot;unspecified&quot;;</span><br><span class="line">    String DEFAULT_STATUS = &quot;release&quot;;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在build.gradle中定义扩展属性和定义版本<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//定义扩展属性</span><br><span class="line">ext &#123;</span><br><span class="line">	set(&apos;springCloudVersion&apos;, &quot;Greenwich.SR1&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//使用扩展的属性</span><br><span class="line">dependencyManagement &#123;</span><br><span class="line">	imports &#123;</span><br><span class="line">		mavenBom &quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想在所有的子项目中都定义某些属性，可以在subProjects{}中编写ext{},或是在build.gradle中添加属性，在子项目的build.gradle文件中使用${}去获取对应的值。<br>在根目录下的settings.gradle,gradle.properties中控制是否添加webOned,然后刷新gradle，idea会提示webOne移出Gradle,而且树状结构也没有了webOne<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//gradle.properties中</span><br><span class="line">isLoadOne= fasle</span><br><span class="line"></span><br><span class="line">//在settings.gradle中添加</span><br><span class="line">rootProject.name = &apos;myGradleProject&apos;</span><br><span class="line">include &apos;webTwo&apos;</span><br><span class="line">if(hasProperty(&apos;isLoadOne&apos;)?isLoadOne.toBoolean():false&#123;</span><br><span class="line">	include &apos;webOne&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="文件操作属性API"><a href="#文件操作属性API" class="headerlink" title="文件操作属性API"></a>文件操作属性API</h3><p>获取文件相关的API<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//获取跟工程的根路径</span><br><span class="line">println &quot;root path :&quot;+ getRootDir().absolutePath</span><br><span class="line">//build文件的路径</span><br><span class="line">println &quot;build path:&quot;+getBuildDir().absolutePath</span><br><span class="line">//当前project路径</span><br><span class="line">println  &quot;project path:&quot;+getProjectDir().absolutePath</span><br><span class="line"></span><br><span class="line">//在build.gradle找到对应路径的文件，并打印出内容</span><br><span class="line">def getContent(String path)&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">	//file方法从当前project的路径开始寻找，files（）方法参数是多个路径，返回的参数是file的集合</span><br><span class="line">        def file = file(path)</span><br><span class="line">        return file.text</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        println &quot;error&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println getContent(&apos;build.gradle&apos;)</span><br></pre></td></tr></table></figure></p>
<p>gradle的文件拷贝在webOne中新建一个文件copy.txt,webOne的build中添加下面的代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy &#123;</span><br><span class="line">	from(&apos;copytest.txt&apos;)</span><br><span class="line">	into getRootProject()</span><br><span class="line">	//不拷贝某些文件</span><br><span class="line">	exclude&#123;&#125;</span><br><span class="line">	//拷贝后重命名</span><br><span class="line">	rename&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在执行gradle的同步后就会在build文件夹下生成对应的文件，<br>文件树的遍历<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//对文件树的遍历</span><br><span class="line">fileTree(&apos;webTwo/src&apos;) &#123; FileTree fileTree-&gt;</span><br><span class="line">    fileTree.visit &#123;FileTreeElement fileTreeElement-&gt;</span><br><span class="line">        println &quot;the file name is :&quot;+fileTreeElement.file.name</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="依赖相关的API"><a href="#依赖相关的API" class="headerlink" title="依赖相关的API"></a>依赖相关的API</h3><p>buildscript 是项目的配置，常用通过的是repositories仓库的配置和dependencies依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buildscript&#123; ScriptHandler scriptHandler-&gt;</span><br><span class="line">    //配置工程的仓库地址</span><br><span class="line">  repositories&#123;</span><br><span class="line">        //私有仓库,如果多个就继续配下去</span><br><span class="line">        maven &#123;</span><br><span class="line">            //仓库的别名</span><br><span class="line">            name &apos;person&apos;</span><br><span class="line">            //maven仓库地址</span><br><span class="line">            url &apos;hhttp://localhoys......&apos;</span><br><span class="line">            //配置仓库的账号和密码</span><br><span class="line">            credentials&#123;</span><br><span class="line">                username = &apos;admin&apos;</span><br><span class="line">                password = &apos;admin123&apos;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        mavenCentral()</span><br><span class="line">        //本地maven库</span><br><span class="line">        mavenLocal()</span><br><span class="line">        jcenter()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //配置工程的插件依赖地址</span><br><span class="line">    dependencies&#123;</span><br><span class="line">        //gradle需要的依赖</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:2.2.2&apos;</span><br><span class="line">        classpath &apos;com.tencent.tinker-patch-gradle-plugin:1.7.7&apos;//腾讯的热修复框架</span><br><span class="line">        //poject需要的依赖</span><br><span class="line">        compile （group: &apos;net.officefloor.server&apos;, name: &apos;officeserver&apos;, version: &apos;3.10.3‘）&#123;</span><br><span class="line">		//这个常用于解决依赖重复的冲突</span><br><span class="line">		exclude module:&apos;support-v4&apos;</span><br><span class="line">        //添加依赖的工程，引用project</span><br><span class="line">        compile project(&apos;webOne&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>java工具</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle学习（一）</title>
    <url>/2019/05/08/gradleOne/</url>
    <content><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>Gradle是一种构建工具，它抛弃了基于XML的构建脚本，取而代之的是采用一种基于Groovy的内部领域特定语言。<br>在Gradle中，有两个基本概念：项目和任务<br>&ensp;&ensp;&ensp;&ensp;1.项目是指我们的构建产物（比如Jar包）或实施产物（将应用程序部署到生产环境）。一个项目包含一个或多个任务。<br>&ensp;&ensp;&ensp;&ensp;2.任务是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试）。<br>每一次Gradle的构建都包含一个或多个项目。<br>&ensp;&ensp;&ensp;&ensp;Gradle本身的领域对象主要有Project和Task。Project为Task提供了执行上下文，所有的Plugin要么向Project中添加用于配置的Property，要么向Project中添加不同的Task。一个Task表示一个逻辑上较为独立的执行过程，比如编译Java源代码，拷贝文件，打包Jar文件，甚至可以是执行一个系统命令或者调用Ant。另外，一个Task可以读取和设置Project的Property以完成特定的操作。</p>
<h1 id="二、gradle的构建基础"><a href="#二、gradle的构建基础" class="headerlink" title="二、gradle的构建基础"></a>二、gradle的构建基础</h1><p>&ensp;&ensp;&ensp;&ensp;构建第一个脚本。创建一个build.gradle的文件,运行CMD切换到build.gradle的文件目录，gradle的命令默认会在当前目录下寻找名未build.gradle的构建脚本。build.gradle<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println &apos;Hello world!&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行命令gradle -q hello执行脚本，打印出  hello world</p>
<h2 id="快速定义任务"><a href="#快速定义任务" class="headerlink" title="快速定义任务"></a>快速定义任务</h2><p>采用闭包的方式来定义了一个叫做 hello 的任务<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task hello &lt;&lt; &#123;</span><br><span class="line">    println &apos;Hello world!&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>gradle脚本也能使用groovy，在build.gradle中编辑<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task upper &lt;&lt; &#123;</span><br><span class="line">    String someString = &apos;mY_nAmE&apos;</span><br><span class="line">    println &quot;Original: &quot; + someString</span><br><span class="line">    println &quot;Upper case: &quot; + someString.toUpperCase()</span><br><span class="line">&#125;</span><br><span class="line">Output of gradle -q upper</span><br><span class="line">&gt; gradle -q upper</span><br><span class="line">Original: mY_nAmE</span><br><span class="line">Upper case: MY_NAME</span><br></pre></td></tr></table></figure></p>
<h2 id="任务依赖"><a href="#任务依赖" class="headerlink" title="任务依赖"></a>任务依赖</h2><p>在build.gradle中添加任务<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task intro(dependsOn: hello) &lt;&lt; &#123;</span><br><span class="line">    println &quot;I&apos;m Gradle&quot;</span><br><span class="line">&#125;</span><br><span class="line">task hello &lt;&lt; &#123;</span><br><span class="line">    println &apos;Hello world!&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>任务之间的依赖的声明顺序可以不不必为顺序声明</p>
<h2 id="创建动态任务"><a href="#创建动态任务" class="headerlink" title="创建动态任务"></a>创建动态任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.times &#123; counter -&gt;</span><br><span class="line">    task &quot;task$counter&quot; &lt;&lt; &#123;</span><br><span class="line">        println &quot;I&apos;m task number $counter&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 API 进行任务之间的通信 - 增加任务行为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task hello &lt;&lt; &#123;</span><br><span class="line">    println &apos;Hello Earth&apos;</span><br><span class="line">&#125;</span><br><span class="line">hello.doFirst &#123;</span><br><span class="line">    println &apos;Hello Venus&apos;</span><br><span class="line">&#125;</span><br><span class="line">hello.doLast &#123;</span><br><span class="line">    println &apos;Hello Mars&apos;</span><br><span class="line">&#125;</span><br><span class="line">hello &lt;&lt; &#123;</span><br><span class="line">    println &apos;Hello Jupiter&apos;</span><br><span class="line">&#125;</span><br><span class="line">Output of gradle -q hello</span><br><span class="line">&gt; gradle -q hello</span><br><span class="line">Hello Venus</span><br><span class="line">Hello Earth</span><br><span class="line">Hello Mars</span><br><span class="line">Hello Jupiter</span><br></pre></td></tr></table></figure></p>
<h2 id="增加自定义的属性"><a href="#增加自定义的属性" class="headerlink" title="增加自定义的属性"></a>增加自定义的属性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task myTask &#123;</span><br><span class="line">    ext.myProperty = &quot;myValue&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task printTaskProperties &lt;&lt; &#123;</span><br><span class="line">    println myTask.myProperty</span><br><span class="line">&#125;</span><br><span class="line">//gradle -q printTaskProperties 的输出为</span><br><span class="line">Output of gradle -q printTaskProperties</span><br><span class="line">\&gt; gradle -q printTaskProperties</span><br><span class="line">myValue</span><br></pre></td></tr></table></figure>
<h2 id="定义默认任务"><a href="#定义默认任务" class="headerlink" title="定义默认任务"></a>定义默认任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">defaultTasks &apos;clean&apos;, &apos;run&apos;</span><br><span class="line">task clean &lt;&lt; &#123;</span><br><span class="line">    println &apos;Default Cleaning!&apos;</span><br><span class="line">&#125;</span><br><span class="line">task run &lt;&lt; &#123;</span><br><span class="line">    println &apos;Default Running!&apos;</span><br><span class="line">&#125;</span><br><span class="line">task other &lt;&lt; &#123;</span><br><span class="line">    println &quot;I&apos;m not a default task!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Output of gradle -q</span><br><span class="line">\&gt; gradle -q</span><br><span class="line">Default Cleaning!</span><br><span class="line">Default Running!</span><br></pre></td></tr></table></figure></p>
<h2 id="Configure-by-DAG"><a href="#Configure-by-DAG" class="headerlink" title="Configure by DAG"></a>Configure by DAG</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task distribution &lt;&lt; &#123;</span><br><span class="line">    println &quot;We build the zip with version=$version&quot;</span><br><span class="line">&#125;</span><br><span class="line">task release(dependsOn: &apos;distribution&apos;) &lt;&lt; &#123;</span><br><span class="line">    println &apos;We release now&apos;</span><br><span class="line">&#125;</span><br><span class="line">gradle.taskGraph.whenReady &#123;taskGraph -&gt;</span><br><span class="line">    if (taskGraph.hasTask(release)) &#123;</span><br><span class="line">        version = &apos;1.0&apos;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        version = &apos;1.0-SNAPSHOT&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">\&gt; gradle -q distribution</span><br><span class="line">We build the zip with version=1.0-SNAPSHOT</span><br></pre></td></tr></table></figure>
<p>使用钩子taskGraph来获取build.gradle定义运行时的版本信息</p>
]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>java工具</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized解析</title>
    <url>/2019/04/26/synchronized%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>//todo </p>
<h1 id="synchronized的底层实现原理"><a href="#synchronized的底层实现原理" class="headerlink" title="synchronized的底层实现原理"></a>synchronized的底层实现原理</h1><p>Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现， 无论是显式同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。在 Java 语言中，同步用的最多的地方可能是被 synchronized 修饰的同步方法。</p>
]]></content>
      <categories>
        <category>java线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot 发送邮件</title>
    <url>/2019/04/20/spring-boort-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="使用springboot-发送邮件功能"><a href="#使用springboot-发送邮件功能" class="headerlink" title="使用springboot 发送邮件功能"></a>使用springboot 发送邮件功能</h1><p>项目结构<br><img src="/2019/04/20/spring-boort-一/construct.png" alt><br> 首先在build.gradle中加入邮件依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile group: &apos;org.springframework.boot&apos;, name: &apos;spring-boot-starter-mail&apos;, version: &apos;2.1.3.RELEASE&apos;</span><br></pre></td></tr></table></figure></p>
<p> 然后在application.properties中添加邮箱的信息，我用的是QQ邮箱，在使用QQ邮箱时要先设置，<br> 进入邮箱-&gt; 设置 -&gt;账户-&gt;POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务-&gt; 开启POP3/SMTP服务<br><img src="/2019/04/20/spring-boort-一/邮箱验证密码.png" alt><br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line">#邮箱账户</span><br><span class="line">spring.mail.username=用户名</span><br><span class="line">#这里的密码就是开通SMTP服务后上图的密码</span><br><span class="line">spring.mail.password=密码</span><br><span class="line">spring.mail.properties.mail.smtp.auth=true</span><br><span class="line">spring.mail.properties.mail.smtp.starttls.enable=true</span><br><span class="line">spring.mail.properties.mail.smtp.starttls.required=true</span><br></pre></td></tr></table></figure></p>
<p> 会根据配置文件中的内容去创建JavaMailSender实例，因此我们可以直接在需要使用的地方直接@Autowired来引入邮件发送对象。</p>
<h2 id="简单文本邮件发送"><a href="#简单文本邮件发送" class="headerlink" title="简单文本邮件发送"></a>简单文本邮件发送</h2> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class MailSendController &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据配置文件创建发送邮件的实例</span><br><span class="line">     */</span><br><span class="line">    @Autowired</span><br><span class="line">    private JavaMailSender javaMailSender;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private VelocityEngine velocityEngine;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 简单文字邮件发送</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/sendEmail&quot;)</span><br><span class="line">    public OperateResult sendEmail()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //邮件内容</span><br><span class="line">            SimpleMailMessage message = new SimpleMailMessage();</span><br><span class="line">            message.setFrom( &quot;from&quot;);</span><br><span class="line">            message.setTo( &quot;to&quot; );</span><br><span class="line">            message.setSubject( &quot;主题：简单邮件&quot; );</span><br><span class="line">            message.setText( &quot;测试邮件内容&quot; );</span><br><span class="line">            javaMailSender.send( message );</span><br><span class="line">            return OperateResult.operationSuccess( &quot;发送邮件成功&quot; );</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return OperateResult.operationFailure( e.getMessage() );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="包含附件的邮件发送"><a href="#包含附件的邮件发送" class="headerlink" title="包含附件的邮件发送"></a>包含附件的邮件发送</h2><p> 实际过程中，我们很可能会发送附件给对方<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 发送带附件的邮件</span><br><span class="line">   */</span><br><span class="line">  @PostMapping(&quot;/sendEmailFile&quot;)</span><br><span class="line">  public OperateResult sendEmailFile()&#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          //邮件内容</span><br><span class="line">          MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">          MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);</span><br><span class="line">          helper.setFrom( &quot;from&quot; );</span><br><span class="line">          helper.setTo( &quot;to&quot; );</span><br><span class="line">          helper.setSubject( &quot;主题：附件邮件&quot; );</span><br><span class="line">          helper.setText( &quot;附件邮件内容&quot; );</span><br><span class="line">	//附件我放在了resources下</span><br><span class="line">          FileSystemResource file = new FileSystemResource(new File(Thread.currentThread().getContextClassLoader().getResource(&quot;test.jpg&quot;).getFile()));</span><br><span class="line">          helper.addAttachment(&quot;附件-1.jpg&quot;, file);</span><br><span class="line">          helper.addAttachment(&quot;附件-2.jpg&quot;, file);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          javaMailSender.send( mimeMessage );</span><br><span class="line">          return OperateResult.operationSuccess( &quot;发送邮件成功&quot; );</span><br><span class="line">      &#125;catch (Exception e)&#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          return OperateResult.operationFailure( e.getMessage() );</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="潜入静态资源的邮件"><a href="#潜入静态资源的邮件" class="headerlink" title="潜入静态资源的邮件"></a>潜入静态资源的邮件</h2> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/sendEmailQuiet&quot;)</span><br><span class="line"> public OperateResult sendEmailQuiet()&#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         //邮件内容</span><br><span class="line">         MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">         MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);</span><br><span class="line">         helper.setFrom( &quot;from&quot; );</span><br><span class="line">         helper.setTo( &quot;to&quot; );</span><br><span class="line">         helper.setSubject( &quot;主题：嵌入静态资源邮件&quot; );</span><br><span class="line">         helper.setText( &quot;嵌入静态资源邮件邮件内容&quot; );</span><br><span class="line">         helper.setText(&quot;&lt;html&gt;&lt;body&gt;&lt;img src=\&quot;cid:test\&quot; &gt;&lt;/body&gt;&lt;/html&gt;&quot;, true);</span><br><span class="line"></span><br><span class="line">         FileSystemResource file = new FileSystemResource(new File(Thread.currentThread().getContextClassLoader().getResource(&quot;test.jpg&quot;).getFile()));</span><br><span class="line">         helper.addInline(&quot;test&quot;, file);</span><br><span class="line">         javaMailSender.send( mimeMessage );</span><br><span class="line">         return OperateResult.operationSuccess( &quot;发送邮件成功&quot; );</span><br><span class="line">     &#125;catch (Exception e)&#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">         return OperateResult.operationFailure( e.getMessage() );</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="发送模板邮件"><a href="#发送模板邮件" class="headerlink" title="发送模板邮件"></a>发送模板邮件</h2><p> 项目中引入模板的依赖<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//        邮件嵌入静态资源</span><br><span class="line">       compile group: &apos;org.springframework.boot&apos;, name: &apos;spring-boot-starter-velocity&apos;, version: &apos;1.4.7.RELEASE&apos;</span><br></pre></td></tr></table></figure></p>
<p> 在路径resources/templates/下，创建一个模板页面template.vm，内容如下<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h3&gt;你好， $&#123;username&#125;, 这是一封模板邮件!&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p> 发送模板的邮件<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/sendEmailQuiet&quot;)</span><br><span class="line">   public OperateResult sendEmailQuiet()&#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           //邮件内容</span><br><span class="line">           MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">           MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);</span><br><span class="line">           helper.setFrom( &quot;from&quot; );</span><br><span class="line">           helper.setTo( &quot;to&quot; );</span><br><span class="line">           helper.setSubject( &quot;主题：嵌入静态资源邮件&quot; );</span><br><span class="line">           helper.setText( &quot;嵌入静态资源邮件邮件内容&quot; );</span><br><span class="line">           helper.setText(&quot;&lt;html&gt;&lt;body&gt;&lt;img src=\&quot;cid:test\&quot; &gt;&lt;/body&gt;&lt;/html&gt;&quot;, true);</span><br><span class="line"></span><br><span class="line">           FileSystemResource file = new FileSystemResource(new File(Thread.currentThread().getContextClassLoader().getResource(&quot;test.jpg&quot;).getFile()));</span><br><span class="line">           helper.addInline(&quot;test&quot;, file);</span><br><span class="line">           javaMailSender.send( mimeMessage );</span><br><span class="line">           return OperateResult.operationSuccess( &quot;发送邮件成功&quot; );</span><br><span class="line">       &#125;catch (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           return OperateResult.operationFailure( e.getMessage() );</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">``</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot web模板引擎和统一异常处理</title>
    <url>/2019/04/20/spring-boot%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="spring-boot-模板引擎"><a href="#spring-boot-模板引擎" class="headerlink" title="spring boot 模板引擎"></a>spring boot 模板引擎</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;在我们开发Web应用的时候，需要引用大量的js、css、图片等静态资源。在动态HTML实现上Spring Boot依然可以完美胜任，并且提供了多种模板引擎的默认配置支持，所以在推荐的模板引擎下，我们可以很快的上手开发动态网站。<br>Spring Boot提供了默认配置的模板引擎主要有以下几种：<br>&nbsp;&nbsp;&nbsp;&nbsp;ymeleaf<br>&nbsp;&nbsp;&nbsp;&nbsp;FreeMarker<br>&nbsp;&nbsp;&nbsp;&nbsp;Velocity<br>&nbsp;&nbsp;&nbsp;&nbsp;Groovy<br>&nbsp;&nbsp;&nbsp;&nbsp;Mustache<br>当你使用上述模板引擎中的任何一个，它们默认的模板配置路径为：src/main/resources/templates。当然也可以修改这个路径，具体如何修改，可在后续各模板引擎的配置属性中查询并修改。</p>
<h2 id="使用Thymeleaf的示例"><a href="#使用Thymeleaf的示例" class="headerlink" title="使用Thymeleaf的示例"></a>使用Thymeleaf的示例</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Thymeleaf是一个XML/XHTML/HTML5模板引擎，可用于Web与非Web环境中的应用开发。它是一个开源的Java库，基于Apache License 2.0许可，由Daniel Fernández创建，该作者还是Java加密库Jasypt的作者。<br>&nbsp;&nbsp;&nbsp;&nbsp;Thymeleaf提供了一个用于整合Spring MVC的可选模块，在应用开发中，你可以使用Thymeleaf来完全代替JSP或其他模板引擎，如Velocity、FreeMarker等。Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的XML与HTML模板。相对于编写逻辑或代码，开发者只需将标签属性添加到模板中即可。接下来，这些标签属性就会在DOM（文档对象模型）上执行预先制定好的逻辑。<br>&nbsp;&nbsp;&nbsp;&nbsp;在Spring Boot中使用Thymeleaf，只需要引入下面依赖，并在默认的模板路径src/main/resources/templates下编写模板文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile group: &apos;org.springframework.boot&apos;, name: &apos;spring-boot-starter-thymeleaf&apos;, version: &apos;2.0.6.RELEASE&apos;</span><br></pre></td></tr></table></figure></p>
<p>在完成配置之后，举一个简单的例子，在快速入门工程的基础上，举一个简单的示例来通过Thymeleaf渲染一个页面。使用的是@Controller而不是@RestController 因为@RestController是@ReponseBody和@Controller，发布会的结果默认是JSON格式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @RequestMapping(&quot;/&quot;)</span><br><span class="line">    public String index(ModelMap map) &#123;</span><br><span class="line">        // 加入一个属性，用来在模板中读取</span><br><span class="line">        map.addAttribute(&quot;host&quot;, &quot;  应该替换成的文字&quot;);</span><br><span class="line">        // return模板文件的名称，对应src/main/resources/templates/index.html</span><br><span class="line">        return &quot;index&quot;;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在templates下创建一个 index.html文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang=&quot;en&quot;&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1 th:text=&quot;$&#123;host&#125;&quot;&gt;为被替换的文字&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>springboot的默认配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#thymeleaf的默认配置</span><br><span class="line"># Enable template caching.</span><br><span class="line">spring.thymeleaf.cache=true</span><br><span class="line"># Check that the templates location exists.</span><br><span class="line">spring.thymeleaf.check-template-location=true</span><br><span class="line"># Content-Type value.</span><br><span class="line">spring.thymeleaf.content-type=text/html</span><br><span class="line"># Enable MVC Thymeleaf view resolution.</span><br><span class="line">spring.thymeleaf.enabled=true</span><br><span class="line"># Template encoding.</span><br><span class="line">spring.thymeleaf.encoding=UTF-8 </span><br><span class="line"># Comma-separated list of view names that should be excluded from resolution.</span><br><span class="line">spring.thymeleaf.excluded-view-names=</span><br><span class="line"># Template mode to be applied to templates. See also StandardTemplateModeHandlers.</span><br><span class="line">spring.thymeleaf.mode=HTML5</span><br><span class="line"># Prefix that gets prepended to view names when building a URL.</span><br><span class="line">spring.thymeleaf.prefix=classpath:/templates/</span><br><span class="line"># Suffix that gets appended to view names when building a URL.</span><br><span class="line">spring.thymeleaf.suffix=.html</span><br><span class="line">#spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain. spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved.</span><br></pre></td></tr></table></figure></p>
<p>这个时候运行成功后访问localhost:port  就可以看见页面上的内容</p>
<h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>自定义异常<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyException extends Exception &#123;</span><br><span class="line">    public MyException(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建全局异常处理类：通过使用@ControllerAdvice定义统一的异常处理类，而不是在每个Controller中逐个定义。@ExceptionHandler用来定义函数针对的异常类型，最后将Exception对象和请求URL映射到error.html中<br>船舰异常的处理类，@ExceptionHandler是标识这个方法是处理什么类型的异常<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ControllerAdvice</span><br><span class="line">class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    public static final String DEFAULT_ERROR_VIEW = &quot;error&quot;;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(value = NullPointerException.class)</span><br><span class="line">    public ModelAndView defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception &#123;</span><br><span class="line">        ModelAndView mav = new ModelAndView();</span><br><span class="line">        mav.addObject(&quot;exception&quot;, e);</span><br><span class="line">        mav.addObject(&quot;url&quot;, req.getRequestURL());</span><br><span class="line">        mav.setViewName(DEFAULT_ERROR_VIEW);</span><br><span class="line">        return mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现error.html页面展示：在templates目录下创建error.html，将请求的URL和Exception对象的message输出。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:th=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span><br><span class="line">&lt;head lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;统一异常处理&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Error Handler&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;url: $&#123;url&#125;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt;message:$&#123;exception&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>创建一个抛出异常的请求<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/json&quot;)</span><br><span class="line">   public String  json() throws MyException &#123;</span><br><span class="line">       throw new MyException(&quot;发生错误2&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候请求/json方法，就会返回error界面，并显示出错误的请求路径和错误信息<br>如果需要返回的是JSON类型的格式，只需要返回的加上@ReponseBody注解<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">异常信息类</span><br><span class="line">public class ErrorInfo&lt;T&gt; &#123;</span><br><span class="line">    public static final Integer OK = 0;</span><br><span class="line">    public static final Integer ERROR = 100;</span><br><span class="line">    private Integer code;</span><br><span class="line">    private String message;</span><br><span class="line">    private String url;</span><br><span class="line">    private T data;</span><br><span class="line">    // 省略getter和setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在异常处理方法中改写为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ExceptionHandler(value = MyException.class)</span><br><span class="line">@ResponseBody  //这个注解是返回JSON格式</span><br><span class="line">public ErrorInfo&lt;String&gt; defaultErrorHandler(HttpServletRequest req,MyException e) throws Exception &#123;</span><br><span class="line">    ErrorInfo&lt;String&gt; r = new ErrorInfo&lt;&gt;();</span><br><span class="line">    r.setMessage(e.getMessage());</span><br><span class="line">    r.setCode(ErrorInfo.ERROR);</span><br><span class="line">    r.setData(&quot;Some Data&quot;);</span><br><span class="line">    r.setUrl(req.getRequestURL().toString());</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot localDate等时间序列化异常</title>
    <url>/2019/04/20/spring-boot%E4%B8%89/</url>
    <content><![CDATA[<h1 id="普通时间的序列化"><a href="#普通时间的序列化" class="headerlink" title="普通时间的序列化"></a>普通时间的序列化</h1><p>@nbsp;@nbsp;@nbsp;@nbsp;LocalDate、LocalTime、LocalDateTime是Java 8开始提供的时间日期API，然而我们在使用Spring Boot或使用Spring Cloud Feign的时候会出现各种问题<br>以前使用的Date只需要添加注解下面的注解，就能够在前后端以JSON格式传输<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)</span><br><span class="line">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span><br><span class="line">private Date date ;</span><br></pre></td></tr></table></figure></p>
<p>如果使用了LocalDate等类型，在传输数据就会报错JSON parse error: Can not construct instance of java.time.LocalDate<br>因为默认情况下Spring MVC对于LocalDate序列化成了一个数组类型，而Feign在调用的时候，还是按照ArrayList来处理，所以自然无法反序列化为LocalDate对象了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;date&quot;:[2019,1,1]</span><br></pre></td></tr></table></figure></p>
<p>解决办法：<br>先引入jackson-datatype-jsr310依赖，再在启动类中加入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//      依赖中加入localDate时间转化依赖</span><br><span class="line">compile group: &apos;com.fasterxml.jackson.datatype&apos;, name: &apos;jackson-datatype-jsr310&apos;, version: &apos;2.9.8&apos;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">//		在启动类中添加</span><br><span class="line">@Bean</span><br><span class="line">public ObjectMapper serializingObjectMapper() &#123;</span><br><span class="line">    ObjectMapper objectMapper = new ObjectMapper();</span><br><span class="line">    objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span><br><span class="line">    objectMapper.registerModule(new JavaTimeModule());</span><br><span class="line">    return objectMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>java-IOandNIO（四）</title>
    <url>/2019/04/18/java-IOandNIO%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="一、通道Channel"><a href="#一、通道Channel" class="headerlink" title="一、通道Channel"></a>一、通道Channel</h1><p>&ensp;&ensp;&ensp;&ensp;通道既不是一个扩展也不是一项增强，而是全新的、极好的Java I/O示例，提供与I/O服务的直接连接。Channel用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据。<br>&ensp;&ensp;&ensp;&ensp;通道是一种途径，缓存区是通道内部的数据发送和接收的单位。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Channel extends Closeable &#123;</span><br><span class="line">    public boolean isOpen();</span><br><span class="line">    public void close() throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Channel接口里面有两个接口，isOpen()是判断通道是否打开，close()是关闭通道的接口</p>
<h1 id="二、通道的基本接口"><a href="#二、通道的基本接口" class="headerlink" title="二、通道的基本接口"></a>二、通道的基本接口</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//只读通道接口</span><br><span class="line">public interface ReadableByteChannel extends Channel &#123;</span><br><span class="line">    public int read(ByteBuffer dst) throws IOException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//写入通道接口</span><br><span class="line">public interface WritableByteChannel extends Channel &#123;</span><br><span class="line">	    public int write(ByteBuffer src) throws IOException;</span><br><span class="line">&#125;</span><br><span class="line">//读写通道</span><br><span class="line">public interface ByteChannel extends ReadableByteChannel, WritableByteChannel &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;通道有阻塞和非阻塞模式，非阻塞模式的通道不会造成线程休眠，要么完成，要么返回状态。只有流的通道(如sockets、pipes)，才可以使用非阻塞的模式<br>下方是SocketChannel<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class SocketChannel</span><br><span class="line">    extends AbstractSelectableChannel</span><br><span class="line">    implements ByteChannel, ScatteringByteChannel, GatheringByteChannel&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">public abstract class AbstractSelectableChannel</span><br><span class="line">    extends SelectableChannel</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，socket通道类从SelectableChannel类引申而来，从SelectableChannel引申而来的类可以和支持有条件的选择的选择器（Selectors）一起使用。将非阻塞I/O和选择器组合起来可以使开发者的程序利用多路复用I/O</p>
<h1 id="三、使用文件通道读写数据"><a href="#三、使用文件通道读写数据" class="headerlink" title="三、使用文件通道读写数据"></a>三、使用文件通道读写数据</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">    File file = new File(&quot;D:/files/readchannel.txt&quot;);</span><br><span class="line">    FileInputStream fis = new FileInputStream(file);</span><br><span class="line">    FileChannel fc = fis.getChannel();</span><br><span class="line">    ByteBuffer bb = ByteBuffer.allocate(35);</span><br><span class="line">    fc.read(bb);</span><br><span class="line">    bb.flip();</span><br><span class="line">    while (bb.hasRemaining())</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print((char)bb.get());</span><br><span class="line">    &#125;</span><br><span class="line">    bb.clear();</span><br><span class="line">    fc.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">    File file = new File(&quot;D:/files/writechannel.txt&quot;);</span><br><span class="line">    RandomAccessFile raf = new RandomAccessFile(file, &quot;rw&quot;);</span><br><span class="line">    FileChannel fc = raf.getChannel();</span><br><span class="line">    ByteBuffer bb = ByteBuffer.allocate(10);</span><br><span class="line">    String str = &quot;abcdefghij&quot;;</span><br><span class="line">    bb.put(str.getBytes());</span><br><span class="line">    bb.flip();</span><br><span class="line">    fc.write(bb);</span><br><span class="line">    bb.clear();</span><br><span class="line">    fc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用了RandomAccessFile去获取FileChannel，然后操作其实差不多，write方法写ByteBuffer中的内容至文件中，注意写之前还是要先把ByteBuffer给flip一下。可能有人觉得这种连续put的方法非常不方便，但是没有办法，之前已经提到过了：通道只能使用ByteBuffer。</p>
]]></content>
      <categories>
        <category>java NIO</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>io/nio</tag>
      </tags>
  </entry>
  <entry>
    <title>java-IOandNIO（三）</title>
    <url>/2019/04/17/java-IOandNIO%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="缓冲区Buffer解析"><a href="#缓冲区Buffer解析" class="headerlink" title="缓冲区Buffer解析"></a>缓冲区Buffer解析</h1><p>&ensp;&ensp;&ensp;&ensp;NIO中有两个核心对象，通道和缓冲区。缓冲区的本质是一个数组，其中添加了三个属性跟踪缓冲区的内部状态变化。其实就是STL库中Vector的设计。<br><strong>position</strong>：指定了下一个将要被写入或者读取的元素索引，它的值由get()/put()方法自动更新，在新创建一个Buffer对象时，position被初始化为0。<br><strong>limit</strong>：指定还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。<br><strong>capacity</strong>：指定了可以存储在缓冲区中的最大数据容量，实际上，它指定了底层数组的大小，或者至少是指定了准许我们使用的底层数组的容量。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  public static void main(String[] args) throws Exception&#123;</span><br><span class="line">      FileInputStream fin = new FileInputStream(&quot;c:\\test.txt&quot;);</span><br><span class="line">//获取通道连接</span><br><span class="line">      FileChannel fc = fin.getChannel();</span><br><span class="line">//初始化大小为10byte的缓冲区</span><br><span class="line">      ByteBuffer buffer = ByteBuffer.allocate(10);</span><br><span class="line">//通道读取缓冲区数据，此时 position =10,limit=10,capacity=10</span><br><span class="line">      fc.read(buffer);</span><br><span class="line">//从缓冲区读取数据前.position =0,limit =10;</span><br><span class="line">      buffer.flip();</span><br><span class="line">//get()使position递增而limit不变</span><br><span class="line">      while (buffer.remaining() &gt; 0) &#123;</span><br><span class="line">          byte b = buffer.get();</span><br><span class="line">          // System.out.print(((char)b));</span><br><span class="line">      &#125;</span><br><span class="line">//将状态回复到初始的状态</span><br><span class="line">      buffer.clear();</span><br><span class="line">      fin.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>缓冲区的分配其实就是一个数组形式的数据分配，使用了allocate来指定缓冲区的容量。<br>缓冲区的分片，在原本的缓存区对象上切出一片来创建一个子缓冲区，但是新的缓冲区其实和原缓冲区在切出的区域上是数据共享的，勇slice方法创建一个子缓冲区。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(10);</span><br><span class="line">//在缓冲区中放入0-9</span><br><span class="line">for (int i=0; i&lt;buffer.capacity(); i++) &#123;</span><br><span class="line">        buffer.put( (byte)i );</span><br><span class="line">&#125;</span><br><span class="line">//在缓冲区中下标3-7的地方设置为子缓冲区</span><br><span class="line">buffer.position(3);</span><br><span class="line">buffer.limit(7);</span><br><span class="line">ByteBuffer slice = buffer.slice();</span><br><span class="line">//改编子缓冲区的内容</span><br><span class="line">for (int i=0; i&lt;slice.capacity(); i++) &#123;</span><br><span class="line">    byte b = slice.get( i );</span><br><span class="line">    b *= 10;</span><br><span class="line">    slice.put( i, b );</span><br><span class="line">&#125;</span><br><span class="line">//自缓冲区的内容改变，原缓存区的数据也改变</span><br><span class="line">//还原原缓存区的初始位置position和limit</span><br><span class="line">buffer.position( 0 );</span><br><span class="line">buffer.limit( buffer.capacity() );</span><br><span class="line">while (buffer.remaining()&gt;0) &#123;</span><br><span class="line">    System.out.println( buffer.get() );</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(&quot;\n&quot;);</span><br></pre></td></tr></table></figure></p>
<p>缓存区分片同样可以创建只读缓冲区，可以通过调用缓冲区的asReadOnlyBuffer()方法，将任何常规缓冲区转 换为只读缓冲区，这个方法返回一个与原缓冲区完全相同的缓冲区，并与原缓冲区共享数据，只不过它是只读的。如果原缓冲区的内容发生了变化，只读缓冲区的内容也随之发生变化。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 10 );</span><br><span class="line">// 缓冲区中的数据0-9</span><br><span class="line">for (int i=0; i&lt;buffer.capacity(); ++i) &#123;</span><br><span class="line">    buffer.put( (byte)i );</span><br><span class="line">&#125;</span><br><span class="line">// 创建只读缓冲区</span><br><span class="line">ByteBuffer readonly = buffer.asReadOnlyBuffer();</span><br><span class="line">// 改变原缓冲区的内容</span><br><span class="line">for (int i=0; i&lt;buffer.capacity(); ++i) &#123;</span><br><span class="line">    byte b = buffer.get( i );</span><br><span class="line">    b *= 10;</span><br><span class="line">    buffer.put( i, b );</span><br><span class="line">&#125;</span><br><span class="line">readonly.position(0);</span><br><span class="line">readonly.limit(buffer.capacity());</span><br><span class="line">// 只读缓冲区的内容也随之改变</span><br><span class="line">while (readonly.remaining()&gt;0) &#123;</span><br><span class="line">    System.out.println( readonly.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>java NIO</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>io/nio</tag>
      </tags>
  </entry>
  <entry>
    <title>java-IOandNIO（二）</title>
    <url>/2019/04/17/java-IOandNIO%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>&ensp;&ensp;&ensp;&ensp;从java1.4开始提供了NIO的新特性，NIO与IO的目的相同，NIO有三个核心对象缓冲区(Buffer)、通道(chanel)、选择器(selector)<br>&ensp;&ensp;&ensp;&ensp;IO的方式与NIO方式的不同: I/O是以字节为单位处理数据，NIO是以代码块的方式处理数据,处理效率比按流的方式高许多。</p>
<h1 id="二、缓冲区Buffer"><a href="#二、缓冲区Buffer" class="headerlink" title="二、缓冲区Buffer"></a>二、缓冲区Buffer</h1><p>缓冲区是一个可指定大小的对象，NIO的所有数据都是以缓冲区的方式处理，读写数据都是在缓冲区Buffer中进行额。而在流的I/O中，数据都是写入到Stream<br><img src="/2019/04/17/java-IOandNIO（二）/buffer.jpg" alt><br>&ensp;&ensp;&ensp;&ensp;一个客户端像服务端发送数据，先将数据放入缓冲区(Buffer)，然后见缓冲区的数据写入到通道(Channel)，服务端将从通道接收数据，写入缓冲区后再从缓冲区中取出。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.nio.IntBuffer;</span><br><span class="line">public class TestIntBuffer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 分配新的int缓冲区，参数为缓冲区容量</span><br><span class="line">        // 新缓冲区的当前位置将为零，其界限(限制位置)将为其容量。它将具有一个底层实现数组，其数组偏移量将为零。</span><br><span class="line">        IntBuffer buffer = IntBuffer.allocate(8);</span><br><span class="line">        for (int i = 0; i &lt; buffer.capacity(); ++i) &#123;</span><br><span class="line">            int j = 2 * (i + 1);</span><br><span class="line">            // 将给定整数写入此缓冲区的当前位置，当前位置递增</span><br><span class="line">            buffer.put(j);</span><br><span class="line">        &#125;</span><br><span class="line">        // 重设此缓冲区，将限制设置为当前位置，然后将当前位置设置为0</span><br><span class="line">        buffer.flip();</span><br><span class="line">        // 查看在当前位置和限制位置之间是否有元素</span><br><span class="line">        while (buffer.hasRemaining()) &#123;</span><br><span class="line">            // 读取此缓冲区当前位置的整数，然后当前位置递增</span><br><span class="line">            int j = buffer.get();</span><br><span class="line">            System.out.print(j + &quot;  &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="三、通道Channel"><a href="#三、通道Channel" class="headerlink" title="三、通道Channel"></a>三、通道Channel</h1><p>&ensp;&ensp;&ensp;&ensp;Channel和传统的IO的stream流功能相似，但是stream是单向操作的，InputSteam或则OutputStream。而channel是双向的。<br>&ensp;&ensp;&ensp;&ensp;通道Channel也是一个对象，通过它可以读取和写入数据，再Channel里面通过Buffer来存放数据，Channel读取缓冲区(Buffer)来获取这个数据。<br>&ensp;&ensp;&ensp;&ensp;Channel(通道)表示到实体如硬件设备、文件、网络套接字或可以执行一个或多个不同I/O操作的程序组件的开放的连接。所有的Channel都不是通过构造器创建的，而是通过传统的节点InputStream、OutputStream的getChannel方法来返回响应的Channel。Channel中最常用的三个类方法就是map、read和write，其中map方法用于将Channel对应的部分或全部数据映射成ByteBuffer，而read或write方法有一系列的重载形式，这些方法用于从Buffer中读取数据或向Buffer中写入数据。<br>下面是NIO的使用例子：使用NIO获取数据大致可以分为三步<br>(1). 从FileInputStream获取Channel<br>(2). 创建Buffer<br>(3). 将数据从Channel读取到Buffer中<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//NIO读取数据</span><br><span class="line">    public static void main( String args[] ) throws Exception &#123;  </span><br><span class="line">        FileInputStream fin = new FileInputStream(&quot;c:\\test.txt&quot;);  </span><br><span class="line">        // 获取通道  </span><br><span class="line">        FileChannel fc = fin.getChannel();  </span><br><span class="line">        // 创建缓冲区  </span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(1024);  </span><br><span class="line">        // 读取数据到缓冲区  </span><br><span class="line">        fc.read(buffer);  </span><br><span class="line">        buffer.flip();  </span><br><span class="line">        while (buffer.remaining()&gt;0) &#123;  </span><br><span class="line">            byte b = buffer.get();  </span><br><span class="line">            System.out.print(((char)b));  </span><br><span class="line">        &#125;  </span><br><span class="line">        fin.close();  </span><br><span class="line">    &#125;  </span><br><span class="line">//NIO写入数据</span><br><span class="line"> private static final byte message[] = &#123; 83, 111, 109, 101, 32,</span><br><span class="line">        98, 121, 116, 101, 115, 46 &#125;;</span><br><span class="line"></span><br><span class="line">    public static void main( String args[] ) throws Exception &#123;</span><br><span class="line">        FileOutputStream fout = new FileOutputStream( &quot;c:\\test.txt&quot; );</span><br><span class="line">        </span><br><span class="line">        FileChannel fc = fout.getChannel();</span><br><span class="line">        </span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">        </span><br><span class="line">        for (int i=0; i&lt;message.length; ++i) &#123;</span><br><span class="line">            buffer.put( message[i] );</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        buffer.flip();</span><br><span class="line">        </span><br><span class="line">        fc.write( buffer );</span><br><span class="line">        </span><br><span class="line">        fout.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="四、选择器"><a href="#四、选择器" class="headerlink" title="四、选择器"></a>四、选择器</h1><p>&ensp;&ensp;&ensp;&ensp;Selector类是NIO的核心类，Selector能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。<br>&ensp;&ensp;&ensp;&ensp;与Selector有关的一个关键类是SelectionKey，一个SelectionKey表示一个到达的事件，这2个类构成了服务端处理业务的关键逻辑。</p>
]]></content>
      <categories>
        <category>java NIO</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>io/nio</tag>
      </tags>
  </entry>
  <entry>
    <title>java  IO模型</title>
    <url>/2019/04/15/javaIO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="一、同步和异步"><a href="#一、同步和异步" class="headerlink" title="一、同步和异步"></a>一、同步和异步</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>同步</strong>：同步方法一旦开始，必须等到方法执行完毕，才能继续执行后面的行为，比如java中的synchronized关键字的使用。<br>&ensp;&ensp;&ensp;&ensp;<strong>异步</strong>：异步方法开始之后，调用者不必等待返回结果，可以继续执行下一步。<br>&ensp;&ensp;&ensp;&ensp;同步一般在执行的过程中使整个流程暂停等待，而异步的方法则在执行的时候不影响其他线程，所以异步一般是通过多线程来实现的。<br>&ensp;&ensp;&ensp;&ensp;事实上，同步和异步是一个非常广的概念，它们的重点在于多个任务和事件发生时，一个事件的发生或执行是否会导致整个流程的暂时等待。我觉得可以将同步和异步与Java中的synchronized关键字联系起来进行类比。当多个线</p>
<h1 id="二、阻塞和非阻塞"><a href="#二、阻塞和非阻塞" class="headerlink" title="二、阻塞和非阻塞"></a>二、阻塞和非阻塞</h1><p>&ensp;&ensp;&ensp;&ensp;介绍了同步和异步的区别，来看一下阻塞和非阻塞的区别。<br>&ensp;&ensp;&ensp;&ensp;<strong>阻塞</strong>就是：当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；<br>&ensp;&ensp;&ensp;&ensp;<strong>非阻塞</strong>就是：当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。<br>这就是阻塞和非阻塞的区别。也就是说阻塞和非阻塞的区别关键在于当发出请求一个操作时，如果条件不满足，是会一直等待还是返回一个标志信息。<br>同步和异步着重点在于多个任务的执行过程中，一个任务的执行是否会导致整个流程的暂时等待；<br>而阻塞和非阻塞着重点在于发出一个请求操作时，如果进行操作的条件不满足是否会返会一个标志信息告知条件不满足。<br>理解阻塞和非阻塞可以同线程阻塞类比地理解，当一个线程进行一个请求操作时，如果条件不满足，则会被阻塞，即在那等待条件满足。</p>
<h1 id="三、阻塞IO与非阻塞IO"><a href="#三、阻塞IO与非阻塞IO" class="headerlink" title="三、阻塞IO与非阻塞IO"></a>三、阻塞IO与非阻塞IO</h1><p>在了解阻塞IO和非阻塞IO之前，先看下一个具体的IO操作过程是怎么进行的。<br>通常来说，IO操作包括：对硬盘的读写、对socket的读写以及外设的读写。<br>当用户线程发起一个IO请求操作（本文以读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：<br>&ensp;&ensp;&ensp;&ensp;1）查看数据是否就绪；<br>&ensp;&ensp;&ensp;&ensp;2）进行数据拷贝（内核将数据拷贝到用户线程）。<br>&ensp;&ensp;&ensp;&ensp;那么阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。<br>&ensp;&ensp;&ensp;&ensp;Java中传统的IO都是阻塞IO，比如通过socket来读数据，调用read()方法之后，如果数据没有就绪，当前线程就会一直阻塞在read方法调用那里，直到有数据才返回；而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直在那里等待。</p>
<h1 id="四、同步IO与异步IO"><a href="#四、同步IO与异步IO" class="headerlink" title="四、同步IO与异步IO"></a>四、同步IO与异步IO</h1><p>我们先来看一下同步IO和异步IO的定义，在《Unix网络编程》一书中对同步IO和异步IO的定义是这样的：<br>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes.<br>An asynchronous I/O operation does not cause the requesting process to be blocked.<br>从字面的意思可以看出：同步IO即 如果一个线程请求进行IO操作，在IO操作完成之前，该线程会被阻塞；<br>而异步IO为 如果一个线程请求进行IO操作，IO操作不会导致请求线程被阻塞。<br>事实上，同步IO和异步IO模型是针对用户线程和内核的交互来说的：<br>对于同步IO：当用户发出IO请求操作之后，如果数据没有就绪，需要通过用户线程或者内核不断地去轮询数据是否就绪，当数据就绪时，再将数据从内核拷贝到用户线程；<br>而异步IO：只有IO请求操作的发出是由用户线程来进行的，IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成。也就是说在异步IO中，不会对用户线程产生任何阻塞。<br>这是同步IO和异步IO关键区别所在，同步IO和异步IO的关键区别反映在数据拷贝阶段是由用户线程完成还是内核完成。所以说异步IO必须要有操作系统的底层支持。<br>阻塞IO和非阻塞IO是反映在当用户请求IO操作时，如果数据没有就绪，是用户线程一直等待数据就绪，还是会收到一个标志信息这一点上面的。也就是说，阻塞IO和非阻塞IO是反映在IO操作的第一个阶段，在查看数据是否就绪时是如何处理的。</p>
<h1 id="五、五种IO模型"><a href="#五、五种IO模型" class="headerlink" title="五、五种IO模型"></a>五、五种IO模型</h1><p>在《Unix网络编程》一书中提到了五种IO模型，分别是：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO以及异步IO</p>
<h2 id="1、阻塞IO模型"><a href="#1、阻塞IO模型" class="headerlink" title="1、阻塞IO模型"></a>1、阻塞IO模型</h2><p>典型的IO模型例子，就是在读/写操作中阻塞<br>当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU，当数据就绪后，内核将数据拷贝到用户线程，此时用户线程解除LOCK的状态。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">data = socket.read();</span><br></pre></td></tr></table></figure></p>
<p>如果数据一直没准备好，线程就会一直阻塞在read()</p>
<h2 id="2、非阻塞IO模型"><a href="#2、非阻塞IO模型" class="headerlink" title="2、非阻塞IO模型"></a>2、非阻塞IO模型</h2><p>当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。<br>所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。典型的非阻塞IO模型一般如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(true)&#123; </span><br><span class="line">    data = socket.read(); </span><br><span class="line">    if(data!= error)&#123; </span><br><span class="line">        处理数据 </span><br><span class="line">        break; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3、多路复用IO模型"><a href="#3、多路复用IO模型" class="headerlink" title="3、多路复用IO模型"></a>3、多路复用IO模型</h2><p>&ensp;&ensp;&ensp;&ensp;多路复用IO模型是目前使用得比较多的模型。Java NIO实际上就是多路复用IO。<br>在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。<br>在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。<br>多路复用IO模式，通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。<br>另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态是通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。<br>不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询</p>
<h2 id="4、信号驱动IO模型"><a href="#4、信号驱动IO模型" class="headerlink" title="4、信号驱动IO模型"></a>4、信号驱动IO模型</h2><p>&ensp;&ensp;&ensp;&ensp;在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。</p>
<h2 id="5、异步的IO模型"><a href="#5、异步的IO模型" class="headerlink" title="5、异步的IO模型"></a>5、异步的IO模型</h2><p>&ensp;&ensp;&ensp;&ensp;异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它收到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要知道实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。<br>&ensp;&ensp;&ensp;&ensp;也就说在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用iO函数进行实际的读写操作。<br>&ensp;&ensp;&ensp;&ensp;注意，异步IO是需要操作系统的底层支持，在Java 7中，提供了Asynchronous IO。</p>
<h1 id="六、高性能的IO设计"><a href="#六、高性能的IO设计" class="headerlink" title="六、高性能的IO设计"></a>六、高性能的IO设计</h1><p>&ensp;&ensp;&ensp;&ensp;在传统的网络服务设计模式中，有两种比较经典的模式：一种是 多线程，一种是线程池。对于多线程模式，也就说来了client，服务器就会新建一个线程来处理该client的读写事件，如下图所示：<br><img src="/2019/04/15/javaIO模型/manyThread.jpg" alt><br>&ensp;&ensp;&ensp;&ensp;因此，为了解决这种一个线程对应一个客户端模式带来的问题，提出了采用线程池的方式，也就说创建一个固定大小的线程池，来一个客户端，就从线程池取一个空闲线程来处理，当客户端处理完读写操作之后，就交出对线程的占用。因此这样就避免为每一个客户端都要创建线程带来的资源浪费，使得线程可以重用<br>&ensp;&ensp;&ensp;&ensp;在Reactor模式中，会先对每个client注册感兴趣的事件，然后有一个线程专门去轮询每个client是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理完之后，便再转去继续轮询，如下图所示：<br><img src="/2019/04/15/javaIO模型/react.jpg" alt><br>&ensp;&ensp;&ensp;&ensp;从这里可以看出，上面的五种IO模型中的多路复用IO就是采用Reactor模式。注意，上面的图中展示的 是顺序处理每个事件，当然为了提高事件处理速度，可以通过多线程或者线程池的方式来处理事件</p>
]]></content>
      <categories>
        <category>java NIO</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>io/nio</tag>
      </tags>
  </entry>
  <entry>
    <title>java IO与NIO的区别（一）</title>
    <url>/2019/04/15/java-IOandNIO%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p>NIO即New IO，这个库是在JDK1.4中才引入的。NIO和IO有相同的作用和目的，但实现方式不同，NIO主要用到的是块，所以NIO的效率要比IO高很多。在Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。</p>
<h1 id="二、IO和NIO的对比区别"><a href="#二、IO和NIO的对比区别" class="headerlink" title="二、IO和NIO的对比区别"></a>二、IO和NIO的对比区别</h1><table>
<thead>
<tr>
<th style="text-align:center">IO</th>
<th style="text-align:center">NIO</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">面向流</td>
<td style="text-align:center">面向缓冲</td>
</tr>
<tr>
<td style="text-align:center">阻塞IO</td>
<td style="text-align:center">非阻塞IO</td>
</tr>
<tr>
<td style="text-align:center">无</td>
<td style="text-align:center">选择器</td>
</tr>
</tbody>
</table>
<h2 id="1、面向流与面向缓冲"><a href="#1、面向流与面向缓冲" class="headerlink" title="1、面向流与面向缓冲"></a>1、面向流与面向缓冲</h2><p>面向流的IO从流中读取一个或多个字节，直至读取完所有的字节，。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
<h2 id="2、阻塞IO与非阻塞IO"><a href="#2、阻塞IO与非阻塞IO" class="headerlink" title="2、阻塞IO与非阻塞IO"></a>2、阻塞IO与非阻塞IO</h2><p>Java IO的各种流是阻塞的。当一个线程在执行read()或write()操作时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。java NIO是非阻塞，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<h2 id="3、选择器"><a href="#3、选择器" class="headerlink" title="3、选择器"></a>3、选择器</h2><p>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</p>
<h1 id="三、NIO与IO对程序设计的影响"><a href="#三、NIO与IO对程序设计的影响" class="headerlink" title="三、NIO与IO对程序设计的影响"></a>三、NIO与IO对程序设计的影响</h1><p>使用NIO与IO的调用接口不同，使用NIO与IO的对比。<br><img src="/2019/04/15/java-IOandNIO（一）/streamAndThread.png" alt><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Name: Anna </span><br><span class="line">Age: 25</span><br><span class="line">Email: anna@mailserver.com </span><br><span class="line">Phone: 1234567890</span><br></pre></td></tr></table></figure><br>以IO的方式逐行读取文本数据<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream input = ... ; <span class="comment">// get the InputStream from the client socket   </span></span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(input));   </span><br><span class="line">String nameLine   = reader.readLine(); </span><br><span class="line">String ageLine    = reader.readLine(); </span><br><span class="line">String emailLine  = reader.readLine(); </span><br><span class="line">String phoneLine  = reader.readLine();</span><br></pre></td></tr></table></figure></p>
<p>以IO方式逐行读取每行的数据时，readLine()读取完数据之前，IO读取流被阻塞，所以第一个获取的是姓名信息，第二个readLine()获取的是年龄信息，能够确定每一步的读数据获取到的数据。以NIO的方式读取文本数据<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>); <span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buffer);</span><br></pre></td></tr></table></figure></p>
<p>在第二行中，冲通道读取字节到ByteBuffer。当这个方法调用返回时，你不知道你所需的所有数据是否在缓冲区内。你所知道的是，该缓冲区包含一些字节，这使得处理有点困难。假设第一次 read(buffer)调用后，读入缓冲区的数据只有半行，例如，“Name:An”，你能处理数据吗？显然不能，需要等待，直到整行数据读入缓存，所以，你怎么知道是否该缓冲区包含足够的数据可以处理呢？好了，你不知道。发现的方法只能查看缓冲区中的数据。其结果是，在你知道所有数据都在缓冲区里之前，你必须检查几次缓冲区的数据。这不仅效率低下，而且可以使程序设计方案杂乱不堪。例如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);   </span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buffer);   </span><br><span class="line"><span class="keyword">while</span>(! bufferFull(bytesRead) ) &#123;   </span><br><span class="line">       bytesRead = inChannel.read(buffer);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bufferFull()方法必须跟踪有多少数据读入缓冲区，并返回真或假，这取决于缓冲区是否已满。换句话说，如果缓冲区准备好被处理，那么表示缓冲区满了。bufferFull()方法扫描缓冲区，但必须保持在bufferFull（）方法被调用之前状态相同。如果没有，下一个读入缓冲区的数据可能无法读到正确的位置。这是不可能的，但却是需要注意的又一问题。如果缓冲区已满，它可以被处理。如果它不满，并且在你的实际案例中有意义，你或许能处理其中的部分数据。但是许多情况下并非如此。下图展示了“缓冲区数据循环就绪”：<br><img src="/2019/04/15/java-IOandNIO（一）/buffer.png" alt></p>
<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>NIO可以只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，实现NIO的服务器可能是一个优势。同样，如果你需要维持许多打开的连接到其他计算机上，如P2P网络中，使用一个单独的线程来管理你所有出站连接，可能是一个优势。一个线程多个连接的设计方案如下图所示：<br><img src="/2019/04/15/java-IOandNIO（一）/connection.png" alt></p>
]]></content>
      <categories>
        <category>java NIO</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>io/nio</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2019/04/15/test/</url>
    <content><![CDATA[<p><img src="/2019/04/15/test/five.jpg" alt><br><img src="/2019/04/15/test/moon.jpg" alt></p>
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>npm</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>你好，hexo</title>
    <url>/2019/04/07/%E4%BD%A0%E5%A5%BD%EF%BC%8Chexo/</url>
    <content><![CDATA[<p>hexo测试文本</p>
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>npm</tag>
        <tag>基础</tag>
      </tags>
  </entry>
</search>
