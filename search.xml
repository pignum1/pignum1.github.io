<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BeanFactory与FactoryBean</title>
    <url>/2020/07/03/BeanFactory%E4%B8%8EFactoryBean/</url>
    <content><![CDATA[<h1 id="一：简单的说"><a href="#一：简单的说" class="headerlink" title="一：简单的说"></a>一：简单的说</h1><p> BeanFactory 是接口，提供了IOC容器最基本的形式，给具体的IOC容器的实现提供了规范。</p>
<p>  FactoryBean 也是接口，为IOC容器中Bean的实现提供了更加灵活的方式，FactoryBean在IOC容器的基础上给Bean的实现加上了一个简单的工厂模式和装饰模式 ，我们可以在getObject()方法中灵活配置.</p>
<p>​    区别：BeanFaactory 是哥Factory,也就是IOC容器或对象工厂，FactoryBean是个Bean.在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。但对FactoryBean而言，<strong>这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似 .</strong></p>
<h1 id="二：复杂的说"><a href="#二：复杂的说" class="headerlink" title="二：复杂的说"></a><strong>二：复杂的说</strong></h1><p><strong>BeanFactory:</strong></p>
<p><strong>1:负责生产和管理bean的一个工厂。</strong></p>
<p><strong>2：事IOC容器的核心接口，它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象的依赖。</strong></p>
<p><strong>3：多种实现：如 DefaultListableBeanFactory、XmlBeanFactory、ApplicationContext等，其中XmlBeanFactory就是常用的一个，该实现将以XML方式描述组成应用的对象及对象间的依赖关系。</strong></p>
<p> <strong>FactoryBean
</strong></p>
<p>   FactoryBean是一个接口，当在IOC容器中的Bean实现了FactoryBean后，通过getBean(String BeanName)获取到的Bean对象并不是FactoryBean的实现类对象，而是这个实现类中的getObject()方法返回的对象。要想获取FactoryBean的实现类，就要getBean(&amp;BeanName)，在BeanName之前加上&amp;。</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>BeanFactory</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal</title>
    <url>/2020/08/17/ThreadLocal/</url>
    <content><![CDATA[<p>以前在刚想学习java的时候，在写练习的db的时候，做数据库连接池有用到ThreadLocal，只晓得是本地的线程变量，平时的业务开发中基本没有使用到。</p>
<h1 id="ThreadLocal的作用"><a href="#ThreadLocal的作用" class="headerlink" title="ThreadLocal的作用"></a>ThreadLocal的作用</h1><p>ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。每个线程都可以通过<code>set()</code>和<code>get()</code>来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，<strong>实现了线程的数据隔离</strong>。</p>
<h1 id="ThreadLocal的常用场景"><a href="#ThreadLocal的常用场景" class="headerlink" title="ThreadLocal的常用场景"></a>ThreadLocal的常用场景</h1><p>在Java的多线程编程中，为保证多个线程对共享变量的安全访问，通常会使用synchronized来保证同一时刻只有一个线程对共享变量进行操作。这种情况下可以将<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E7%B1%BB%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">类变量</a>放到ThreadLocal类型的对象中，threadLocal主要满足某些变量或者示例是线程隔离的，但是在相同线程的多个类或者方法中都能使用的到，并且当线程结束时该变量也应该销毁。常用于解决数据库连接、spring事务传播、Session管理等。</p>
<h1 id="ThreadLocal的内部原理"><a href="#ThreadLocal的内部原理" class="headerlink" title="ThreadLocal的内部原理"></a>ThreadLocal的内部原理</h1><p>jdk1.8的ThreadLocal的源码中和新方法主要是getMap()、Set()、Get()、Remove()4个核心方法。</p>
<ul>
<li>Thread 定义了ThreadLocalMap类，内部类是一个Entry继承WeakReference&lt;ThreadLocal&lt;?&gt;</li>
<li>ThreadLocalMap种存放的是每个子线程Thread持有的自己的ThreadLocalMap实例, 因此它们是不存在并发竞争的。</li>
<li><code>Entry</code>的key是对ThreadLocal的弱引用，当抛弃掉ThreadLocal对象时，垃圾收集器会忽略这个key的引用而清理掉ThreadLocal对象， 防止了内存泄漏。</li>
</ul>
<p><img src="/2020/08/17/ThreadLocal/E:/blog\source\_posts\ThreadLocal\ThreadLocalMap.png" alt></p>
<p>扩展：ThreadLocal在线程池中使用容易发生的问题： 内存泄漏</p>
<p><img src="/2020/08/17/ThreadLocal/E:/blog\source\_posts\ThreadLocal\内存泄露.png" alt></p>
<p>每个thread中都存在一个map, map的类型是ThreadLocal.ThreadLocalMap. Map中的key为一个threadlocal实例. 这个Map的确使用了弱引用,不过弱引用只是针对key. 每个key都弱引用指向threadlocal. 当把threadlocal实例置为null以后,没有任何强引用指向threadlocal实例,所以threadlocal将会被gc回收. 但是,我们的value却不能回收,因为存在一条从current thread连接过来的强引用. 只有当前thread结束以后, current thread就不会存在栈中,强引用断开, Current Thread, Map, value将全部被GC回收.</p>
<p><strong>get()方法的源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>set()方法源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>remove()方法源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>getMap()</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    return t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ThreadLocal本身并不存储值</strong>，它只是<strong>作为一个key来让线程从ThreadLocalMap获取value</strong>。</p>
<p>ThreadLocal的数据并不共享，如果想要共享线程可以使用InheritableThreadLocal</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ThreadLocal threadLocal = new InheritableThreadLocal();</span><br><span class="line">    threadLocal.set(&quot;我就试试，不进去&quot;);</span><br><span class="line">    Thread t = new Thread() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在子线程种依然可以共享父线程的传递数据，是因为在Thread的init()方法中，初始化Thread的时候蒋父线程的数据拷贝到了子线程中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void init(ThreadGroup g, Runnable target, String name,</span><br><span class="line">                  long stackSize, AccessControlContext acc,</span><br><span class="line">                  boolean inheritThreadLocals) &#123;</span><br><span class="line">    if (name == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;name cannot be null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.name = name;</span><br><span class="line"></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    if (g == null) &#123;</span><br><span class="line">        if (security != null) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">        if (g == null) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g.checkAccess();</span><br><span class="line">    if (security != null) &#123;</span><br><span class="line">        if (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.addUnstarted();</span><br><span class="line"></span><br><span class="line">    this.group = g;</span><br><span class="line">    this.daemon = parent.isDaemon();</span><br><span class="line">    this.priority = parent.getPriority();</span><br><span class="line">    if (security == null || isCCLOverridden(parent.getClass()))</span><br><span class="line">        this.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    else</span><br><span class="line">        this.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    this.inheritedAccessControlContext =</span><br><span class="line">            acc != null ? acc : AccessController.getContext();</span><br><span class="line">    this.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    //就是这一步，如果父线程的inheritThreadLocals存在，那么我就把父线程的inheritThreadLocals给当前线程的</span><br><span class="line">    if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)</span><br><span class="line">        this.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    this.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ThreadLocal的应用示例"><a href="#ThreadLocal的应用示例" class="headerlink" title="ThreadLocal的应用示例"></a>ThreadLocal的应用示例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThreadLocalTest &#123;</span><br><span class="line"></span><br><span class="line">    static class MyRunAble implements Runnable &#123;</span><br><span class="line">        private ThreadLocal threadLocal = new ThreadLocal();</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            threadLocal.set((int) (Math.random() * 100D));</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            //可以通过下面方法读取保存在ThreadLocal变量中的值</span><br><span class="line">            System.out.println(&quot;-------threadLocal value-------&quot; + threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();</span><br><span class="line">        MyRunAble myRunAble1 = new MyRunAble();</span><br><span class="line">        MyRunAble myRunAble2 = new MyRunAble();</span><br><span class="line">        myRunAble1.run();</span><br><span class="line">        myRunAble2.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ThreadLocal</category>
      </categories>
      <tags>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle学习（一）</title>
    <url>/2019/05/08/gradleOne/</url>
    <content><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>Gradle是一种构建工具，它抛弃了基于XML的构建脚本，取而代之的是采用一种基于Groovy的内部领域特定语言。<br>在Gradle中，有两个基本概念：项目和任务<br>&ensp;&ensp;&ensp;&ensp;1.项目是指我们的构建产物（比如Jar包）或实施产物（将应用程序部署到生产环境）。一个项目包含一个或多个任务。<br>&ensp;&ensp;&ensp;&ensp;2.任务是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试）。<br>每一次Gradle的构建都包含一个或多个项目。<br>&ensp;&ensp;&ensp;&ensp;Gradle本身的领域对象主要有Project和Task。Project为Task提供了执行上下文，所有的Plugin要么向Project中添加用于配置的Property，要么向Project中添加不同的Task。一个Task表示一个逻辑上较为独立的执行过程，比如编译Java源代码，拷贝文件，打包Jar文件，甚至可以是执行一个系统命令或者调用Ant。另外，一个Task可以读取和设置Project的Property以完成特定的操作。</p>
<h1 id="二、gradle的构建基础"><a href="#二、gradle的构建基础" class="headerlink" title="二、gradle的构建基础"></a>二、gradle的构建基础</h1><p>&ensp;&ensp;&ensp;&ensp;构建第一个脚本。创建一个build.gradle的文件,运行CMD切换到build.gradle的文件目录，gradle的命令默认会在当前目录下寻找名未build.gradle的构建脚本。build.gradle<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println &apos;Hello world!&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行命令gradle -q hello执行脚本，打印出  hello world</p>
<h2 id="快速定义任务"><a href="#快速定义任务" class="headerlink" title="快速定义任务"></a>快速定义任务</h2><p>采用闭包的方式来定义了一个叫做 hello 的任务<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task hello &lt;&lt; &#123;</span><br><span class="line">    println &apos;Hello world!&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>gradle脚本也能使用groovy，在build.gradle中编辑<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task upper &lt;&lt; &#123;</span><br><span class="line">    String someString = &apos;mY_nAmE&apos;</span><br><span class="line">    println &quot;Original: &quot; + someString</span><br><span class="line">    println &quot;Upper case: &quot; + someString.toUpperCase()</span><br><span class="line">&#125;</span><br><span class="line">Output of gradle -q upper</span><br><span class="line">&gt; gradle -q upper</span><br><span class="line">Original: mY_nAmE</span><br><span class="line">Upper case: MY_NAME</span><br></pre></td></tr></table></figure></p>
<h2 id="任务依赖"><a href="#任务依赖" class="headerlink" title="任务依赖"></a>任务依赖</h2><p>在build.gradle中添加任务<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task intro(dependsOn: hello) &lt;&lt; &#123;</span><br><span class="line">    println &quot;I&apos;m Gradle&quot;</span><br><span class="line">&#125;</span><br><span class="line">task hello &lt;&lt; &#123;</span><br><span class="line">    println &apos;Hello world!&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>任务之间的依赖的声明顺序可以不不必为顺序声明</p>
<h2 id="创建动态任务"><a href="#创建动态任务" class="headerlink" title="创建动态任务"></a>创建动态任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.times &#123; counter -&gt;</span><br><span class="line">    task &quot;task$counter&quot; &lt;&lt; &#123;</span><br><span class="line">        println &quot;I&apos;m task number $counter&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 API 进行任务之间的通信 - 增加任务行为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task hello &lt;&lt; &#123;</span><br><span class="line">    println &apos;Hello Earth&apos;</span><br><span class="line">&#125;</span><br><span class="line">hello.doFirst &#123;</span><br><span class="line">    println &apos;Hello Venus&apos;</span><br><span class="line">&#125;</span><br><span class="line">hello.doLast &#123;</span><br><span class="line">    println &apos;Hello Mars&apos;</span><br><span class="line">&#125;</span><br><span class="line">hello &lt;&lt; &#123;</span><br><span class="line">    println &apos;Hello Jupiter&apos;</span><br><span class="line">&#125;</span><br><span class="line">Output of gradle -q hello</span><br><span class="line">&gt; gradle -q hello</span><br><span class="line">Hello Venus</span><br><span class="line">Hello Earth</span><br><span class="line">Hello Mars</span><br><span class="line">Hello Jupiter</span><br></pre></td></tr></table></figure></p>
<h2 id="增加自定义的属性"><a href="#增加自定义的属性" class="headerlink" title="增加自定义的属性"></a>增加自定义的属性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task myTask &#123;</span><br><span class="line">    ext.myProperty = &quot;myValue&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task printTaskProperties &lt;&lt; &#123;</span><br><span class="line">    println myTask.myProperty</span><br><span class="line">&#125;</span><br><span class="line">//gradle -q printTaskProperties 的输出为</span><br><span class="line">Output of gradle -q printTaskProperties</span><br><span class="line">\&gt; gradle -q printTaskProperties</span><br><span class="line">myValue</span><br></pre></td></tr></table></figure>
<h2 id="定义默认任务"><a href="#定义默认任务" class="headerlink" title="定义默认任务"></a>定义默认任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">defaultTasks &apos;clean&apos;, &apos;run&apos;</span><br><span class="line">task clean &lt;&lt; &#123;</span><br><span class="line">    println &apos;Default Cleaning!&apos;</span><br><span class="line">&#125;</span><br><span class="line">task run &lt;&lt; &#123;</span><br><span class="line">    println &apos;Default Running!&apos;</span><br><span class="line">&#125;</span><br><span class="line">task other &lt;&lt; &#123;</span><br><span class="line">    println &quot;I&apos;m not a default task!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Output of gradle -q</span><br><span class="line">\&gt; gradle -q</span><br><span class="line">Default Cleaning!</span><br><span class="line">Default Running!</span><br></pre></td></tr></table></figure></p>
<h2 id="Configure-by-DAG"><a href="#Configure-by-DAG" class="headerlink" title="Configure by DAG"></a>Configure by DAG</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task distribution &lt;&lt; &#123;</span><br><span class="line">    println &quot;We build the zip with version=$version&quot;</span><br><span class="line">&#125;</span><br><span class="line">task release(dependsOn: &apos;distribution&apos;) &lt;&lt; &#123;</span><br><span class="line">    println &apos;We release now&apos;</span><br><span class="line">&#125;</span><br><span class="line">gradle.taskGraph.whenReady &#123;taskGraph -&gt;</span><br><span class="line">    if (taskGraph.hasTask(release)) &#123;</span><br><span class="line">        version = &apos;1.0&apos;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        version = &apos;1.0-SNAPSHOT&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">\&gt; gradle -q distribution</span><br><span class="line">We build the zip with version=1.0-SNAPSHOT</span><br></pre></td></tr></table></figure>
<p>使用钩子taskGraph来获取build.gradle定义运行时的版本信息</p>
]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>java工具</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle 打包</title>
    <url>/2020/01/13/gradle-%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">	apply <span class="string">plugin:</span> <span class="string">"java"</span></span><br><span class="line">	<span class="comment">//打包插件，不含第三方依赖jar</span></span><br><span class="line">    apply <span class="string">plugin:</span> <span class="string">"maven-publish"</span></span><br><span class="line">    apply <span class="string">plugin:</span> <span class="string">'idea'</span></span><br><span class="line"></span><br><span class="line">    version = <span class="string">'1.0.0'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// JVM 版本号要求</span></span><br><span class="line">    sourceCompatibility = <span class="number">1.8</span></span><br><span class="line">    targetCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// java编译的时候缺省状态下会因为中文字符而失败</span></span><br><span class="line">    [compileJava, compileTestJava, javadoc]*.options*.encoding = <span class="string">'UTF-8'</span></span><br><span class="line"></span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenLocal()</span><br><span class="line">        maven &#123; url <span class="string">"http://maven.aliyun.com/nexus/content/groups/public"</span> &#125;</span><br><span class="line">        mavenCentral()</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123; url <span class="string">"http://repo.spring.io/snapshot"</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">"http://repo.spring.io/milestone"</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'http://maven.springframework.org/release'</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'http://maven.springframework.org/milestone'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jar &#123;</span><br><span class="line">        manifest &#123;</span><br><span class="line">            attributes(<span class="string">"Implementation-Title"</span>: <span class="string">"Gradle"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示当前项目下所有用于 compile 的 jar.</span></span><br><span class="line">    task listJars(<span class="string">description:</span> <span class="string">'Display all compile jars.'</span>) &lt;&lt; &#123;</span><br><span class="line">        configurations.compile.each &#123; File file -&gt; println file.name &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gradle.projectsEvaluated &#123;</span><br><span class="line">        tasks.withType(JavaCompile) &#123;</span><br><span class="line">            options.compilerArgs &lt;&lt; <span class="string">"-Xlint:unchecked"</span> &lt;&lt; <span class="string">"-Xlint:deprecation"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    task <span class="string">"create-dirs"</span> &lt;&lt; &#123;</span><br><span class="line">        sourceSets*.java.srcDirs*.each &#123;</span><br><span class="line">            it.mkdirs()</span><br><span class="line">        &#125;</span><br><span class="line">        sourceSets*.resources.srcDirs*.each&#123;</span><br><span class="line">            it.mkdirs()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ext &#123;</span><br><span class="line">        set(<span class="string">'springCloudVersion'</span>, <span class="string">"Dalston.SR5"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line"><span class="comment">//        compile group: 'org.springframework.boot', name: 'spring-boot-starter-data-jpa', version: '2.1.4.RELEASE'</span></span><br><span class="line">        compile <span class="string">group:</span> <span class="string">'org.springframework.boot'</span>, <span class="string">name:</span> <span class="string">'spring-boot-starter-data-jpa'</span>, <span class="string">version:</span> <span class="string">'2.2.2.RELEASE'</span></span><br><span class="line">        compile <span class="string">group:</span> <span class="string">'org.springframework.boot'</span>, <span class="string">name:</span> <span class="string">'spring-boot-starter-web'</span>, <span class="string">version:</span> <span class="string">'2.2.2.RELEASE'</span></span><br><span class="line">        <span class="comment">// https://mvnrepository.com/artifact/org.projectlombok/lombok</span></span><br><span class="line">        compile <span class="string">group:</span> <span class="string">'org.projectlombok'</span>, <span class="string">name:</span> <span class="string">'lombok'</span>, <span class="string">version:</span> <span class="string">'1.18.8'</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置动态属性</span></span><br><span class="line">    ext &#123;</span><br><span class="line">        <span class="comment">//发布到仓库用户名</span></span><br><span class="line">        publishUserName = <span class="string">"dawei"</span></span><br><span class="line">        <span class="comment">//发布到仓库地址</span></span><br><span class="line">        publishUserPassword = <span class="string">"qq1235789"</span></span><br><span class="line">        <span class="comment">//仓库地址</span></span><br><span class="line">        publishURL = <span class="string">"http://47.102.99.93:8081/repository/panghu/"</span></span><br><span class="line"></span><br><span class="line">        apiBaseJarName = <span class="string">"base"</span></span><br><span class="line">        apiBaseJarVersion = <span class="string">'0.0.1'</span></span><br><span class="line">        builtBy = <span class="string">"gradle 1.9"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//jar包名称组成：[baseName]-[appendix]-[version]-[classifier].[extension]</span></span><br><span class="line"><span class="comment">//打包class文件</span></span><br><span class="line">    task apiBaseJar(<span class="string">type:</span>Jar)&#123;</span><br><span class="line">        version apiBaseJarVersion</span><br><span class="line">        baseName apiBaseJarName</span><br><span class="line">        from sourceSets.main.output</span><br><span class="line">        destinationDir file(<span class="string">"$buildDir/api-libs"</span>)</span><br><span class="line">        includes [<span class="string">'com/example/**'</span>]</span><br><span class="line">        manifest &#123;</span><br><span class="line">            attributes <span class="string">'packageName'</span>: apiBaseJarName, <span class="string">'Built-By'</span>: builtBy,<span class="string">'Built-date'</span>: <span class="keyword">new</span> Date().format(<span class="string">'yyyy-MM-dd HH:mm:ss'</span>),<span class="string">'Manifest-Version'</span>:version</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//打包源码</span></span><br><span class="line">    task apiBaseSourceJar(<span class="string">type:</span>Jar)&#123;</span><br><span class="line">        version apiBaseJarVersion</span><br><span class="line">        baseName apiBaseJarName</span><br><span class="line">        classifier <span class="string">"sources"</span></span><br><span class="line">        from sourceSets.main.allSource</span><br><span class="line">        destinationDir file(<span class="string">"$buildDir/api-libs"</span>)</span><br><span class="line">        includes [<span class="string">'com/example/**'</span>]</span><br><span class="line">        manifest &#123;</span><br><span class="line">            attributes <span class="string">'packageName'</span>: apiBaseJarName+<span class="string">'-sources'</span>, <span class="string">'Built-By'</span>: builtBy,<span class="string">'Built-date'</span>: <span class="keyword">new</span> Date().format(<span class="string">'yyyy-MM-dd HH:mm:ss'</span>),<span class="string">'Manifest-Version'</span>:version</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//上传jar包</span></span><br><span class="line">    publishing &#123;</span><br><span class="line">        publications &#123;</span><br><span class="line">            publishing.publications.create(<span class="string">'apiBase'</span>, MavenPublication) &#123;</span><br><span class="line">                groupId <span class="string">'base-core'</span></span><br><span class="line">                artifactId apiBaseJarName</span><br><span class="line">                version apiBaseJarVersion</span><br><span class="line">                <span class="comment">//同时上传class包和源码包</span></span><br><span class="line">                artifacts = [apiBaseJar, apiBaseSourceJar]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        repositories &#123;</span><br><span class="line">            maven &#123;</span><br><span class="line">                url publishURL</span><br><span class="line">                credentials &#123;</span><br><span class="line">                    username = publishUserName</span><br><span class="line">                    password = publishUserPassword</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>gradleThree</title>
    <url>/2019/07/28/gradleThree/</url>
    <content><![CDATA[<h1 id="Task任务"><a href="#Task任务" class="headerlink" title="Task任务"></a>Task任务</h1><h2 id="task任务定义"><a href="#task任务定义" class="headerlink" title="task任务定义"></a>task任务定义</h2><p>在gradle文件中定义task的方法有两种，如下。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//直接定义task</span><br><span class="line">task hello1(group: &apos;immoc&apos;,description: &apos;hellostudy&apos;)&#123;</span><br><span class="line">    println &quot;hello1&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//通过TaskContainer 创建task</span><br><span class="line">this.tasks.create(name: &apos;hello2&apos;)&#123;</span><br><span class="line">    setGroup(&apos;immoc&apos;);</span><br><span class="line">    setDescription(&apos;hellostudy&apos;)</span><br><span class="line">    println &quot;hello2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在执行gradle clean时，两个任务都会配置阶段运行。配置task在运行阶段而不是配置阶段,doFirst和doLast，可以监听任务执行的时长，代码如下、<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task test()&#123;&#125;</span><br><span class="line">def startBuildTime ,endBuildTime;</span><br><span class="line">//计算构建的时常</span><br><span class="line">this.afterEvaluate &#123;Project project-&gt;</span><br><span class="line">    //保证配置阶段完成</span><br><span class="line">    def preBuildTask = project.tasks.findByName(&apos;test&apos;)</span><br><span class="line">    preBuildTask.doFirst &#123;</span><br><span class="line">        startBuildTime =System.currentTimeMillis();</span><br><span class="line">        println &quot;start time is $&#123;startBuildTime&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    def buildTask = project.tasks.findByName(&apos;test&apos;)</span><br><span class="line">    buildTask.doLast &#123;</span><br><span class="line">        endBuildTime = System.currentTimeMillis();</span><br><span class="line">        println &quot;end time is $&#123;endBuildTime&#125;&quot;</span><br><span class="line">        println &quot;cost time is $&#123;endBuildTime- startBuildTime&#125;ms&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="task的执行顺序"><a href="#task的执行顺序" class="headerlink" title="task的执行顺序"></a>task的执行顺序</h2><p>task的执行顺序可以分成三种：dependsOn强依赖的方式、通过task输入输出指定、通过API指定顺序<br>强依赖的方式执行顺序,先执行依赖的task<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> task taskX()&#123;doLast &#123; println &quot;task x&quot;&#125;&#125;</span><br><span class="line">task taskY()&#123;doLast &#123; println &quot;task y&quot; &#125;&#125;</span><br><span class="line">task taskZ(dependsOn: [taskX,taskY])&#123;</span><br><span class="line">    doLast &#123;println &quot;task z&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line">另一种指定依赖写法</span><br><span class="line">taskZ.denpendsOn(taskX,taskY)</span><br></pre></td></tr></table></figure></p>
<p>另一种动态的指定执行顺序的方法,调用dependsOn方法动态添加依赖，注意被依赖的方法要定义在需要引用的task之前<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// &lt;&lt;等同于 doLast,不在编译期执行</span><br><span class="line">task lib1 &lt;&lt; &#123;</span><br><span class="line">    println &quot;lib1&quot;</span><br><span class="line">&#125;</span><br><span class="line">task lib2 &lt;&lt; &#123;</span><br><span class="line">    println &quot;lib2&quot;</span><br><span class="line">&#125;</span><br><span class="line">task noLib  &lt;&lt; &#123;</span><br><span class="line">    println &quot;noLib&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task testLib &#123;</span><br><span class="line">//    添加前缀名为lib的依赖</span><br><span class="line">    dependsOn this.tasks.findAll &#123;</span><br><span class="line">        task-&gt;return task.name.startsWith(&apos;lib&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println &apos;test&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="task-的输入和输出"><a href="#task-的输入和输出" class="headerlink" title="task 的输入和输出"></a>task 的输入和输出</h2><p>//TODO </p>
<h2 id="task的指定顺序"><a href="#task的指定顺序" class="headerlink" title="task的指定顺序"></a>task的指定顺序</h2><p>使用mustRunAfter 来指定任务的执行顺序,控制台输入gradle task1 task3 task2，可以发现任务执行顺序是1、2、3<br>如果使用的是shouldRunAfter 执行顺序不是强制性<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task task1&#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println &quot;task1&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task task2&#123;</span><br><span class="line">    mustRunAfter task1</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println &quot;task2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task task3&#123;</span><br><span class="line">    mustRunAfter task2</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println &quot;task3&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="task自定义和配置"><a href="#task自定义和配置" class="headerlink" title="task自定义和配置"></a>task自定义和配置</h2><p>在定义task的时候可以设置task的分组和描述，idea中gradle中的任务就是按分组分类，默认为other下的task<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task helloTask&#123;</span><br><span class="line">    println &quot;helloTask&quot;</span><br><span class="line">&#125;</span><br><span class="line">//通过TaskContainer创建任务</span><br><span class="line">this.tasks.create(name: &apos;helloTask2&apos;)&#123;</span><br><span class="line">	//给任务添加属性</span><br><span class="line">	setGroup(&quot;gradle&quot;)</span><br><span class="line">    setDescription(&quot;helloTask2&quot;)</span><br><span class="line">    println &quot;helloTask2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置资源文件夹</span><br><span class="line">sourceSets&#123;</span><br><span class="line">	main &#123;</span><br><span class="line">		groovy &#123;</span><br><span class="line">			others&#123;</span><br><span class="line">				srcDir &apos;src/main/others&apos;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>java工具</tag>
        <tag>gradle，groovy</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle学习（二）</title>
    <url>/2019/05/09/gradleTwo/</url>
    <content><![CDATA[<h1 id="gradle的生命周期"><a href="#gradle的生命周期" class="headerlink" title="gradle的生命周期"></a>gradle的生命周期</h1><p>![][/yilai.png]<br>gradle的生命周期监听<br>gradle 的生命周期主要分为三个阶段：<br>@nesp;@nesp;@nesp;@nesp;项目的初始化阶段，构建Project项目的project对象<br>@nesp;@nesp;@nesp;@nesp;解析所有projiect中的task,并构建task的拓扑图<br>@nesp;@nesp;@nesp;@nesp;执行相关的task和相关的task</p>
<p>项目的目录结构如下图所示<br><img src="/2019/05/09/gradleTwo/content.png" alt><br>全局的build.gradle中添加监听方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//声明gradle脚本自身需要的资源，可以声明的资源包括依赖项、第三方插件、maven仓库地址等</span><br><span class="line">buildscript&#123;&#125;</span><br><span class="line">// 所有子项目的通用配置</span><br><span class="line">subprojects &#123;&#125;</span><br><span class="line">//所有项目的通用配置</span><br><span class="line">allprojects&#123;&#125;</span><br><span class="line"></span><br><span class="line">//初始化阶段后，配置阶段开始前的</span><br><span class="line">this.beforeEvaluate &#123;&#125;</span><br><span class="line"></span><br><span class="line">//配置阶段完成，执行阶段前</span><br><span class="line">this.afterEvaluate &#123;</span><br><span class="line">    println &quot;配置完成&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//gradle生命周期完成之后</span><br><span class="line">this.gradle.buildFinished &#123;</span><br><span class="line">    println &quot;执行完成&quot;</span><br><span class="line">&#125;</span><br><span class="line">在setting.gradle中添加</span><br><span class="line">println &quot;初始化开始&quot;</span><br></pre></td></tr></table></figure></p>
<p>再运行gradle中的task就会打印出上述的打印语句</p>
<h2 id="gradle中的project"><a href="#gradle中的project" class="headerlink" title="gradle中的project"></a>gradle中的project</h2><p>在gradle多项目中，除了根工程，这些Moudle也是gradle的工程，而文件中的build.gradle标志Moudle是gradle项目<br>执行gradle projects命令，可以看见打印出<br><img src="/2019/05/09/gradleTwo/projects.png" alt><br>project以树的结构管理项目，但是项目一般只构建两层<br>gradle的相关API大致可以分为下图中的六部分<br><img src="/2019/05/09/gradleTwo/projects.png" alt></p>
<h3 id="project中的API"><a href="#project中的API" class="headerlink" title="project中的API"></a>project中的API</h3><p>在根project的build中定义打印处所有project的方法，并调用，可以直接在命令窗口上任意运行task，因为都会加载配置文件，执行this.getProjects()在加载配置文件中就运行。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//加载配置文件时会调用</span><br><span class="line">this.getProjects()</span><br><span class="line">//返回所有的project列表</span><br><span class="line">def getProjects()&#123;</span><br><span class="line">    println &quot;--------&quot;</span><br><span class="line">    println &quot;root project&quot;</span><br><span class="line">    println &quot;--------&quot;</span><br><span class="line">    this.getAllprojects().eachWithIndex&#123; Project project, int i -&gt;</span><br><span class="line">        if(i==0)&#123;</span><br><span class="line">            println &quot;rootProject:$&#123;project.name&#125;&quot;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            println &quot;+-- :$&#123;project.name&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同理，还可以定义获取父project和根project的方法，但是这获取父project方法不能再根目录下的build中运行，因为根目录没有父project了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//获取父project的名称</span><br><span class="line">def getParentName = &#123;</span><br><span class="line">    println this.getParent().name</span><br><span class="line">&#125;</span><br><span class="line">//获取根目录的名称</span><br><span class="line">def getRootName =&#123;</span><br><span class="line">    println this.getRootProject().name</span><br><span class="line">&#125;</span><br><span class="line">//相当于设置对应模块的配置，不过通用模块可以在subprojects&#123;&#125;里面配置的</span><br><span class="line">project(&apos;webOne&apos;)&#123;</span><br><span class="line">    Project project-&gt; println project.name</span><br><span class="line">        apply plugin: &apos;io.spring.dependency-management&apos;</span><br><span class="line">        agroup &apos;com.demo&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="属性相关的API"><a href="#属性相关的API" class="headerlink" title="属性相关的API"></a>属性相关的API</h3><p>geadle中的Project中的默认配置如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Project extends Comparable&lt;Project&gt;, ExtensionAware, PluginAware &#123;</span><br><span class="line">	//默认的配置文件名称是build.gradle，</span><br><span class="line">    String DEFAULT_BUILD_FILE = &quot;build.gradle&quot;;</span><br><span class="line">	//默认的路径分割符</span><br><span class="line">    String PATH_SEPARATOR = &quot;:&quot;;</span><br><span class="line">	//gradle的默认输出文件夹</span><br><span class="line">    String DEFAULT_BUILD_DIR_NAME = &quot;build&quot;;</span><br><span class="line">	//配置常量文件名</span><br><span class="line">    String GRADLE_PROPERTIES = &quot;gradle.properties&quot;;</span><br><span class="line">    String SYSTEM_PROP_PREFIX = &quot;systemProp&quot;;</span><br><span class="line">    String DEFAULT_VERSION = &quot;unspecified&quot;;</span><br><span class="line">    String DEFAULT_STATUS = &quot;release&quot;;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在build.gradle中定义扩展属性和定义版本<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//定义扩展属性</span><br><span class="line">ext &#123;</span><br><span class="line">	set(&apos;springCloudVersion&apos;, &quot;Greenwich.SR1&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//使用扩展的属性</span><br><span class="line">dependencyManagement &#123;</span><br><span class="line">	imports &#123;</span><br><span class="line">		mavenBom &quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想在所有的子项目中都定义某些属性，可以在subProjects{}中编写ext{},或是在build.gradle中添加属性，在子项目的build.gradle文件中使用${}去获取对应的值。<br>在根目录下的settings.gradle,gradle.properties中控制是否添加webOned,然后刷新gradle，idea会提示webOne移出Gradle,而且树状结构也没有了webOne<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//gradle.properties中</span><br><span class="line">isLoadOne= fasle</span><br><span class="line"></span><br><span class="line">//在settings.gradle中添加</span><br><span class="line">rootProject.name = &apos;myGradleProject&apos;</span><br><span class="line">include &apos;webTwo&apos;</span><br><span class="line">if(hasProperty(&apos;isLoadOne&apos;)?isLoadOne.toBoolean():false&#123;</span><br><span class="line">	include &apos;webOne&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="文件操作属性API"><a href="#文件操作属性API" class="headerlink" title="文件操作属性API"></a>文件操作属性API</h3><p>获取文件相关的API<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//获取跟工程的根路径</span><br><span class="line">println &quot;root path :&quot;+ getRootDir().absolutePath</span><br><span class="line">//build文件的路径</span><br><span class="line">println &quot;build path:&quot;+getBuildDir().absolutePath</span><br><span class="line">//当前project路径</span><br><span class="line">println  &quot;project path:&quot;+getProjectDir().absolutePath</span><br><span class="line"></span><br><span class="line">//在build.gradle找到对应路径的文件，并打印出内容</span><br><span class="line">def getContent(String path)&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">	//file方法从当前project的路径开始寻找，files（）方法参数是多个路径，返回的参数是file的集合</span><br><span class="line">        def file = file(path)</span><br><span class="line">        return file.text</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        println &quot;error&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println getContent(&apos;build.gradle&apos;)</span><br></pre></td></tr></table></figure></p>
<p>gradle的文件拷贝在webOne中新建一个文件copy.txt,webOne的build中添加下面的代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy &#123;</span><br><span class="line">	from(&apos;copytest.txt&apos;)</span><br><span class="line">	into getRootProject()</span><br><span class="line">	//不拷贝某些文件</span><br><span class="line">	exclude&#123;&#125;</span><br><span class="line">	//拷贝后重命名</span><br><span class="line">	rename&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在执行gradle的同步后就会在build文件夹下生成对应的文件，<br>文件树的遍历<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//对文件树的遍历</span><br><span class="line">fileTree(&apos;webTwo/src&apos;) &#123; FileTree fileTree-&gt;</span><br><span class="line">    fileTree.visit &#123;FileTreeElement fileTreeElement-&gt;</span><br><span class="line">        println &quot;the file name is :&quot;+fileTreeElement.file.name</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="依赖相关的API"><a href="#依赖相关的API" class="headerlink" title="依赖相关的API"></a>依赖相关的API</h3><p>buildscript 是项目的配置，常用通过的是repositories仓库的配置和dependencies依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buildscript&#123; ScriptHandler scriptHandler-&gt;</span><br><span class="line">    //配置工程的仓库地址</span><br><span class="line">  repositories&#123;</span><br><span class="line">        //私有仓库,如果多个就继续配下去</span><br><span class="line">        maven &#123;</span><br><span class="line">            //仓库的别名</span><br><span class="line">            name &apos;person&apos;</span><br><span class="line">            //maven仓库地址</span><br><span class="line">            url &apos;hhttp://localhoys......&apos;</span><br><span class="line">            //配置仓库的账号和密码</span><br><span class="line">            credentials&#123;</span><br><span class="line">                username = &apos;admin&apos;</span><br><span class="line">                password = &apos;admin123&apos;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        mavenCentral()</span><br><span class="line">        //本地maven库</span><br><span class="line">        mavenLocal()</span><br><span class="line">        jcenter()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //配置工程的插件依赖地址</span><br><span class="line">    dependencies&#123;</span><br><span class="line">        //gradle需要的依赖</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:2.2.2&apos;</span><br><span class="line">        classpath &apos;com.tencent.tinker-patch-gradle-plugin:1.7.7&apos;//腾讯的热修复框架</span><br><span class="line">        //poject需要的依赖</span><br><span class="line">        compile （group: &apos;net.officefloor.server&apos;, name: &apos;officeserver&apos;, version: &apos;3.10.3‘）&#123;</span><br><span class="line">		//这个常用于解决依赖重复的冲突</span><br><span class="line">		exclude module:&apos;support-v4&apos;</span><br><span class="line">        //添加依赖的工程，引用project</span><br><span class="line">        compile project(&apos;webOne&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>java工具</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>groovy learn（一）</title>
    <url>/2019/05/19/groovy-learn%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="一、groovy-的环境安装"><a href="#一、groovy-的环境安装" class="headerlink" title="一、groovy 的环境安装"></a>一、groovy 的环境安装</h1><p>centos下的安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -s get.sdkman.io | bash</span><br><span class="line">$ source &quot;$HOME/.sdkman/bin/sdkman-init.sh&quot;</span><br><span class="line">$ sdk install groovy</span><br><span class="line">$ groovy -version</span><br></pre></td></tr></table></figure></p>
<p>windows下的安装<br>官网下载安装包后解压，配置环境<br>•新建GROOVY_HOME，值为解压后文件的路径。<br><img src="/2019/05/19/groovy-learn（一）/groovy_home.png" alt><br>•修改PATH，在最后追加<code>%GROOVY_HOME%\bin<br><img src="/2019/05/19/groovy-learn（一）/home.png" alt></code></p>
<p>#二 groovy的基础语法<br>groovy的变量<br><img src="/2019/05/19/groovy-learn（一）/type.png" alt><br>创建.Groovy Script文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package variable</span><br><span class="line">//groovy 中变量最后都会被包装成对象类型</span><br><span class="line">int x = 10</span><br><span class="line">println x.class  //Integer</span><br><span class="line">double  y = 1.14</span><br><span class="line">println y.class  // Double</span><br><span class="line"></span><br><span class="line">//groovy 定义变量的类型,使用def快速定义弱类型,推断数据类型</span><br><span class="line">def x_1 =2</span><br><span class="line">println x_1.class</span><br><span class="line">def y_1 = 3.15</span><br><span class="line">println y_1.class</span><br><span class="line">def name = &apos;david&apos;</span><br><span class="line">println name.class</span><br></pre></td></tr></table></figure></p>
<h1 id="三、groovy中的字符串用法"><a href="#三、groovy中的字符串用法" class="headerlink" title="三、groovy中的字符串用法"></a>三、groovy中的字符串用法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def str = &apos;a \&apos;a\&apos; string &apos;</span><br><span class="line">println str</span><br><span class="line">println str.class</span><br><span class="line"></span><br><span class="line">//三个引号定义的字符串可以指定格式</span><br><span class="line">def thupleStr = &apos;&apos;&apos;\</span><br><span class="line">three </span><br><span class="line">signle </span><br><span class="line">string&apos;&apos;&apos;</span><br><span class="line">println thupleStr</span><br><span class="line">println  thupleStr.class</span><br><span class="line"></span><br><span class="line">//双引号字符串格式,可一再字符串中引用其他字符串，引用其他变量后类型是groovy.runtime.GStringImpl</span><br><span class="line">def name =  &quot;david&quot;</span><br><span class="line">def doubleName = &quot;name: $&#123;thupleStr&#125;&quot;</span><br><span class="line">println doubleName</span><br><span class="line">println doubleName.class</span><br><span class="line"></span><br><span class="line">//双引号中的扩展接受任意的表达式</span><br><span class="line">def sum = &quot;the sum of 2 and 3 equals $&#123;2 + 3&#125;&quot;</span><br><span class="line">println sum</span><br><span class="line"></span><br><span class="line">//测试GString 和String 的转换.编译器转换</span><br><span class="line">def result = echo(sum)</span><br><span class="line">println result</span><br><span class="line">println result.class</span><br><span class="line">String echo(String message)&#123;</span><br><span class="line">    return message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*******字符串String 常用方法 *********************/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def str1 = &quot;justTest&quot;</span><br><span class="line">//println st1.center(9,&apos;a&apos;)//字符串两边填充字符，默认填充空格。先右后左</span><br><span class="line"></span><br><span class="line">//println str1.padLeft(10,&apos;a&apos;)//字符串右侧填充</span><br><span class="line"></span><br><span class="line">//字符串比较</span><br><span class="line">def str2 = &quot;hello&quot;</span><br><span class="line">println str1&gt;str2</span><br><span class="line"></span><br><span class="line">println str2[0]  //获取下标的值</span><br><span class="line">println str2[0..3]  //获取下标范围的值</span><br><span class="line"></span><br><span class="line">println str2.minus(&quot;ello&quot;)   //等同于 石str1 - str2</span><br><span class="line"></span><br><span class="line">println str2.reverse() //字符串反转</span><br><span class="line"></span><br><span class="line">println str2.capitalize()  //首字母大写</span><br></pre></td></tr></table></figure>
<h1 id="四、groovy中的逻辑控制"><a href="#四、groovy中的逻辑控制" class="headerlink" title="四、groovy中的逻辑控制"></a>四、groovy中的逻辑控制</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> package variable</span><br><span class="line">//逻辑控制</span><br><span class="line"></span><br><span class="line">// switch语句</span><br><span class="line"> def x = 1.23</span><br><span class="line"> def result</span><br><span class="line"> switch (x)&#123;</span><br><span class="line">    case &apos;foo&apos;:</span><br><span class="line">        result=&quot;founf foo&quot;</span><br><span class="line">        break</span><br><span class="line">     case &apos;bar&apos;:</span><br><span class="line">         result = &apos;bar&apos;</span><br><span class="line">         break</span><br><span class="line">     case [1.23,5,6,&apos;inList&apos;]: //列表中的结果匹配</span><br><span class="line">         result = &apos;list&apos;</span><br><span class="line">         break</span><br><span class="line">     case 12..30:</span><br><span class="line">         result = &apos;range&apos;</span><br><span class="line">         break</span><br><span class="line">     case Integer:</span><br><span class="line">         result = &apos;integer&apos;</span><br><span class="line">         break</span><br><span class="line">     case BigDecimal:</span><br><span class="line">         result = &apos;bigDecimal&apos;</span><br><span class="line">         break</span><br><span class="line">     default:result = &apos;default&apos;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> println result</span><br><span class="line"></span><br><span class="line">// for循环  计算0-9的和</span><br><span class="line">def sum = 0</span><br><span class="line"> for(i in 0..9)&#123;</span><br><span class="line">     sum+=i</span><br><span class="line"> &#125;</span><br><span class="line"> println &apos;sum:&apos;+sum</span><br><span class="line"></span><br><span class="line"> //对于List中元素循环</span><br><span class="line"> def sum1 = 0</span><br><span class="line"> for(i in [1,2,3,4,5,6,7,8,9])&#123;</span><br><span class="line">     sum1 += i</span><br><span class="line"> &#125;</span><br><span class="line"> println &quot;sum1:&quot;+sum1</span><br><span class="line"></span><br><span class="line">// 对MAP进行循环</span><br><span class="line"> def sum2 =0</span><br><span class="line"> for(i in [&apos;xiaoMing&apos;:1,&apos;xiaoQiang&apos;:2,&apos;xiaoHua&apos;:3])&#123;</span><br><span class="line">     sum2 += i.value</span><br><span class="line"> &#125;</span><br><span class="line"> println &apos;sum2:&apos;+sum2</span><br></pre></td></tr></table></figure>
<h1 id="五、闭包"><a href="#五、闭包" class="headerlink" title="五、闭包"></a>五、闭包</h1><p><img src="/2019/05/19/groovy-learn（一）/close.png" alt></p>
<p>##闭包的定义<br>闭包是代码块。定义如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//*******闭包的定义和参数********</span><br><span class="line">def closure = &#123;println  &quot;close package&quot;&#125;//闭包的定义方式</span><br><span class="line">closure.call()//调用闭包方法的两种方式</span><br><span class="line">//closure()</span><br><span class="line"></span><br><span class="line">def close = &#123;String name -&gt; println &quot;hello $&#123;name&#125;&quot;&#125;//有参数的闭包定义</span><br><span class="line">close(&quot;david&quot;)</span><br><span class="line"></span><br><span class="line">//多个参数</span><br><span class="line">def close1 = &#123;String name,Integer age-&gt; println &quot;hello :$&#123;name&#125;&amp;$&#123;age&#125;&quot;&#125;</span><br><span class="line">close1(&quot;pangpang&quot;,12)</span><br><span class="line"></span><br><span class="line">//闭包方法的隐式参数it</span><br><span class="line">def close2 = &#123; println &quot;hello $&#123;it&#125;&quot;&#125;</span><br><span class="line">close2(&quot;david&quot;)</span><br><span class="line"></span><br><span class="line">//*********闭包的返回值**********</span><br><span class="line">def close3 = &#123; println  &quot;test return $&#123;it&#125;&quot;&#125;</span><br><span class="line">def result = close3(&quot;test&quot;)</span><br><span class="line">println result //闭包方法必定有返回值，默认返回null</span><br></pre></td></tr></table></figure></p>
<h2 id="闭包的用法"><a href="#闭包的用法" class="headerlink" title="闭包的用法"></a>闭包的用法</h2><p><img src="/2019/05/19/groovy-learn（一）/closeuse.png" alt><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//闭包求阶乘</span><br><span class="line">int fab(number)&#123;</span><br><span class="line">    int result = 1</span><br><span class="line">    1.upto(number,&#123;num-&gt;result *=num&#125;)//upto 实现循环阶乘</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">println &quot;向上阶乘：&quot;+fab(5)</span><br><span class="line"></span><br><span class="line">int fab2(int number2)&#123;</span><br><span class="line">    int result = 1</span><br><span class="line">    number2.downto(1,&#123;num-&gt;result *=num&#125;)</span><br><span class="line">    return  result</span><br><span class="line">&#125;</span><br><span class="line">println &quot;向下阶乘：&quot;+fab2(7)</span><br><span class="line"></span><br><span class="line">//累计求和方法,这里的次数由0开始，所以不能用于阶乘的计算</span><br><span class="line">int cal(int number)&#123;</span><br><span class="line">    int sum = 0</span><br><span class="line">    number.times&#123; num-&gt;sum+=num &#125;</span><br><span class="line">    return sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println cal(101) // 计算0-100的结果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//*********字符串在闭包的使用</span><br><span class="line">String str =&quot;string test 1&quot;</span><br><span class="line">str.each &#123;</span><br><span class="line">//    String result -&gt; print result.multiply(2)  //每个字符串输出两次</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查找满主条件的第一个元素</span><br><span class="line">str.find&#123;</span><br><span class="line">    String s-&gt;s.isNumber()  //必须是一个返回布尔类型的闭包</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查找满主条件的所有元素</span><br><span class="line">def list = str.findAll&#123;</span><br><span class="line">    String s -&gt; !s.isNumber()</span><br><span class="line">&#125;</span><br><span class="line">println &quot;列表：&quot;+list.toListString()</span><br><span class="line"></span><br><span class="line">//判断字符串是否满足某个条件</span><br><span class="line">def res = str.any &#123;</span><br><span class="line">    String s-&gt; s.isNumber()</span><br><span class="line">&#125;</span><br><span class="line">println &quot;res:&quot;+res</span><br><span class="line"></span><br><span class="line">//是否每一项满足某个条件</span><br><span class="line">println &quot;every:&quot;+str.every &#123;String s-&gt; s.isNumber()&#125;</span><br><span class="line"></span><br><span class="line">//对字符串中每一项处理</span><br><span class="line">def list2 = str.collect &#123;</span><br><span class="line">    it.toUpperCase()</span><br><span class="line">&#125;</span><br><span class="line">println &quot;list2:&quot;+list2.toListString()</span><br></pre></td></tr></table></figure></p>
<h2 id="闭包的三个重要变量"><a href="#闭包的三个重要变量" class="headerlink" title="闭包的三个重要变量"></a>闭包的三个重要变量</h2><p>this、owner、delegate三个关键字<br>this代表定义闭包的类。<br>owner代表闭包定义处的类或者对象，闭包内部定义闭包中的owner是外层的闭包<br>deleGate 代表任意的对象，默认值就是owner<br>如果在类或者方法中定义闭包，此时this,owner,deleGate是一样的，指向闭包定义处的实例或者类本身<br>如果在闭包中定义闭包，this指向的仍然是闭包处的实例或者类本身，而owner和deleGate指向的最近的闭包对象。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> //定义一个内部类 , 三个变量指向最近的封闭类</span><br><span class="line">class Person&#123;</span><br><span class="line">    def classClosure = &#123;</span><br><span class="line">        println &quot;classClouser this&quot;+this</span><br><span class="line">        println &quot;classClouser this&quot;+owner</span><br><span class="line">        println &quot;classClouser this&quot;+delegate</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    def say()&#123;</span><br><span class="line">        def methodClosure = &#123;</span><br><span class="line">            println &quot;methodClouser this&quot;+this</span><br><span class="line">            println &quot;methodClouser this&quot;+owner</span><br><span class="line">            println &quot;methodClouser this&quot;+delegate</span><br><span class="line">        &#125;</span><br><span class="line">        methodClosure.call()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person person = new Person()</span><br><span class="line">person.classClosure.call()</span><br><span class="line">person.say()</span><br><span class="line"></span><br><span class="line">//在闭包中中定义闭包</span><br><span class="line">def nestClouser = &#123;</span><br><span class="line">    def innerClouser = &#123;</span><br><span class="line">        println &quot;innerClouser this&quot;+this</span><br><span class="line">        println &quot;innerClouser this&quot;+owner</span><br><span class="line">        println &quot;innerClouser this&quot;+delegate</span><br><span class="line">    &#125;</span><br><span class="line">    innerClouser.delegate = person // 修改默认的deleGate.此时deleGate指向person对象</span><br><span class="line"></span><br><span class="line">    innerClouser.call()</span><br><span class="line">&#125;</span><br><span class="line">//this 指向实例本身或者定义处的类，owner和deleGate表示的是距离最近的闭包</span><br><span class="line">nestClouser.call()</span><br></pre></td></tr></table></figure></p>
<h2 id="闭包的委托策略"><a href="#闭包的委托策略" class="headerlink" title="闭包的委托策略"></a>闭包的委托策略</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//委托构造</span><br><span class="line">class Student&#123;</span><br><span class="line">    String name</span><br><span class="line">    def pretty = &#123;</span><br><span class="line">        println &quot;my name is $&#123;name&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String toString()&#123;</span><br><span class="line">        pretty.call()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Teacher&#123;</span><br><span class="line">    String name</span><br><span class="line">&#125;</span><br><span class="line">Student student = new Student(name: &quot;jane&quot;)</span><br><span class="line">Teacher teacher = new Teacher(name: &quot;lay&quot;)</span><br><span class="line">student.toString();</span><br><span class="line">student.pretty.delegate = teacher // 将闭包中的delegate指向teacher</span><br><span class="line">student.pretty.resolveStrategy = Closure.DELEGATE_FIRST  //修改委托策略为 deleGate 默认是owner</span><br><span class="line">student.toString()  //此时会在委托的类中寻找name属性，找不到会回来本身类的内部寻找</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>java工具</tag>
        <tag>gradle，groovy</tag>
      </tags>
  </entry>
  <entry>
    <title>groovy-learn（三）</title>
    <url>/2019/05/22/groovy-learn%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="groovy的高级操作"><a href="#groovy的高级操作" class="headerlink" title="groovy的高级操作"></a>groovy的高级操作</h1><h2 id="对json的操作"><a href="#对json的操作" class="headerlink" title="对json的操作"></a>对json的操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//列表转换成Json</span><br><span class="line">def list = [new Person(name: &apos;david&apos;,age: 13),new Person(name: &apos;jane&apos;,age: 43)]</span><br><span class="line">println JsonOutput.toJson(list)</span><br><span class="line"></span><br><span class="line">//转换Object</span><br><span class="line">def jsonSlpuer = new JsonSlurper()</span><br><span class="line">//jsonSlpuer.parse()</span><br><span class="line"></span><br><span class="line">//模拟发送请求和数据转换</span><br><span class="line">def getNetworkDate(String url)&#123;</span><br><span class="line">    //发送http请求</span><br><span class="line">    def connection = new URL(url).openConnection()</span><br><span class="line">    connection.setRequestMethod(&quot;GET&quot;)</span><br><span class="line">    connection.connect()</span><br><span class="line">    def response = connection.content.text</span><br><span class="line">    //将json转对象</span><br><span class="line">    def jsonSlpuer = new JsonSlurper()</span><br><span class="line">    return jsonSlpuer.parseText(response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def response = getNetworkDate(&apos;&apos;)</span><br><span class="line">println response.data.head.name</span><br></pre></td></tr></table></figure>
<h1 id="groovy对xml文件的处理"><a href="#groovy对xml文件的处理" class="headerlink" title="groovy对xml文件的处理"></a>groovy对xml文件的处理</h1><p>解析XML文件<br><img src="/2019/05/22/groovy-learn（三）/xmlString.png" alt><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def xml = &apos;&apos;&apos; &apos;&apos;&apos;</span><br><span class="line">def xmlSluper = new XmlSlurper()</span><br><span class="line">def result = xmlSluper.parseText(xml)</span><br><span class="line">println result.value.books[0].book[0].title.text()</span><br><span class="line">println result.value.books[0].book[0].@avaliable</span><br><span class="line"></span><br><span class="line">//根据作者赛筛选数据</span><br><span class="line">def bookList = []</span><br><span class="line">result.value.books.each&#123; books-&gt;</span><br><span class="line">    books.book.each&#123; book-&gt;</span><br><span class="line">        def author = book.author.text()</span><br><span class="line">        if(author.equals(&quot;李刚&quot;))&#123;</span><br><span class="line">            bookList.add(book.title.text())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//深层遍历</span><br><span class="line">def titles = result.depthFirst().findAll &#123;book-&gt;</span><br><span class="line">    return book.author.text() == &apos;李刚&apos;? true :false</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//创建XML</span><br><span class="line">def sw = new StringWriter()</span><br><span class="line">def xmlBuilder = new MarkupBuilder(sw)</span><br><span class="line">xmlBuilder.langs(type:&apos;current&apos;)&#123;</span><br><span class="line">    language(flavor:&apos;static&apos;)</span><br><span class="line">    language(flavor:&apos;public&apos;)</span><br><span class="line">    language(flavor:&apos;private&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println sw</span><br></pre></td></tr></table></figure></p>
<h1 id="groovy-对文件的处理"><a href="#groovy-对文件的处理" class="headerlink" title="groovy 对文件的处理"></a>groovy 对文件的处理</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//读取文件</span><br><span class="line">def file = new File(&apos;../../helloGroovy.iml&apos;)</span><br><span class="line">file.eachLine &#123;line-&gt;</span><br><span class="line">    println line</span><br><span class="line">&#125;</span><br><span class="line">打印出全部的文件信息</span><br><span class="line">println file.text</span><br><span class="line">打印一部分文件的信息</span><br><span class="line">def  reader = file.withReader &#123;reader-&gt;</span><br><span class="line">    char[] buffer = new char[100]</span><br><span class="line">    reader.read(buffer)</span><br><span class="line">    return buffer</span><br><span class="line">&#125;</span><br><span class="line">println reader</span><br><span class="line"></span><br><span class="line">def copy(String sourcePath,String destationPath)&#123;</span><br><span class="line">    def desFile = new File(destationPath)</span><br><span class="line">    if(!desFile.exists())&#123;</span><br><span class="line">        desFile.createNewFile()</span><br><span class="line">    &#125;</span><br><span class="line">    //copy</span><br><span class="line">    new File(sourcePath).withReader &#123;reader-&gt;</span><br><span class="line">        def lines = reader.readLines()</span><br><span class="line">        desFile.withWriter &#123;writer-&gt;</span><br><span class="line">            lines.each &#123;line-&gt;</span><br><span class="line">                writer.append(line)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br><span class="line">def copy = copy(&apos;../../helloGroovy.iml&apos;,&apos;../../helloGroovy2.iml&apos;)</span><br><span class="line">//测试存/读取对象</span><br><span class="line">def saveObject(Object obj,String path)&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        def desFile = new File(path)</span><br><span class="line">        if(!desFile.exists())&#123;</span><br><span class="line">            desFile.createNewFile()</span><br><span class="line">        &#125;</span><br><span class="line">        desFile.withObjectOutputStream &#123;out-&gt;</span><br><span class="line">            out.writeObject(obj)</span><br><span class="line">        &#125;</span><br><span class="line">        return true</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">        reutrn false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">def readObject(String path)&#123;</span><br><span class="line">    def obj = null</span><br><span class="line">    try&#123;</span><br><span class="line">        def file = new File(path)</span><br><span class="line">        if(file == null || !file.exists())&#123;return null&#125;</span><br><span class="line">        //文件中读取对象</span><br><span class="line">        file.withObjectInputStream &#123;input-&gt;</span><br><span class="line">            obj=input.readObject()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return obj</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line">def person = new Person(name: &quot;david&quot;,age:17)</span><br><span class="line">//saveObject(person,&apos;../../person.bin&apos;)</span><br><span class="line">def result = (Person)readObject(&apos;../../person.bin&apos;)</span><br><span class="line">println  &quot;name: $&#123;result.name&#125;,age:$&#123;result.age&#125;&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>java工具</tag>
        <tag>gradle，groovy</tag>
      </tags>
  </entry>
  <entry>
    <title>groovy-learn（二）</title>
    <url>/2019/05/20/groovy-learn%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="groovy中的数据结构"><a href="#groovy中的数据结构" class="headerlink" title="groovy中的数据结构"></a>groovy中的数据结构</h1><h2 id="groovy中列表的操作"><a href="#groovy中列表的操作" class="headerlink" title="groovy中列表的操作"></a>groovy中列表的操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//列表</span><br><span class="line">//def list = new ArrayList(); java中定义列表的方式</span><br><span class="line">def list = [1,2,3,4,5]</span><br><span class="line">//println list.class</span><br><span class="line">//println list.size()</span><br><span class="line"></span><br><span class="line">//定义数组的方式</span><br><span class="line">//def array = [1,2,3,4,5] as int[]</span><br><span class="line">//int[] array2 = [1,2,3,4,5]</span><br><span class="line"></span><br><span class="line">//对列表进行排序</span><br><span class="line">def sortList = [5,9,3,5,-2]</span><br><span class="line">//Collections.sort(sortList)</span><br><span class="line">Comparator comparator = &#123;</span><br><span class="line">    a,b-&gt; Math.abs(b)&gt;Math.abs(a) ? 1 :  -1  //比较的逻辑和结果是反的？？？</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(sortList,comparator)</span><br><span class="line">println  sortList</span><br><span class="line"></span><br><span class="line">def strList = [&apos;sd&apos;,&apos;ddqw&apos;,&apos;qwefcf&apos;,&apos;a&apos;]</span><br><span class="line">strList.sort&#123;it-&gt;return it.size()&#125;</span><br><span class="line"></span><br><span class="line">//列表的查找</span><br><span class="line">def findList = [1,6,9,4,11]</span><br><span class="line">//int result = findList.find &#123;</span><br><span class="line">//    return it%2==0</span><br><span class="line">//&#125;</span><br><span class="line">//def result = findList.findAll &#123;</span><br><span class="line">//    return it%2!=0</span><br><span class="line">//&#125;</span><br><span class="line">//def result = findList.min&#123;return Math.abs(it)&#125;</span><br><span class="line">//def result = findList.max&#123;return Math.abs(it)&#125;</span><br><span class="line">//def result = findList.count &#123;return it&gt;10&#125;</span><br><span class="line">//println result</span><br><span class="line"></span><br><span class="line">//list的元素添加</span><br><span class="line">findList.add(8)</span><br><span class="line">findList.leftShift(7)</span><br><span class="line">findList&lt;&lt;13</span><br><span class="line">//println findList</span><br><span class="line"></span><br><span class="line">//list的删除操作</span><br><span class="line">findList.remove(7)//移除下标的元素</span><br><span class="line">findList.remove((java.lang.Object) 7)//移除元素</span><br><span class="line">println findList</span><br></pre></td></tr></table></figure>
<h2 id="groovy中的映射"><a href="#groovy中的映射" class="headerlink" title="groovy中的映射"></a>groovy中的映射</h2><p>map在groovy中的定义<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//map的定义</span><br><span class="line">def colors = [red:&apos;ff00000&apos;,green:&apos;00ff00&apos;,blue:&apos;0000ff&apos;]</span><br><span class="line">//map查询</span><br><span class="line">//println colors[&apos;red&apos;]</span><br><span class="line">//println colors.red</span><br><span class="line">//添加元素</span><br><span class="line">colors.yellow = &apos;ffff00&apos;</span><br><span class="line">//println colors.toMapString( )</span><br><span class="line"></span><br><span class="line">//map的遍历</span><br><span class="line">def stu = [1:[num:&apos;001&apos;,name:&apos;boa&apos;,score:11],</span><br><span class="line">           2:[num:&apos;002&apos;,name:&apos;bob&apos;,score:57],</span><br><span class="line">           3:[num:&apos;003&apos;,name:&apos;boc&apos;,score:89],</span><br><span class="line">           4:[num:&apos;004&apos;,name:&apos;bod&apos;,score:94]</span><br><span class="line">            ]</span><br><span class="line">stu.each &#123;</span><br><span class="line">    def student-&gt;</span><br><span class="line">        println &quot;the key is $&#123;student.key&#125;,the value is $&#123;student.value&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">//直接遍历key ,value</span><br><span class="line">stu.eachWithIndex&#123; key,value,index -&gt;</span><br><span class="line">    println &quot;the key is $&#123;key&#125;,the value is $&#123;value&#125; index is $&#123;index&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//map中的查找</span><br><span class="line">def entry = stu.find &#123;def student -&gt;return student.value.score&gt;60&#125;</span><br><span class="line">//println  entry</span><br><span class="line"></span><br><span class="line">def names = stu.findAll &#123;def student -&gt;return student.value.score&gt;60&#125;.collect &#123;return it.value.name&#125;</span><br><span class="line">//println names</span><br><span class="line"></span><br><span class="line">//map的排序</span><br><span class="line">def sort = stu.sort &#123;def stu1,def stu2 -&gt;</span><br><span class="line">    Number score1 = stu1.value.score</span><br><span class="line">    Number score2 = stu2.value.score</span><br><span class="line">    return score1 == score2 ? 0 :score1&lt;score2? -1: 1</span><br><span class="line">&#125;</span><br><span class="line">println  sort</span><br></pre></td></tr></table></figure></p>
<h2 id="groovy中的范围"><a href="#groovy中的范围" class="headerlink" title="groovy中的范围"></a>groovy中的范围</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//定义范围</span><br><span class="line">def range = 1..10</span><br><span class="line"></span><br><span class="line">println range[0]//获取范围中的元素,取第一个数</span><br><span class="line">println range.contains(7)//判断是否包含某个元素</span><br><span class="line">println range.from//起始值</span><br><span class="line">println range.to//中止值</span><br><span class="line">//遍历</span><br><span class="line">range.each &#123;</span><br><span class="line">    println it</span><br><span class="line">&#125;</span><br><span class="line">//范围的应用</span><br><span class="line">def getGrade(Number number) &#123;</span><br><span class="line">    def result</span><br><span class="line">    switch (number) &#123;</span><br><span class="line">        case 0..60:</span><br><span class="line">            result = &quot;不及格&quot;</span><br><span class="line">            break</span><br><span class="line">        case 61..100:</span><br><span class="line">            result = &quot;及格&quot;</span><br><span class="line">            break</span><br><span class="line">    &#125;</span><br><span class="line">    println result</span><br><span class="line">&#125;</span><br><span class="line">getGrade(71)</span><br></pre></td></tr></table></figure>
<h1 id="groovy中的面向对象类，接口的使用"><a href="#groovy中的面向对象类，接口的使用" class="headerlink" title="groovy中的面向对象类，接口的使用"></a>groovy中的面向对象类，接口的使用</h1><p>创建 new Groovy Class<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 默认为class</span><br><span class="line">// 默认继承groovyObject类</span><br><span class="line">class Person &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Integer age;</span><br><span class="line"></span><br><span class="line">    def increaseAge(Integer year)&#123;</span><br><span class="line">        age += year;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建groovy的脚本 groovy script类型 objectstu<br>操作对象的属性和方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person person = new Person(name: &apos;david&apos;,age: 22)</span><br><span class="line">println &quot;person&apos;s name is $&#123;person.name&#125; .person&apos;s age is $&#123;person.age&#125;&quot;</span><br><span class="line">person.increaseAge(12)</span><br><span class="line">person.play()</span><br><span class="line">person.eat()</span><br></pre></td></tr></table></figure></p>
<p>创建groovy中的接口<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> //接口中的方法只能是public</span><br><span class="line">interface Action &#123;</span><br><span class="line">    def eat()</span><br><span class="line">    def drink()</span><br><span class="line">    def play()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Trait类似Interface,可以定义默认的实现方法，java8中也能配置接口默认实现方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">trait DefaultAction &#123;</span><br><span class="line">    abstract void eat()</span><br><span class="line">    void play()&#123;</span><br><span class="line">        println &quot;play&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h1><p>groovy中方法的调用顺序如图<br><img src="/2019/05/20/groovy-learn（二）/yuan.png" alt><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">println person.cry()</span><br></pre></td></tr></table></figure></p>
<p>会报错groovy.lang.MissingMethodException: No signature of method<br>重写Person类中的invokeMethod方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 一个方法寻找不到调用此方法</span><br><span class="line"> */</span><br><span class="line">    @Override</span><br><span class="line">    Object invokeMethod(String s, Object o) &#123;</span><br><span class="line">        return &quot;method name is $&#123;s&#125;,param is $&#123;o&#125;&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>再次运行程序打印方法名称和参数<br>同理也可以重写methodMissing方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def methodMissing(String name,Object args)&#123;</span><br><span class="line">    return &quot;method2 name is $&#123;name&#125;,param is $&#123;args&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="metaClass的使用"><a href="#metaClass的使用" class="headerlink" title="metaClass的使用"></a>metaClass的使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为类动态新增一个属性 </span><br><span class="line">Person.metaClass.sex = &apos;male&apos;</span><br><span class="line">Person p1 = new Person(name: &apos;jane&apos;,age: 23)</span><br><span class="line">println p1.sex</span><br><span class="line">//为类动态生成方法</span><br><span class="line">Person.metaClass.upper = &#123;-&gt;sex.toUpperCase()&#125;</span><br><span class="line">println p1.upper()</span><br><span class="line">//生成静态方法</span><br><span class="line">Person.metaClass.static.createPerson=&#123;String name,Integer age-&gt;new Person(name:name,age:age)&#125;</span><br><span class="line">Person p2 =  Person.createPerson(&quot;test&quot;,3)</span><br><span class="line">println p2.name+&quot; and &quot;+p2.getAge()</span><br></pre></td></tr></table></figure>
<p>如果想要注入的方法或者属性全局可用<br>在外部的注入方法前添加<br>ExpandMetaClass.enableGlobally()</p>
]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>java工具</tag>
        <tag>gradle，groovy</tag>
      </tags>
  </entry>
  <entry>
    <title>java NIO</title>
    <url>/2019/04/15/java-IOandNIO%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p>操作系统都是采用的虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操心系统的核心是内核，操心系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。</p>
<p>在Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。</p>
<h1 id="二、IO模式"><a href="#二、IO模式" class="headerlink" title="二、IO模式"></a>二、IO模式</h1><p><strong>进程是无法直接操作I/O设备的，其必须通过系统调用请求内核来协助完成I/O动作，而内核会为每个I/O设备维护一个buffer</strong>。</p>
<p><img src="/2019/04/15/java-IOandNIO（一）/E:/blog\source\_posts\java-IOandNIO（一）\nio.png" alt></p>
<p>具体的请求过程为： <strong>户进程发起请求，内核接受到请求后，从I/O设备中获取数据到buffer中，再将buffer中的数据copy到用户进程的地址空间，该用户进程获取到数据。</strong></p>
<p>IO按照阻塞和同步异步可大致分为以下五种</p>
<h3 id="1、阻塞I-O"><a href="#1、阻塞I-O" class="headerlink" title="1、阻塞I/O"></a>1、阻塞I/O</h3><p>​    阻塞型IO(Blocking I/O),BIO是一种同步的阻塞IO，一请求一应答通信模型，通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在while(true) 循环中服务端会调用 accept() 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，IO在进行读写时，该线程将被阻塞，    此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接，如下图所示。</p>
<p><img src="/2019/04/15/java-IOandNIO（一）/bio-model.png" alt></p>
<h3 id="2、非阻塞I-O"><a href="#2、非阻塞I-O" class="headerlink" title="2、非阻塞I/O"></a>2、非阻塞I/O</h3><p>NIO是一种<strong>同步非阻塞</strong>的I/O模型，java 1.4中引入了NIO的框架，提供了 Channel , Selector，Buffer等抽象。它支持面向缓冲的，基于通道的I/O操作方法， NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 **SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。</p>
<p><img src="/2019/04/15/java-IOandNIO（一）/nio-model.png" alt></p>
<p><strong>IO流是阻塞的，NIO流是不阻塞的。</strong></p>
<p>Java NIO使我们可以进行非阻塞IO操作。比如说，<strong>单线程中从通道读取数据到buffer，同时可以继续做别的事情</strong>，当数据读取到buffer中后，线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</p>
<p>Java IO的各种流是阻塞的。这意味着，<strong>当一个线程调用 read() 或 write() 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。</strong>该线程在此期间不能再干任何事情了</p>
<p><strong>IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。</strong></p>
<ul>
<li>NIO类库加入Buffer对象，即所有数据都是用缓冲区处理的，在读取数据时，它是直接读到缓冲区中，在写入数据时，写入数据区中。任何时间访问NIO中的数据，都是通过缓冲区进行操作。<br>最常用的缓冲区是ByteBuffer，一个ByteBuffer用于操作byte数组。<strong>每一种Java基本类型都对应一种缓冲区（除了boolean类型）</strong></li>
<li>在面向流IO中，，可以将数据直接写入或者将数据直接读到Stream中，虽然Stream中也有Buffer开头的扩展类，但是只是流的包装类，还是从流读到缓冲区。</li>
</ul>
<h4 id="Channel-通道"><a href="#Channel-通道" class="headerlink" title="Channel (通道)"></a>Channel (通道)</h4><p><strong>NIO通过Channel（通道）进行读写。</strong><br>通道是<strong>双向的</strong>，可读可写，而流是单向。因为通道只能和Buffer交互，因为Buffer，通道可以异步的读写。</p>
<h3 id="3、IO复用"><a href="#3、IO复用" class="headerlink" title="3、IO复用"></a>3、IO复用</h3><p>（I/O Multiplexing）</p>
<p>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。类似于select、epoll、poll。用一个线程不断的轮询所有的socket,用户进程可以直接从这个监视线程中获取socket的数据是否准备好了。当某个用户进程调用了这个监视线程（select、epoll、poll），该线程会被block，内核会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从内核拷贝到用户进程。</p>
<h4 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h4><p>​        操作系统将每一个外部的设备操作都可以看作一个文件来操作，们对一个文件的读写，都通过调用内核提供的系统调用；内核给我们返回一个filed scriptor（fd,文件描述符）。而对一个socket的读写也会有相应的描述符，称为socketfd(socket描述符）。描述符就是一个数字，指向内核中一个结构体（文件路径，数据区，等一些属性）。那么我们的应用程序对文件的读写就通过对描述符的读写完成。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>​        select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。但是select的缺点也正因为select每次都要遍历，所以效率比较低下，而且需要维护一个用来存放fd的数据空间，用户空间和内核空间在传递该结构时性能消耗高。select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FDSETSIZE设置，32位机默认是1024个，64位机默认是2048。</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>​    poll和select本质上没有区别，将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。它没有最大连接数的限制，原因是它是基于链表来存储的，但是存在内核态到用户态的数据复制。poll还有一个特点是水平触发，上一次报告的fd但是没有被处理，下一次报告仍然会报告该fd。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>​        相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>
<p>​    epoll的优势：</p>
<p>​        1、没有了连接数的限制，能打开的连接数不在受限于fd,</p>
<p>​        2、不使用轮询的方式，而是类似于事件的回调方法，不会出现大量输出的重复复制数据传递。</p>
<h3 id="信号驱动的I-O"><a href="#信号驱动的I-O" class="headerlink" title="信号驱动的I/O"></a>信号驱动的I/O</h3><p>信号驱动的I/O是不阻塞的，用户进程创建sigio信号的处理程序，并通过sigaction方法来执行信号二点处理，这个时候用户进程可以做其他的事情，当数据准备就绪以后变为该用户进程生成一个sigio的信号，通知该进程数据已经就绪，此时用户进程将数据拷贝至用户内存，返回结果。</p>
<p><img src="/2019/04/15/java-IOandNIO（一）/E:/blog\source\_posts\java-IOandNIO（一）\sio-model.png" alt></p>
<h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h3><p>一般来说，这些函数通过告诉内核启动操作并在整个操作（包括内核的数据到缓冲区的副本）完成时通知我们。这个模型和前面的信号驱动I/O模型的主要区别是，在信号驱动的I/O中，内核告诉我们何时可以启动I/O操作，但是异步I/O时，内核告诉我们何时I/O操作完成。</p>
<p>当用户进程向内核发起某个操作后，会立刻得到返回，并把所有的任务都交给内核去完成（包括将数据从内核拷贝到用户自己的缓冲区），内核完成之后，只需返回一个信号告诉用户进程已经完成就可以了。</p>
<p><img src="/2019/04/15/java-IOandNIO（一）/aio-model.png" alt></p>
<h2 id="浅谈零拷贝"><a href="#浅谈零拷贝" class="headerlink" title="浅谈零拷贝"></a>浅谈零拷贝</h2><p>零拷贝是服务器网络编程的一个关键字，CPU不执行拷贝数据从一个存储区域到另一个存储区域的任务，这通常用于在网络上传输文件时节省CPU周期和内存带宽，在java语言中，常用的零拷贝有mmap 和 sendFile，</p>
<p>传统数据的读写过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">File file = new File(&quot;index.html&quot;);</span><br><span class="line">     RandomAccessFile raf = new RandomAccessFile(file, &quot;rw&quot;);</span><br><span class="line"></span><br><span class="line">     byte[] arr = new byte[(int) file.length()];</span><br><span class="line">     raf.read(arr);</span><br><span class="line"></span><br><span class="line">     Socket socket = new ServerSocket(8080).accept();</span><br><span class="line">     socket.getOutputStream().write(arr);</span><br></pre></td></tr></table></figure>
<p>上述代码的功能是用read方法读取index.html,转换成字节数组，然后调用write方法，将index.html字节流写道socket中。在操作系统层发生了下面的过程。</p>
<p><img src="/2019/04/15/java-IOandNIO（一）/copy.png" alt></p>
<p>在上述的方法中发生拷贝操作如下</p>
<p>1、在读取内存文件时，直接从内存中获取数据，并拷贝到内存缓存区 </p>
<p>2、将内存缓存区的数据拷贝到用户的缓存区，同时发生了一次上下文切换 内核太态-&gt;用户态  </p>
<p> read完成</p>
<p>3、调用write方法时，将数据从用户缓存区拷贝到Socket缓存区，此时有发生了一次上下文切换到内核态</p>
<p>4、数据从socket缓存区拷贝到网络协议引擎。不需要上下文切换</p>
<p>5、write方法返回，最后从内核态切换到用户态</p>
<p>上述在OS中的复制操作太多了。所以有了下面的优化方法</p>
<p>mmap优化方法</p>
<p>mmap 通过内存映射，将文件映射到内核缓冲区，此时在读取文件时不需要再进行内存态到用户态的切换，可以减少内存到用户的拷贝此说。</p>
<p>sendFile方法</p>
<p> Linux 2.1 版本 提供了 sendFile 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 Socket Buffer，同时，由于和用户态完全无关，就减少了一次上下文切换。</p>
<p>数据被 DMA 引擎从文件复制到内核缓冲区，然后调用，然后掉write 方法时，从内核缓冲区进入到 Socket，这时，是没有上下文切换的，因为在一个用户空间。</p>
<h1 id="三、NIO与IO对程序设计的影响"><a href="#三、NIO与IO对程序设计的影响" class="headerlink" title="三、NIO与IO对程序设计的影响"></a>三、NIO与IO对程序设计的影响</h1><p>使用NIO与IO的调用接口不同，使用NIO与IO的对比。<br><img src="/2019/04/15/java-IOandNIO（一）/streamAndThread.png" alt><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Name: Anna </span><br><span class="line">Age: 25</span><br><span class="line">Email: anna@mailserver.com </span><br><span class="line">Phone: 1234567890</span><br></pre></td></tr></table></figure><br>以IO的方式逐行读取文本数据<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream input = ... ; <span class="comment">// get the InputStream from the client socket   </span></span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(input));   </span><br><span class="line">String nameLine   = reader.readLine(); </span><br><span class="line">String ageLine    = reader.readLine(); </span><br><span class="line">String emailLine  = reader.readLine(); </span><br><span class="line">String phoneLine  = reader.readLine();</span><br></pre></td></tr></table></figure></p>
<p>以IO方式逐行读取每行的数据时，readLine()读取完数据之前，IO读取流被阻塞，所以第一个获取的是姓名信息，第二个readLine()获取的是年龄信息，能够确定每一步的读数据获取到的数据。以NIO的方式读取文本数据<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>); <span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buffer);</span><br></pre></td></tr></table></figure></p>
<p>在第二行中，冲通道读取字节到ByteBuffer。当这个方法调用返回时，你不知道你所需的所有数据是否在缓冲区内。你所知道的是，该缓冲区包含一些字节，这使得处理有点困难。假设第一次 read(buffer)调用后，读入缓冲区的数据只有半行，例如，“Name:An”，你能处理数据吗？显然不能，需要等待，直到整行数据读入缓存，所以，你怎么知道是否该缓冲区包含足够的数据可以处理呢？好了，你不知道。发现的方法只能查看缓冲区中的数据。其结果是，在你知道所有数据都在缓冲区里之前，你必须检查几次缓冲区的数据。这不仅效率低下，而且可以使程序设计方案杂乱不堪。例如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);   </span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buffer);   </span><br><span class="line"><span class="keyword">while</span>(! bufferFull(bytesRead) ) &#123;   </span><br><span class="line">       bytesRead = inChannel.read(buffer);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bufferFull()方法必须跟踪有多少数据读入缓冲区，并返回真或假，这取决于缓冲区是否已满。换句话说，如果缓冲区准备好被处理，那么表示缓冲区满了。bufferFull()方法扫描缓冲区，但必须保持在bufferFull（）方法被调用之前状态相同。如果没有，下一个读入缓冲区的数据可能无法读到正确的位置。这是不可能的，但却是需要注意的又一问题。如果缓冲区已满，它可以被处理。如果它不满，并且在你的实际案例中有意义，你或许能处理其中的部分数据。但是许多情况下并非如此。下图展示了“缓冲区数据循环就绪”：<br><img src="/2019/04/15/java-IOandNIO（一）/buffer.png" alt></p>
<h2 id="缓冲区Buffer"><a href="#缓冲区Buffer" class="headerlink" title="缓冲区Buffer"></a>缓冲区Buffer</h2><p>&ensp;&ensp;&ensp;&ensp;NIO中有两个核心对象，通道和缓冲区。缓冲区的本质是一个数组，其中添加了三个属性跟踪缓冲区的内部状态变化。其实就是STL库中Vector的设计。<br><strong>position</strong>：指定了下一个将要被写入或者读取的元素索引，它的值由get()/put()方法自动更新，在新创建一个Buffer对象时，position被初始化为0。<br><strong>limit</strong>：指定还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。<br><strong>capacity</strong>：指定了可以存储在缓冲区中的最大数据容量，实际上，它指定了底层数组的大小，或者至少是指定了准许我们使用的底层数组的容量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  public static void main(String[] args) throws Exception&#123;</span><br><span class="line">      FileInputStream fin = new FileInputStream(&quot;c:\\test.txt&quot;);</span><br><span class="line">//获取通道连接</span><br><span class="line">      FileChannel fc = fin.getChannel();</span><br><span class="line">//初始化大小为10byte的缓冲区</span><br><span class="line">      ByteBuffer buffer = ByteBuffer.allocate(10);</span><br><span class="line">//通道读取缓冲区数据，此时 position =10,limit=10,capacity=10</span><br><span class="line">      fc.read(buffer);</span><br><span class="line">//从缓冲区读取数据前.position =0,limit =10;</span><br><span class="line">      buffer.flip();</span><br><span class="line">//get()使position递增而limit不变</span><br><span class="line">      while (buffer.remaining() &gt; 0) &#123;</span><br><span class="line">          byte b = buffer.get();</span><br><span class="line">          // System.out.print(((char)b));</span><br><span class="line">      &#125;</span><br><span class="line">//将状态回复到初始的状态</span><br><span class="line">      buffer.clear();</span><br><span class="line">      fin.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>缓冲区的分配其实就是一个数组形式的数据分配，使用了allocate来指定缓冲区的容量。<br>缓冲区的分片，在原本的缓存区对象上切出一片来创建一个子缓冲区，但是新的缓冲区其实和原缓冲区在切出的区域上是数据共享的，勇slice方法创建一个子缓冲区。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(10);</span><br><span class="line">//在缓冲区中放入0-9</span><br><span class="line">for (int i=0; i&lt;buffer.capacity(); i++) &#123;</span><br><span class="line">        buffer.put( (byte)i );</span><br><span class="line">&#125;</span><br><span class="line">//在缓冲区中下标3-7的地方设置为子缓冲区</span><br><span class="line">buffer.position(3);</span><br><span class="line">buffer.limit(7);</span><br><span class="line">ByteBuffer slice = buffer.slice();</span><br><span class="line">//改编子缓冲区的内容</span><br><span class="line">for (int i=0; i&lt;slice.capacity(); i++) &#123;</span><br><span class="line">    byte b = slice.get( i );</span><br><span class="line">    b *= 10;</span><br><span class="line">    slice.put( i, b );</span><br><span class="line">&#125;</span><br><span class="line">//自缓冲区的内容改变，原缓存区的数据也改变</span><br><span class="line">//还原原缓存区的初始位置position和limit</span><br><span class="line">buffer.position( 0 );</span><br><span class="line">buffer.limit( buffer.capacity() );</span><br><span class="line">while (buffer.remaining()&gt;0) &#123;</span><br><span class="line">    System.out.println( buffer.get() );</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(&quot;\n&quot;);</span><br></pre></td></tr></table></figure>
<p>缓存区分片同样可以创建只读缓冲区，可以通过调用缓冲区的asReadOnlyBuffer()方法，将任何常规缓冲区转 换为只读缓冲区，这个方法返回一个与原缓冲区完全相同的缓冲区，并与原缓冲区共享数据，只不过它是只读的。如果原缓冲区的内容发生了变化，只读缓冲区的内容也随之发生变化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 10 );</span><br><span class="line">// 缓冲区中的数据0-9</span><br><span class="line">for (int i=0; i&lt;buffer.capacity(); ++i) &#123;</span><br><span class="line">    buffer.put( (byte)i );</span><br><span class="line">&#125;</span><br><span class="line">// 创建只读缓冲区</span><br><span class="line">ByteBuffer readonly = buffer.asReadOnlyBuffer();</span><br><span class="line">// 改变原缓冲区的内容</span><br><span class="line">for (int i=0; i&lt;buffer.capacity(); ++i) &#123;</span><br><span class="line">    byte b = buffer.get( i );</span><br><span class="line">    b *= 10;</span><br><span class="line">    buffer.put( i, b );</span><br><span class="line">&#125;</span><br><span class="line">readonly.position(0);</span><br><span class="line">readonly.limit(buffer.capacity());</span><br><span class="line">// 只读缓冲区的内容也随之改变</span><br><span class="line">while (readonly.remaining()&gt;0) &#123;</span><br><span class="line">    System.out.println( readonly.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;通道既不是一个扩展也不是一项增强，而是全新的、极好的Java I/O示例，提供与I/O服务的直接连接。Channel用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据。<br>&ensp;&ensp;&ensp;&ensp;通道是一种途径，缓存区是通道内部的数据发送和接收的单位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Channel extends Closeable &#123;</span><br><span class="line">    public boolean isOpen();</span><br><span class="line">    public void close() throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Channel接口里面有两个接口，isOpen()是判断通道是否打开，close()是关闭通道的接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//只读通道接口</span><br><span class="line">public interface ReadableByteChannel extends Channel &#123;</span><br><span class="line">    public int read(ByteBuffer dst) throws IOException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//写入通道接口</span><br><span class="line">public interface WritableByteChannel extends Channel &#123;</span><br><span class="line">	    public int write(ByteBuffer src) throws IOException;</span><br><span class="line">&#125;</span><br><span class="line">//读写通道</span><br><span class="line">public interface ByteChannel extends ReadableByteChannel, WritableByteChannel &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;通道有阻塞和非阻塞模式，非阻塞模式的通道不会造成线程休眠，要么完成，要么返回状态。只有流的通道(如sockets、pipes)，才可以使用非阻塞的模式<br>下方是SocketChannel</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class SocketChannel</span><br><span class="line">    extends AbstractSelectableChannel</span><br><span class="line">    implements ByteChannel, ScatteringByteChannel, GatheringByteChannel&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">public abstract class AbstractSelectableChannel</span><br><span class="line">    extends SelectableChannel</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，socket通道类从SelectableChannel类引申而来，从SelectableChannel引申而来的类可以和支持有条件的选择的选择器（Selectors）一起使用。将非阻塞I/O和选择器组合起来可以使开发者的程序利用多路复用I/O</p>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>Selector运行单线程处理多个Channel，如果你的应用打开了多个通道，但每个连接的流量都很低，使用Selector就会很方便。例如在一个聊天服务器中。要使用Selector, 得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新的连接进来、数据接收等。</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Channel和IO中的Stream(流)是差不多一个等级的。只不过Stream是单向的，譬如：InputStream, OutputStream.而Channel是双向的，既可以用来进行读操作，又可以用来进行写操作。</p>
<p>FileChannel、 DatagramChannel、 SocketChannel、 ServerSocketChannel。</p>
<p>分别可以对应文件IO、UDP和TCP（Server和Client）</p>
<h1 id="四、NIO的使用"><a href="#四、NIO的使用" class="headerlink" title="四、NIO的使用"></a>四、NIO的使用</h1><h2 id="FileChannel的使用"><a href="#FileChannel的使用" class="headerlink" title="FileChannel的使用"></a>FileChannel的使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       RandomAccessFile aFile = null;</span><br><span class="line">       try&#123;</span><br><span class="line">           aFile = new RandomAccessFile(&quot;C:/Users/sd/Desktop/file.txt&quot;,&quot;rw&quot;);</span><br><span class="line">           FileChannel fileChannel = aFile.getChannel();</span><br><span class="line">           ByteBuffer buf = ByteBuffer.allocate(1024);</span><br><span class="line">           int bytesRead = fileChannel.read(buf);</span><br><span class="line">           System.out.println(bytesRead);</span><br><span class="line">           while(bytesRead != -1)</span><br><span class="line">           &#123;</span><br><span class="line">               buf.flip();</span><br><span class="line">               while(buf.hasRemaining())</span><br><span class="line">               &#123;</span><br><span class="line">                   System.out.print((char)buf.get());</span><br><span class="line">               &#125;</span><br><span class="line">               buf.compact();</span><br><span class="line">               bytesRead = fileChannel.read(buf);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;catch (IOException e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;finally&#123;</span><br><span class="line">           try&#123;</span><br><span class="line">               if(aFile != null)&#123;</span><br><span class="line">                   aFile.close();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;catch (IOException e)&#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码可以看见使用了下面的方法</p>
<ul>
<li>分配空间（ByteBuffer buf = ByteBuffer.allocate(1024); 还有一种allocateDirector后面再陈述）</li>
<li>写入数据到Buffer(int bytesRead = fileChannel.read(buf);)</li>
<li>调用filp()方法（ buf.flip();）</li>
<li>从Buffer中读取数据（System.out.print((char)buf.get());）</li>
<li>调用clear()方法或者compact()方法</li>
</ul>
<p>向Buffer中写数据：</p>
<ul>
<li>从Channel写到Buffer (fileChannel.write(buf))</li>
<li>通过Buffer的put()方法 （buf.put(…)）</li>
</ul>
<p>从Buffer中读取数据：</p>
<ul>
<li>从Buffer读取到Channel (channel.read(buf))</li>
<li>使用get()方法从Buffer中读取数据 （buf.get()）</li>
</ul>
<h2 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h2><p>说完了FileChannel和Buffer, 大家应该对Buffer的用法比较了解了，这里使用SocketChannel来继续探讨NIO。NIO的强大功能部分来自于Channel的非阻塞特性，套接字的某些操作可能会无限期地阻塞。例如，对accept()方法的调用可能会因为等待一个客户端连接而阻塞；对read()方法的调用可能会因为没有数据可读而阻塞，直到连接的另一端传来新的数据。总的来说，创建/接收连接或读写数据等I/O调用，都可能无限期地阻塞等待，直到底层的网络实现发生了什么。慢速的，有损耗的网络，或仅仅是简单的网络故障都可能导致任意时间的延迟。然而不幸的是，在调用一个方法之前无法知道其是否阻塞。NIO的channel抽象的一个重要特征就是可以通过配置它的阻塞行为，以实现非阻塞式的信道。</p>
<p>服务端代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Server &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = null;</span><br><span class="line">        InputStream in = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            serverSocket = new ServerSocket(8081);</span><br><span class="line">            int recvMsgSize = 0;</span><br><span class="line">            byte[] recvBuf = new byte[1024];</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                Socket clientSocket = serverSocket.accept();</span><br><span class="line">                SocketAddress clientAddress = clientSocket.getRemoteSocketAddress();</span><br><span class="line">                System.out.println(&quot;Handling client at &quot; + clientAddress);</span><br><span class="line">                in = clientSocket.getInputStream();</span><br><span class="line">                while ((recvMsgSize = in.read(recvBuf)) != -1) &#123;</span><br><span class="line">                    byte[] temp = new byte[recvMsgSize];</span><br><span class="line">                    System.arraycopy(recvBuf, 0, temp, 0, recvMsgSize);</span><br><span class="line">                    System.out.println(Arrays.toString(temp));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (serverSocket != null) &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if (in != null) &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">        SocketChannel socketChannel = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            socketChannel = SocketChannel.open();</span><br><span class="line">            socketChannel.configureBlocking(false);</span><br><span class="line">            socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 8081));</span><br><span class="line">            if (socketChannel.finishConnect()) &#123;</span><br><span class="line">                int i = 0;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                    String info = &quot;I&apos;m &quot; + i++ + &quot;-th information from client&quot;;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    buffer.put(info.getBytes());</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    while (buffer.hasRemaining()) &#123;</span><br><span class="line">                        System.out.println(buffer);</span><br><span class="line">                        socketChannel.write(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (socketChannel != null) &#123;</span><br><span class="line">                    socketChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TCP服务端的NIO写法"><a href="#TCP服务端的NIO写法" class="headerlink" title="TCP服务端的NIO写法"></a>TCP服务端的NIO写法</h2><p>Selector类可以用于避免使用阻塞式客户端中很浪费资源的“忙等”方法。例如，考虑一个IM服务器。像QQ或者旺旺这样的，可能有几万甚至几千万个客户端同时连接到了服务器，但在任何时刻都只是非常少量的消息。需要读取和分发。这就需要一种方法阻塞等待，直到至少有一个信道可以进行I/O操作，并指出是哪个信道。</p>
<p>​    NIO的选择器就实现了这样的功能。一个Selector实例可以同时检查一组信道的I/O状态。用专业术语来说，选择器就是一个多路开关选择器，因为一个选择器能够管理多个信道上的I/O操作。然而如果用传统的方式来处理这么多客户端，使用的方法是循环地一个一个地去检查所有的客户端是否有I/O操作，如果当前客户端有I/O操作，则可能把当前客户端扔给一个线程池去处理，如果没有I/O操作则进行下一个轮询，当所有的客户端都轮询过了又接着从头开始轮询；这种方法是非常笨而且也非常浪费资源，因为大部分客户端是没有I/O操作，我们也要去检查；而Selector就不一样了，它在内部可以同时管理多个I/O，当一个信道有I/O操作的时候，他会通知Selector，Selector就是记住这个信道有I/O操作，并且知道是何种I/O操作，是读呢？是写呢？还是接受新的连接；所以如果使用Selector，它返回的结果只有两种结果，一种是0，即在你调用的时刻没有任何客户端需要I/O操作，另一种结果是一组需要I/O操作的客户端，这时你就根本不需要再检查了，因为它返回给你的肯定是你想要的。这样一种通知的方式比那种主动轮询的方式要高效得多！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ServerConnect</span><br><span class="line">&#123;</span><br><span class="line">    private static final int BUF_SIZE=1024;</span><br><span class="line">    private static final int PORT = 8080;</span><br><span class="line">    private static final int TIMEOUT = 3000;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        selector();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void handleAccept(SelectionKey key) throws IOException&#123;</span><br><span class="line">        ServerSocketChannel ssChannel = (ServerSocketChannel)key.channel();</span><br><span class="line">        SocketChannel sc = ssChannel.accept();</span><br><span class="line">        sc.configureBlocking(false);</span><br><span class="line">        sc.register(key.selector(), SelectionKey.OP_READ,ByteBuffer.allocateDirect(BUF_SIZE));</span><br><span class="line">    &#125;</span><br><span class="line">    public static void handleRead(SelectionKey key) throws IOException&#123;</span><br><span class="line">        SocketChannel sc = (SocketChannel)key.channel();</span><br><span class="line">        ByteBuffer buf = (ByteBuffer)key.attachment();</span><br><span class="line">        long bytesRead = sc.read(buf);</span><br><span class="line">        while(bytesRead&gt;0)&#123;</span><br><span class="line">            buf.flip();</span><br><span class="line">            while(buf.hasRemaining())&#123;</span><br><span class="line">                System.out.print((char)buf.get());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            buf.clear();</span><br><span class="line">            bytesRead = sc.read(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        if(bytesRead == -1)&#123;</span><br><span class="line">            sc.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void handleWrite(SelectionKey key) throws IOException&#123;</span><br><span class="line">        ByteBuffer buf = (ByteBuffer)key.attachment();</span><br><span class="line">        buf.flip();</span><br><span class="line">        SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">        while(buf.hasRemaining())&#123;</span><br><span class="line">            sc.write(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        buf.compact();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void selector() &#123;</span><br><span class="line">        Selector selector = null;</span><br><span class="line">        ServerSocketChannel ssc = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            ssc= ServerSocketChannel.open();</span><br><span class="line">            ssc.socket().bind(new InetSocketAddress(PORT));</span><br><span class="line">            ssc.configureBlocking(false);</span><br><span class="line">            ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                if(selector.select(TIMEOUT) == 0)&#123;</span><br><span class="line">                    System.out.println(&quot;==&quot;);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">                while(iter.hasNext())&#123;</span><br><span class="line">                    SelectionKey key = iter.next();</span><br><span class="line">                    if(key.isAcceptable())&#123;</span><br><span class="line">                        handleAccept(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(key.isReadable())&#123;</span><br><span class="line">                        handleRead(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(key.isWritable() &amp;&amp; key.isValid())&#123;</span><br><span class="line">                        handleWrite(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(key.isConnectable())&#123;</span><br><span class="line">                        System.out.println(&quot;isConnectable = true&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                if(selector!=null)&#123;</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if(ssc!=null)&#123;</span><br><span class="line">                    ssc.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;catch(IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这一片段的代码功能是给定的选择器注册该通道,为了将Channel和Selector配合使用，必须将Channel注册到Selector上，通过SelectableChannel.register()方法来实现.</p>
<p>与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</p>
<p>register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">selector = Selector.open();</span><br><span class="line">         ssc = ServerSocketChannel.open();</span><br><span class="line">         ssc.socket().bind(new InetSocketAddress(PORT));</span><br><span class="line">         ssc.configureBlocking(false);</span><br><span class="line">         ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>
<p>当向Selector注册Channel时，register()方法会返回一个SelectionKey对象。这个对象包含了一些你感兴趣的属性：</p>
<ul>
<li>interest集合</li>
<li>ready集合</li>
<li>Channel</li>
<li>Selector</li>
<li>附加的对象（可选）</li>
</ul>
<p>interest集合：Selector注册通道一节中所描述的，interest集合是你所选择的感兴趣的事件集合。可以通过SelectionKey读写interest集合。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int readySet = selectionKey.readyOps();</span><br></pre></td></tr></table></figure>
<p>可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">selectionKey.isAcceptable();selectionKey.isConnectable();selectionKey.isReadable();selectionKey.isWritable();</span><br></pre></td></tr></table></figure>
<p>从SelectionKey访问Channel和Selector很简单。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure>
<p>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">selectionKey.attach(theObject);Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure>
<p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure>
<h3 id="通过Selector选择通道"><a href="#通过Selector选择通道" class="headerlink" title="通过Selector选择通道"></a>通过Selector选择通道</h3><p>一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。</p>
<p>下面是select()方法：</p>
<ul>
<li>int select()</li>
<li>int select(long timeout)</li>
<li>int selectNow()</li>
</ul>
<p>select()阻塞到至少有一个通道在你注册的事件上就绪了。<br>select(long timeout)和select()一样，除了最长会阻塞timeout毫秒(参数)。<br>selectNow()不会阻塞，不管什么通道就绪都立刻返回（译者注：此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零。）。</p>
<p>select()方法返回的int值表示有多少通道已经就绪。亦即，自上次调用select()方法后有多少通道变成就绪状态。如果调用select()方法，因为有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。</p>
<p>一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，访问“已选择键集（selected key set）”中的就绪通道。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java NIO</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>nio</tag>
      </tags>
  </entry>
  <entry>
    <title>hashMap数据结构和原理</title>
    <url>/2020/07/24/hashMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h1><p>HashMap是一个集合，键值对的集合,源码中hashMap的内部类Node,每个节点用Node&lt;K,V&gt;表示,可以看到Node里面存放的数据分别是hash-哈希值，key-键，value-值,next-下一节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">   final int hash;</span><br><span class="line">   final K key;</span><br><span class="line">   V value;</span><br><span class="line">   Node&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure>
<p>HashMap的数据结构为 <strong>数组+(链表或红黑树)</strong></p>
<p><img src="/2020/07/24/hashMap数据结构和原理/hashMap.jpg" alt="img"></p>
<p>使用数组+链表/红黑树的数据结构有以下优点。</p>
<p><strong>数组的特点：查询效率高，插入，删除效率低</strong>。</p>
<p><strong>链表的特点：查询效率低，插入删除效率高</strong>。</p>
<p>红黑树的特点：红黑树是一种含有红黑结点并能自平衡的二叉查找树 </p>
<p>​        性质1：每个节点要么是黑色，要么是红色。</p>
<p>​        性质2：根节点是黑色。</p>
<p>​        性质3：每个叶子节点（NIL）是黑色。</p>
<p>​        性质4：每个红色结点的两个子结点一定都是黑色。</p>
<p>​        性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</p>
<p>因为链表中元素太多的时候会影响查找效率，所以当链表的元素个数达到8的时候使用链表存储就转变成了使用红黑树存储，原因就是<strong>红黑树是平衡二叉树，在查找性能方面比链表要高</strong>.所以后面修改成红黑树是为了提高查询效率。</p>
<h1 id="HashMap存放数据的过程"><a href="#HashMap存放数据的过程" class="headerlink" title="HashMap存放数据的过程"></a>HashMap存放数据的过程</h1><p>1、存放元素的时候会先根据key的hash值去计算元素下标，如果这个下标没有元素，就创建一个Node节点放进去；</p>
<p>2、如果数组下标有数据，先判断key是否相同，相同的话替换元素的value；不同的话插在链表的尾节点。这里说明了 同一个链表中的节点不一定是发生了hash冲突的，有可能hash值不同，但是在计算时下标相同。</p>
<p>3、链表长度大于8，且数组长度大于64，会把链表转位红黑树，红黑树本质是一颗自平衡的二叉查找树，查找时间复杂度为o(logn)；</p>
<p>4、用数组容量大小(threshold)乘以加载因子(loadFactor)得到一个值，一旦数组中存储的元素个数超过该值就会调用rehash方法将数组容量增加到原来的两倍扩容。在做扩容的时候会生成一个新的数组，原来的所有数据需要重新计算哈希码值重新分配到新的数组，所以扩容的操作非常消耗性能.</p>
<p><img src="/2020/07/24/hashMap数据结构和原理/hashMap_put.png" alt></p>
<h1 id="HashMap的常见问题"><a href="#HashMap的常见问题" class="headerlink" title="HashMap的常见问题"></a>HashMap的常见问题</h1><h2 id="解决hash冲突"><a href="#解决hash冲突" class="headerlink" title="解决hash冲突"></a>解决hash冲突</h2><p>当存储元素出现hash冲突时，意味着hash值相同（计算下标相同）的多个元素要存储在数组中的同一个位置，这时候就通过一个单链表/红黑树来解决，判断新增元素的时是否需要扩容，在扩容之后重新计算下标位置，如果链表的元素超过8个，且数组的长度大于64，这个时候会将链表转换成为红黑树。</p>
<h2 id="为什么是链表个数超过8的时候才转红黑树"><a href="#为什么是链表个数超过8的时候才转红黑树" class="headerlink" title="为什么是链表个数超过8的时候才转红黑树"></a>为什么是链表个数超过8的时候才转红黑树</h2><p>红黑树插入为O(lgn),查询为O(lgn)，链表插入为O(1)，查询为O(n)。个数少时，插入删除成本高，用链表；个数多时，查询成本高，用红黑树。需要定一个值，比这个值大就转红黑树，比这个值小就转链表，而且要避免频繁的转换。根据泊松分布，在负载因子0.75（HashMap默认）的情况下，单个hash槽内元素个数为8的概率小于百万分之一，将7作为一个分水岭，等于7时不做转换，大于等于8才转红黑树，小于等于6才转链表。</p>
<h2 id="为什么数组的数量扩容的个数是2-n"><a href="#为什么数组的数量扩容的个数是2-n" class="headerlink" title="为什么数组的数量扩容的个数是2^n"></a>为什么数组的数量扩容的个数是2^n</h2><p>为了让添加的元素均匀分布在HashMap的数组上，减少hash碰撞。hash是int类型，转换为2进制数是32位，为了简化，假设<br>hash=0101 0101，n-1= 15</p>
<p>这样就可以限制&amp;运算的结果在<code>0000~1111</code>之间，转为10进制数就是<code>0～15</code>，是不是和求余运算的结果一致？如果n=17，n-1=0001 0000，这样&amp;运算结果的低位全为0，数组中有很多位置利用不到，这样会出现大量的hash冲突。</p>
<h2 id="HashMap的扩容"><a href="#HashMap的扩容" class="headerlink" title="HashMap的扩容"></a>HashMap的扩容</h2><p>扩容有3个触发时机，一个是初始化，也就是第一次<code>put()</code>存放数据时，另一个是存储的元素数量大于阈值<code>threshold</code>时；还有一个是树化的时候（这一点很多人应该不知道），最后都是调用<code>resize()</code>方法完成扩容和数据迁移的。</p>
<p><strong>原来数组中的元素在扩容后只有2种选择，第一，在原来的位置；第二，在原来位置基础上再加上原来数组长度。</strong></p>
<p>下面这幅图是扩容前后A、B元素的数组下标的计算过程（有区别的地方做了标示）。在扩容前A、B的hash值不一样，但是&amp;运算后的下标却是一样的；扩容后发生了一个变化，就是n变成了2原来的2倍，变成2倍可以用左移1位表示，也就是从<code>0000 1111(16)</code>变成<code>0001 1111(32)</code>，那扩容后与运算，A在高位的第4位&amp;运算结果为0；B在高位的第4位&amp;运算结果为1；也就是说A还是在原来的位置，B在原来的位置(5),再往后移动16位，也就是B移动到21了。</p>
<p><img src="/2020/07/24/hashMap数据结构和原理/resize.png" alt></p>
<h2 id="HashMap是否有序"><a href="#HashMap是否有序" class="headerlink" title="HashMap是否有序"></a>HashMap是否有序</h2><p>hashMap是无序的，再存放元素的时候是按照hash值来确定下标来存放元素，所以是无序的。想要有序的存放元素可以选择LinkedHashMap或则TreeMap。</p>
<h1 id="LinkedHashMap解析"><a href="#LinkedHashMap解析" class="headerlink" title="LinkedHashMap解析"></a>LinkedHashMap解析</h1><p><code>LinkedHashMap</code> 是一个<strong>关联数组、哈希表</strong>，它是<strong>线程不安全</strong>的，允许<strong>key为null</strong>,<strong>value为null</strong>。它也是HashMap的一个派生类。所以很多方法都是直接集成自HashMap。</p>
<p>LinkedHashMap是有序的是因为他的节点数据结构是类似于双向链表,Entry集成Node.记录了上下节点的信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在每次<strong>插入数据，或者访问、修改数据</strong>时，<strong>会增加节点、或调整链表的节点顺序</strong>。以决定迭代时输出的顺序。</p>
<p>默认情况，遍历时的顺序是<strong>按照插入节点的顺序</strong>。这也是其与<code>HashMap</code>最大的区别。 也可以在构造时传入<code>accessOrder</code>参数，使得其遍历顺序<strong>按照访问的顺序</strong>输出。</p>
<p>LinkedHashMap`在实现时，就是重写override了几个方法。以满足其输出序列有序的需求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;1&quot;, &quot;a&quot;);</span><br><span class="line">        map.put(&quot;2&quot;, &quot;b&quot;);</span><br><span class="line">        map.put(&quot;3&quot;, &quot;c&quot;);</span><br><span class="line">        map.put(&quot;4&quot;, &quot;d&quot;);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;以下是accessOrder=true的情况:&quot;);</span><br><span class="line"></span><br><span class="line">        map = new LinkedHashMap&lt;String, String&gt;(10, 0.75f, true);</span><br><span class="line">        map.put(&quot;1&quot;, &quot;a&quot;);</span><br><span class="line">        map.put(&quot;2&quot;, &quot;b&quot;);</span><br><span class="line">        map.put(&quot;3&quot;, &quot;c&quot;);</span><br><span class="line">        map.put(&quot;4&quot;, &quot;d&quot;);</span><br><span class="line">        map.get(&quot;2&quot;);//2移动到了内部的链表末尾</span><br><span class="line">        map.get(&quot;4&quot;);//4调整至末尾</span><br><span class="line">        map.put(&quot;3&quot;, &quot;e&quot;);//3调整至末尾</span><br><span class="line">        map.put(null, null);//插入两个新的节点 null</span><br><span class="line">        map.put(&quot;5&quot;, null);//5</span><br><span class="line">        iterator = map.entrySet().iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //打印结果</span><br><span class="line"> &gt; Task :Hash.main()</span><br><span class="line">1=a</span><br><span class="line">2=b</span><br><span class="line">3=c</span><br><span class="line">4=d</span><br><span class="line">以下是accessOrder=true的情况:</span><br><span class="line">1=a</span><br><span class="line">2=b</span><br><span class="line">4=d</span><br><span class="line">3=e</span><br><span class="line">null=null</span><br><span class="line">5=null</span><br></pre></td></tr></table></figure>
<p>LinkedHashMap修改了节点的结构，并且添加了链表的头和尾节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The head (eldest) of the doubly linked list.</span><br><span class="line"> */</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The tail (youngest) of the doubly linked list.</span><br><span class="line"> */</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure>
<p>相比较HashMap的增删逻辑没有什么改变，其重写了构建新节点的<code>newNode()</code>方法，新建节点是在链表的末尾添加该节点。重写了<code>afterNodeRemoval()</code>这个回调方法，在删除节点后，更新双向链表的操作。</p>
<p>重写了containsValue方法，在判断是否包含某个元素的方法，HashMap使用了的两层for循环，逐个遍历元素，效率相对较低。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//hashMap </span><br><span class="line">public boolean containsValue(Object value) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; size &gt; 0) &#123;</span><br><span class="line">        for (int i = 0; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123;</span><br><span class="line">                if ((v = e.value) == value ||</span><br><span class="line">                    (value != null &amp;&amp; value.equals(v)))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">//LinkedHashMap</span><br><span class="line">public boolean containsValue(Object value) &#123;</span><br><span class="line">    //遍历一遍链表，去比较有没有value相等的节点，并返回</span><br><span class="line">    for (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != null; e = e.after) &#123;</span><br><span class="line">        V v = e.value;</span><br><span class="line">        if (v == value || (value != null &amp;&amp; value.equals(v)))</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="TreeMap解析"><a href="#TreeMap解析" class="headerlink" title="TreeMap解析"></a>TreeMap解析</h1><p>TreeMap是以红黑树为存储结构，TreeMap因为是按照红黑树的构造，默认情况下comparator为null，所以按照key来自动排序，，如果想自定义排序规则，就要传递默comparator的实现。</p>
<p>TreeMap的构造，他的几点Entry也是继承Map.Entry</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TreeMap&lt;K,V&gt;</span><br><span class="line">    extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">	//比较器用于维护此树形图中的顺序；如果比较器使用其键的自然顺序，则为null</span><br><span class="line">    private final Comparator&lt;? super K&gt; comparator;</span><br><span class="line">	//Tree根节点</span><br><span class="line">    private transient Entry&lt;K,V&gt; root;</span><br><span class="line"> 	//Entry数</span><br><span class="line">    private transient int size = 0;</span><br><span class="line">	//结构修改次数</span><br><span class="line">    private transient int modCount = 0;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    //左子节点</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    //右子节点</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    //父节点</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    //默认情况下为黑色</span><br><span class="line">    boolean color = BLACK;</span><br></pre></td></tr></table></figure>
<p>TreeMap是红黑树的结构，所以会在插入节点的时候自平衡</p>
<ol>
<li>变色：在不违反上述红黑树规则特点情况下，将红黑树某个node节点颜色由红变黑，或者由黑变红；</li>
<li>左旋：逆时针旋转两个节点，让一个节点被其右子节点取代，而该节点成为右子节点的左子节点</li>
<li>右旋：顺时针旋转两个节点，让一个节点被其左子节点取代，而该节点成为左子节点的右子节点</li>
</ol>
<p>TreeMap的核心是put方法，在添加值的时候，为了维护红黑树的平衡，需要进行一系列操作，fixAfterInsertion方法来进行自平衡处理。</p>
<table>
<thead>
<tr>
<th></th>
<th>无需调整</th>
<th>【变色】即可实现平衡</th>
<th>【旋转+变色】才可实现平衡</th>
</tr>
</thead>
<tbody>
<tr>
<td>情况1：</td>
<td>当父节点为黑色时插入子节点</td>
<td>空树插入根节点，将根节点红色变为黑色</td>
<td>父节点为红色左节点，叔父节点为黑色，插入左子节点，那么通过【左左节点旋转】</td>
</tr>
<tr>
<td>情况2：</td>
<td>-</td>
<td>父节点和叔父节点都为红色</td>
<td>父节点为红色左节点，叔父节点为黑色，插入右子节点，那么通过【左右节点旋转】</td>
</tr>
<tr>
<td>情况3：</td>
<td>-</td>
<td>-</td>
<td>父节点为红色右节点，叔父节点为黑色，插入左子节点，那么通过【右左节点旋转】</td>
</tr>
<tr>
<td>情况4：</td>
<td>-</td>
<td>-</td>
<td>父节点为红色右节点，叔父节点为黑色，插入右子节点，那么通过【右右节点旋转】</td>
</tr>
</tbody>
</table>
<h1 id="ConcurrentHashMap解析"><a href="#ConcurrentHashMap解析" class="headerlink" title="ConcurrentHashMap解析"></a>ConcurrentHashMap解析</h1><p>ConCurrentHashMap的结构是：数组+红黑树，与HashMap相同。Hashtable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下Hashtable的效率非常低下。因为当一个线程访问Hashtable的同步方法时，其他线程访问Hashtable的同步方法时，可能会进入阻塞或轮询状态。</p>
<p>CAS是比较常见的一个问题：当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值(<strong>A和内存值V相同时，将内存值V修改为B)</strong>，而其它线程都失败，失败的线程<strong>并不会被挂起</strong>，而是被告知这次竞争中失败，并可以再次尝试<strong>(否则什么都不做)</strong></p>
<p><strong>volatile仅仅用来保证该变量对所有线程的可见性，但不保证原子性</strong>。</p>
<p>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，</p>
<p>（JDK 1.7）那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。1.7用这种分段锁的方法来保证数据的一致性。</p>
<p>JDK1.8 使用的是CAS+Synchronized来保证并发更新的安全性，在更新时会局部锁住某部分数据，但不会把整个表都锁住。同步读取操作则是完全非阻塞的。好处是在保证合理的同步前提下，效率很高。坏处是严格来说读取操作不能保证反映最近的更新。例如线程A调用putAll写入大量数据，期间线程B调用get，则只能get到目前为止已经顺利插入的部分数据。</p>
<h2 id="类似的-HashSet-和TreeSet"><a href="#类似的-HashSet-和TreeSet" class="headerlink" title="类似的 HashSet 和TreeSet"></a>类似的 HashSet 和TreeSet</h2><p>HashSet不允许保存重复对象，这个重复是有自己定义的。比如需要保存People对象，People类包含名字和年龄两个属性，你可以在People类中重写equals和hashCode方法，指明姓名和年龄都相等的People对象是相等的，那么就不能重复存入姓名和年龄相等的People对象。HashSet中的对象没有顺序。<br> TreeSet保存的对象有顺序性，也有不可重复性。顺序性有两种方法实现，一个是类实现Comparable接口；另一个是构造比较器，将比较器对象作为TreeSet的构造函数的参数传入。顺序性和不可重复性都是在compareTo()方法中实现的，当按年龄排序时，先比较年龄，年龄相等再比较姓名，姓名相等则不存入。</p>
]]></content>
  </entry>
  <entry>
    <title>java  IO模型</title>
    <url>/2019/04/15/javaIO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="一、同步和异步"><a href="#一、同步和异步" class="headerlink" title="一、同步和异步"></a>一、同步和异步</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>同步</strong>：同步方法一旦开始，必须等到方法执行完毕，才能继续执行后面的行为，比如java中的synchronized关键字的使用。<br>&ensp;&ensp;&ensp;&ensp;<strong>异步</strong>：异步方法开始之后，调用者不必等待返回结果，可以继续执行下一步。<br>&ensp;&ensp;&ensp;&ensp;同步一般在执行的过程中使整个流程暂停等待，而异步的方法则在执行的时候不影响其他线程，所以异步一般是通过多线程来实现的。<br>&ensp;&ensp;&ensp;&ensp;事实上，同步和异步是一个非常广的概念，它们的重点在于多个任务和事件发生时，一个事件的发生或执行是否会导致整个流程的暂时等待。我觉得可以将同步和异步与Java中的synchronized关键字联系起来进行类比。当多个线</p>
<h1 id="二、阻塞和非阻塞"><a href="#二、阻塞和非阻塞" class="headerlink" title="二、阻塞和非阻塞"></a>二、阻塞和非阻塞</h1><p>&ensp;&ensp;&ensp;&ensp;介绍了同步和异步的区别，来看一下阻塞和非阻塞的区别。<br>&ensp;&ensp;&ensp;&ensp;<strong>阻塞</strong>就是：当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；<br>&ensp;&ensp;&ensp;&ensp;<strong>非阻塞</strong>就是：当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。<br>这就是阻塞和非阻塞的区别。也就是说阻塞和非阻塞的区别关键在于当发出请求一个操作时，如果条件不满足，是会一直等待还是返回一个标志信息。<br>同步和异步着重点在于多个任务的执行过程中，一个任务的执行是否会导致整个流程的暂时等待；<br>而阻塞和非阻塞着重点在于发出一个请求操作时，如果进行操作的条件不满足是否会返会一个标志信息告知条件不满足。<br>理解阻塞和非阻塞可以同线程阻塞类比地理解，当一个线程进行一个请求操作时，如果条件不满足，则会被阻塞，即在那等待条件满足。</p>
<h1 id="三、阻塞IO与非阻塞IO"><a href="#三、阻塞IO与非阻塞IO" class="headerlink" title="三、阻塞IO与非阻塞IO"></a>三、阻塞IO与非阻塞IO</h1><p>在了解阻塞IO和非阻塞IO之前，先看下一个具体的IO操作过程是怎么进行的。<br>通常来说，IO操作包括：对硬盘的读写、对socket的读写以及外设的读写。<br>当用户线程发起一个IO请求操作（本文以读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：<br>&ensp;&ensp;&ensp;&ensp;1）查看数据是否就绪；<br>&ensp;&ensp;&ensp;&ensp;2）进行数据拷贝（内核将数据拷贝到用户线程）。<br>&ensp;&ensp;&ensp;&ensp;那么阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。<br>&ensp;&ensp;&ensp;&ensp;Java中传统的IO都是阻塞IO，比如通过socket来读数据，调用read()方法之后，如果数据没有就绪，当前线程就会一直阻塞在read方法调用那里，直到有数据才返回；而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直在那里等待。</p>
<h1 id="四、同步IO与异步IO"><a href="#四、同步IO与异步IO" class="headerlink" title="四、同步IO与异步IO"></a>四、同步IO与异步IO</h1><p>我们先来看一下同步IO和异步IO的定义，在《Unix网络编程》一书中对同步IO和异步IO的定义是这样的：<br>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes.<br>An asynchronous I/O operation does not cause the requesting process to be blocked.<br>从字面的意思可以看出：同步IO即 如果一个线程请求进行IO操作，在IO操作完成之前，该线程会被阻塞；<br>而异步IO为 如果一个线程请求进行IO操作，IO操作不会导致请求线程被阻塞。<br>事实上，同步IO和异步IO模型是针对用户线程和内核的交互来说的：<br>对于同步IO：当用户发出IO请求操作之后，如果数据没有就绪，需要通过用户线程或者内核不断地去轮询数据是否就绪，当数据就绪时，再将数据从内核拷贝到用户线程；<br>而异步IO：只有IO请求操作的发出是由用户线程来进行的，IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成。也就是说在异步IO中，不会对用户线程产生任何阻塞。<br>这是同步IO和异步IO关键区别所在，同步IO和异步IO的关键区别反映在数据拷贝阶段是由用户线程完成还是内核完成。所以说异步IO必须要有操作系统的底层支持。<br>阻塞IO和非阻塞IO是反映在当用户请求IO操作时，如果数据没有就绪，是用户线程一直等待数据就绪，还是会收到一个标志信息这一点上面的。也就是说，阻塞IO和非阻塞IO是反映在IO操作的第一个阶段，在查看数据是否就绪时是如何处理的。</p>
<h1 id="五、五种IO模型"><a href="#五、五种IO模型" class="headerlink" title="五、五种IO模型"></a>五、五种IO模型</h1><p>在《Unix网络编程》一书中提到了五种IO模型，分别是：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO以及异步IO</p>
<h2 id="1、阻塞IO模型"><a href="#1、阻塞IO模型" class="headerlink" title="1、阻塞IO模型"></a>1、阻塞IO模型</h2><p>典型的IO模型例子，就是在读/写操作中阻塞<br>当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU，当数据就绪后，内核将数据拷贝到用户线程，此时用户线程解除LOCK的状态。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">data = socket.read();</span><br></pre></td></tr></table></figure></p>
<p>如果数据一直没准备好，线程就会一直阻塞在read()</p>
<h2 id="2、非阻塞IO模型"><a href="#2、非阻塞IO模型" class="headerlink" title="2、非阻塞IO模型"></a>2、非阻塞IO模型</h2><p>当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。<br>所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。典型的非阻塞IO模型一般如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(true)&#123; </span><br><span class="line">    data = socket.read(); </span><br><span class="line">    if(data!= error)&#123; </span><br><span class="line">        处理数据 </span><br><span class="line">        break; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3、多路复用IO模型"><a href="#3、多路复用IO模型" class="headerlink" title="3、多路复用IO模型"></a>3、多路复用IO模型</h2><p>&ensp;&ensp;&ensp;&ensp;多路复用IO模型是目前使用得比较多的模型。Java NIO实际上就是多路复用IO。<br>在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。<br>在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。<br>多路复用IO模式，通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。<br>另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态是通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。<br>不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询</p>
<h2 id="4、信号驱动IO模型"><a href="#4、信号驱动IO模型" class="headerlink" title="4、信号驱动IO模型"></a>4、信号驱动IO模型</h2><p>&ensp;&ensp;&ensp;&ensp;在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。</p>
<h2 id="5、异步的IO模型"><a href="#5、异步的IO模型" class="headerlink" title="5、异步的IO模型"></a>5、异步的IO模型</h2><p>&ensp;&ensp;&ensp;&ensp;异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它收到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要知道实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。<br>&ensp;&ensp;&ensp;&ensp;也就说在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用iO函数进行实际的读写操作。<br>&ensp;&ensp;&ensp;&ensp;注意，异步IO是需要操作系统的底层支持，在Java 7中，提供了Asynchronous IO。</p>
<h1 id="六、高性能的IO设计"><a href="#六、高性能的IO设计" class="headerlink" title="六、高性能的IO设计"></a>六、高性能的IO设计</h1><p>&ensp;&ensp;&ensp;&ensp;在传统的网络服务设计模式中，有两种比较经典的模式：一种是 多线程，一种是线程池。对于多线程模式，也就说来了client，服务器就会新建一个线程来处理该client的读写事件，如下图所示：<br><img src="/2019/04/15/javaIO模型/manyThread.jpg" alt><br>&ensp;&ensp;&ensp;&ensp;因此，为了解决这种一个线程对应一个客户端模式带来的问题，提出了采用线程池的方式，也就说创建一个固定大小的线程池，来一个客户端，就从线程池取一个空闲线程来处理，当客户端处理完读写操作之后，就交出对线程的占用。因此这样就避免为每一个客户端都要创建线程带来的资源浪费，使得线程可以重用<br>&ensp;&ensp;&ensp;&ensp;在Reactor模式中，会先对每个client注册感兴趣的事件，然后有一个线程专门去轮询每个client是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理完之后，便再转去继续轮询，如下图所示：<br><img src="/2019/04/15/javaIO模型/react.jpg" alt><br>&ensp;&ensp;&ensp;&ensp;从这里可以看出，上面的五种IO模型中的多路复用IO就是采用Reactor模式。注意，上面的图中展示的 是顺序处理每个事件，当然为了提高事件处理速度，可以通过多线程或者线程池的方式来处理事件</p>
]]></content>
      <categories>
        <category>java NIO</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>io/nio</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka</title>
    <url>/2020/07/16/kafka/</url>
    <content><![CDATA[<p>公司用到的很多技术，自己之前都没学过(<strong>尬</strong>)，于是只能慢慢补了。这次是<strong>消息队列</strong>的笔记。以前写过的RabitMq和这个差别还是蛮大的。</p>
<h1 id="为什么要使用消息队列"><a href="#为什么要使用消息队列" class="headerlink" title="为什么要使用消息队列"></a>为什么要使用消息队列</h1><p>消息队列的主要作用是</p>
<h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><p><img src="/2020/07/16/kafka/解耦.png" alt></p>
<p>现在我有一个系统A，系统A可以产生一个<code>userId</code></p>
<p>携程伪代码可能是这个样子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SystemA &#123;</span><br><span class="line"></span><br><span class="line">    // 系统B和系统C的依赖</span><br><span class="line">    SystemB systemB = new SystemB();</span><br><span class="line">    SystemC systemC = new SystemC();</span><br><span class="line"></span><br><span class="line">    // 系统A独有的数据userId</span><br><span class="line">    private String userId = &quot;Java3y&quot;;</span><br><span class="line"></span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line"></span><br><span class="line">        // 系统B和系统C都需要拿着系统A的userId去操作其他的事</span><br><span class="line">        systemB.SystemBNeed2do(userId);</span><br><span class="line">        systemC.SystemCNeed2do(userId);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>又过了几天，系统E的负责人过来了，告诉系统A，需要userId。</li>
<li>又过了几天，系统B的负责人过来了，告诉系统A，还是重新关调那个接口吧。</li>
<li>又过了几天，系统F的负责人过来了，告诉系统A，需要userId。</li>
</ul>
<p>然后就原地boom!!!。</p>
<p>现在将系统A将userId写到消息队列中，系统C和系统D从消息队列中拿数据。这样就根本不管系统b、c。他们的交互也是从消息队列中获取。</p>
<h2 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h2><p>我们再来一个场景，现在我们每个月要搞一次大促，大促期间的并发可能会很高的，比如每秒3000个请求。假设我们现在有两台机器处理请求，并且每台机器只能每次处理1000个请求。那多出来的1000个请求，可能就把我们<strong>整个系统给搞崩了</strong>…所以，有一种办法，我们可以写到消息队列中：</p>
<p><img src="/2020/07/16/kafka/削峰.png" alt></p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p><img src="/2020/07/16/kafka/E:/blog\source\_posts\kafka\异步.png" alt></p>
<p>伪代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SystemA &#123;</span><br><span class="line"></span><br><span class="line">    SystemB systemB = new SystemB();</span><br><span class="line">    SystemC systemC = new SystemC();</span><br><span class="line">    SystemD systemD = new SystemD();</span><br><span class="line"></span><br><span class="line">    // 系统A独有的数据</span><br><span class="line">    private String userId ;</span><br><span class="line"></span><br><span class="line">    public void doOrder() &#123;</span><br><span class="line"></span><br><span class="line">        // 下订单</span><br><span class="line">          userId = this.order();</span><br><span class="line">        // 如果下单成功，则安排其他系统做一些事  </span><br><span class="line">        systemB.SystemBNeed2do(userId);</span><br><span class="line">        systemC.SystemCNeed2do(userId);</span><br><span class="line">        systemD.SystemDNeed2do(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>假设</strong>系统A运算出userId具体的值需要50ms，调用系统B的接口需要300ms，调用系统C的接口需要300ms，调用系统D的接口需要300ms。那么这次请求就需要<code>50+300+300+300=950ms</code></p>
<p>并且我们得知，系统A做的是<strong>主要的业务</strong>，而系统B、C、D是<strong>非主要</strong>的业务。比如系统A处理的是<strong>订单下单</strong>，而系统B是订单下单成功了，那发送一条短信告诉具体的用户此订单已成功，而系统C和系统D也是处理一些小事而已。</p>
<p>那么此时，为了<strong>提高用户体验和吞吐量</strong>，其实可以<strong>异步地</strong>调用系统B、C、D的接口。所以，我们可以弄成是这样的：</p>
<p><img src="/2020/07/16/kafka/异步2.png" alt></p>
<h1 id="消息队列的问题"><a href="#消息队列的问题" class="headerlink" title="消息队列的问题"></a>消息队列的问题</h1><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>消息队列的选择上，无论是我们使用消息队列来做解耦、异步还是削峰，消息队列<strong>肯定不能是单机</strong>的。试着想一下，如果是单机的消息队列，万一这台机器挂了，那我们整个系统几乎就是不可用了。所以，当我们项目中使用消息队列，都是得<code>集群/分布式</code>的。要做<code>集群/分布式</code>就必然希望该消息队列能够提供<strong>现成</strong>的支持，而不是自己写代码手动去实现。</p>
<p><img src="/2020/07/16/kafka/E:/blog\source\_posts\kafka\高可用.png" alt></p>
<h2 id="数据丢失"><a href="#数据丢失" class="headerlink" title="数据丢失"></a>数据丢失</h2><p>我们将数据写到消息队列上，系统B和C还没来得及取消息队列的数据，就挂掉了。<strong>如果没有做任何的措施，我们的数据就丢了</strong>。</p>
<p><img src="/2020/07/16/kafka/消息丢失.png" alt></p>
<p>学过Redis的都知道，Redis可以将数据持久化磁盘上，万一Redis挂了，还能从磁盘从将数据恢复过来。同样地，消息队列中的数据也需要存在别的地方，这样才尽可能减少数据的丢失。</p>
<p>除了这些，我们在<strong>使用的时候</strong>还得考虑各种的问题：</p>
<ul>
<li>消息重复消费了怎么办啊？</li>
<li>我想保证消息是<strong>绝对</strong>有顺序的怎么做？</li>
<li>……..</li>
</ul>
<p>虽然消息队列给我们带来了那么多的好处，但同时我们发现引入消息队列也会<strong>提高系统的复杂性</strong>。市面上现在已经有不少消息队列轮子了，每种消息队列都有自己的特点，<strong>选取哪种MQ还得好好斟酌</strong>。</p>
<h1 id="centos7安装kafka集群"><a href="#centos7安装kafka集群" class="headerlink" title="centos7安装kafka集群"></a>centos7安装kafka集群</h1><p>1.下载zookeeper</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /root/soft</span><br><span class="line">wget https://mirrors.bfsu.edu.cn/apache/kafka/2.5.0/kafka_2.12-2.5.0.tgz</span><br></pre></td></tr></table></figure>
<p>2.解压文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf kafka_2.12-2.5.0.tgz</span><br><span class="line">cd /root/soft/kafka_2.12-2.5.0.tgz</span><br></pre></td></tr></table></figure>
<p>3.修改配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd  /usr/local/application/kafka/kafka_2.12-2.5.0/config</span><br><span class="line">vim server.properties</span><br></pre></td></tr></table></figure>
<p>修改配置文件中的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">broker.id=0  #当前机器在集群中的唯一标识，和zookeeper的myid性质一样</span><br><span class="line">port=5701 #当前kafka对外提供服务的端口默认是9092</span><br><span class="line">host.name=192.168.7.100 #这个参数默认是关闭的，在0.8.1有个bug，DNS解析问题，失败率的问题。</span><br><span class="line">num.network.threads=3 #这个是borker进行网络处理的线程数</span><br><span class="line">num.io.threads=8 #这个是borker进行I/O处理的线程数</span><br><span class="line">log.dirs=/usr/local/application/kafka/kafka_2.12-2.5.0/kafka-logs #消息存放的目录，这个目录可以配置为“，”逗号分割的表达式，上面的num.io.threads要大于这个目录的个数这个目录，如果配置多个目录，新创建的topic他把消息持久化的地方是，当前以逗号分割的目录中，那个分区数最少就放那一个</span><br><span class="line">socket.send.buffer.bytes=102400 #发送缓冲区buffer大小，数据不是一下子就发送的，先回存储到缓冲区了到达一定的大小后在发送，能提高性能</span><br><span class="line">socket.receive.buffer.bytes=102400 #kafka接收缓冲区大小，当数据到达一定大小后在序列化到磁盘</span><br><span class="line">socket.request.max.bytes=104857600 #这个参数是向kafka请求消息或者向kafka发送消息的请请求的最大数，这个值不能超过java的堆栈大小</span><br><span class="line">num.partitions=1 #默认的分区数，一个topic默认1个分区数</span><br><span class="line">log.retention.hours=168 #默认消息的最大持久化时间，168小时，7天</span><br><span class="line">message.max.byte=5242880  #消息保存的最大值5M</span><br><span class="line">default.replication.factor=2  #kafka保存消息的副本数，如果一个副本失效了，另一个还可以继续提供服务</span><br><span class="line">replica.fetch.max.bytes=5242880  #取消息的最大直接数</span><br><span class="line">log.segment.bytes=1073741824 #这个参数是：因为kafka的消息是以追加的形式落地到文件，当超过这个值的时候，kafka会新起一个文件</span><br><span class="line">log.retention.check.interval.ms=300000 #每隔300000毫秒去检查上面配置的log失效时间（log.retention.hours=168 ），到目录查看是否有过期的消息如果有，删除</span><br><span class="line">log.cleaner.enable=false #是否启用log压缩，一般不用启用，启用的话可以提高性能</span><br><span class="line">zookeeper.connect=192.168.7.100:5701,192.168.7.101:5702,192.168.7.107:5703 #设置zk服务的端口</span><br></pre></td></tr></table></figure>
<p>启动kafka集群并测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/local/application/kafka/kafka_2.12-2.5.0/bin</span><br><span class="line">#启动方式一</span><br><span class="line">./kafka-server-start.sh ../config/server.properties</span><br><span class="line">#启动方式二  </span><br><span class="line">./kafka-server-start.sh ../config/server_1.properties &gt; ../logs/kafka_log_1/kafka.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>验证kafka 是否可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进入bin 目录下</span><br><span class="line"></span><br><span class="line">运行kafka生产者发送消息</span><br><span class="line">./kafka-console-producer.sh --broker-list localhost:5701 --topic shuaige</span><br><span class="line">发送消息</span><br><span class="line">&gt; aa</span><br><span class="line"></span><br><span class="line">运行kafka消费者接收消息</span><br><span class="line">$ ./kafka-console-consumer.sh --bootstrap-server localhost:5701 --topic shuaige --from-beginning</span><br><span class="line">aa</span><br><span class="line"></span><br><span class="line">查看主题列表</span><br><span class="line">./kafka-topics.sh --list --zookeeper localhost:5601</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">功能</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">创建主题</td>
<td>./kafka-topics.sh –create –zookeeper localhost:5601 –replication-factor 2 –partitions 1 –topic shuaige</td>
</tr>
<tr>
<td style="text-align:left">查看主题</td>
<td>./kafka-topics.sh –list –zookeeper localhost:5601</td>
</tr>
<tr>
<td style="text-align:left">删除主题</td>
<td>./kafka-topics.sh –delete –topic shuaige –zookeeper localhost:5601</td>
</tr>
<tr>
<td style="text-align:left">启动生产者</td>
<td>./kafka-console-producer.sh –broker-list localhost:5701 –topic shuaige</td>
</tr>
<tr>
<td style="text-align:left">启动消费者</td>
<td>./kafka-console-consumer.sh –bootstrap-server localhost:5701 –topic shuaige</td>
</tr>
</tbody>
</table>
<p>现在只是单个的一个broker,没什么意思。对于Kafka，一个broker仅仅只是一个集群的大小，所有让我们多设几个broker。</p>
<p>首先为每个broker创建一个配置文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#复制两份配置文件，修改其中的属性</span><br><span class="line">&gt; cp config/server.properties config/server-1.properties </span><br><span class="line">&gt; cp config/server.properties config/server-2.properties</span><br><span class="line"></span><br><span class="line">#修改properties的属性</span><br><span class="line">config/server-1.properties: </span><br><span class="line">    broker.id=1 </span><br><span class="line">    listeners=PLAINTEXT://:5701 </span><br><span class="line">    advertised.listeners=PLAINTEXT://localhost:5701</span><br><span class="line">    log.dir=/usr/local/application/kafka/kafka_2.12-2.5.0/kafka-logs/log_1</span><br><span class="line"></span><br><span class="line">config/server-2.properties: </span><br><span class="line">    broker.id=2 </span><br><span class="line">    listeners=PLAINTEXT://:5702 </span><br><span class="line">    advertised.listeners=PLAINTEXT://localhost:5702</span><br><span class="line">    log.dir=/usr/local/application/kafka/kafka_2.12-2.5.0/kafka-logs/log_2</span><br></pre></td></tr></table></figure>
<p>现在已经做好了集群，查看每个集群在做什么使用下面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#新建一个消息topic,分区为1，备份2</span><br><span class="line">./kafka-topics.sh --create --zookeeper localhost:5601 --replication-factor 2 --partitions 1 --topic panghu</span><br><span class="line">#查看集群信息</span><br><span class="line">./kafka-topics.sh --describe --zookeeper localhost:5601 --topic panghu</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/16/kafka/kafka-describe.png" alt="kafka-describe"></p>
<ul>
<li>“leader”：该节点负责该分区的所有的读和写，每个节点的<code>leader</code>都是随机选择的。</li>
<li>“replicas”：备份的节点列表，无论该节点是否是leader或者目前是否还活着，只是显示。</li>
<li>“isr”：“同步备份”的节点列表，也就是活着的节点并且正在同步leader。</li>
</ul>
<p>kafkamanage</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell&gt; nohup bin/kafka-manager -Dconfig.file=conf/application.conf -Dhttp.port=9002 &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<h1 id="标记删除topic的问题"><a href="#标记删除topic的问题" class="headerlink" title="标记删除topic的问题"></a>标记删除topic的问题</h1><p>删除节点时遇见了mark delete,标记删除，但是实际上topic并没有删除。尝试过修改配置文件server.properties,添加属性 delete.topic.enable=true,但是没得生效，后来看了大佬们的博客发现了topic的删除过程。</p>
<p>kafka是依托于zookeeper的一个消息系统。再kafka创建topic的同时，zookeeper的admin/topic节点下也会持久化对应的节点信息。当调用./kafka-topics.sh –delete –topic 的命令的时候，是在zookeeper的节点/admin/delete_topics下创建一个要被删除的节点名称，此时只是标记删除。</p>
<p>在Kafka中删除Topic的过程，</p>
<p>1.Kafka的broker在被选举成controller后，会执行下面几步 1.1 注册DeleteTopicsListener，监听zookeeper节点/admin/delete_topics下子节点的变化，delete命令实际上就是要在该节点下创建一个节点，名字是待删除topic名，标记该topic是待删除的</p>
<p>2.DeleteTopicsThread线程启动时会先在awaitTopicDeletionNotification处阻塞并等待删除事件的通知，即有新的topic被添加到queue里等待被删除。</p>
<p>3.DeleteTopicsThread线程启动时会先在awaitTopicDeletionNotification处阻塞并等待删除事件的通知，即有新的topic被添加到queue里等待被删除</p>
<p>4.DeleteTopicsListener会收到ChildChange事件会依次判断如下逻辑： 4.1 查询topic是否存在，若已经不存在了，则直接删除/admin/delete_topics/&lt;topic_name&gt;节点。 4.2 查询topic是否为当前正在执行Preferred副本选举或分区重分配，若果是，则标记为暂时不适合被删除。 4.3 并将该topic添加到queue中，此时会唤醒DeleteTopicsThread中doWork方法里awaitTopicDeletionNotification处的阻塞线程，让删除线程继续往下执行</p>
<p>执行删除操作的真正逻辑是</p>
<ol>
<li>它首先会向各broker更新原信息，使得他们不再向外提供数据服务，准备开始删除数据。</li>
<li>开始删除这个topic的所有分区 2.1 给所有broker发请求，告诉它们这些分区要被删除。broker收到后就不再接受任何在这些分区上的客户端请求了 2.2 把每个分区下的所有副本都置于OfflineReplica状态，这样ISR就不断缩小，当leader副本最后也被置于OfflineReplica状态时leader信息将被更新为-1 2.3 将所有副本置于ReplicaDeletionStarted状态 2.4 副本状态机捕获状态变更，然后发起StopReplicaRequest给broker，broker接到请求后停止所有fetcher线程、移除缓存，然后删除底层log文件 2.5 关闭所有空闲的Fetcher线程</li>
<li>删除zookeeper上节点/brokers/topics/&lt;topic_name&gt;</li>
<li>删除zookeeper上节点/config/topics/&lt;topic_name&gt;</li>
<li>删除zookeeper上节点/admin/delete_topics/&lt;topic_name&gt;</li>
<li>并删除内存中的topic相关信息。</li>
</ol>
<p>用zookeeper tool查看zookeeper的结构</p>
<p><img src="/2020/07/16/kafka/kafka-zk-持久化.png" alt="kafka-zk-持久化"></p>
<p>总结来说就要保证以下的几步操作</p>
<p>1.被删除topic 的生产和消费程序需要停止。同时，需要设置 auto.create.topics.enable = false，避免自动创建topic。</p>
<p>2.server.properties <strong>设置 delete.topic.enable=true</strong>则调用kafka 的delete命令无法真正将topic删除，而是显示（marked for deletion）</p>
<p>3.删除kafka存储目录（server.properties文件log.dirs配置，默认为”/data/kafka-logs”）相关topic的数据目录。</p>
<p>4.找到注册的zookeeper，在对应的bin目录下执行以下操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#登录到zk</span><br><span class="line">bin/zkCli.sh -server zookeeper localhost:5601</span><br><span class="line">#查看kafka的已有topic和标记删除目录</span><br><span class="line">ls /brokers/topics</span><br><span class="line">ls /admin/delete_topics</span><br><span class="line">#找到你要删除的topic,执行下面的删除命令</span><br><span class="line">rmr /brokers/topics/shuaige</span><br><span class="line">rmr /admin/delete_topics/shuaige</span><br></pre></td></tr></table></figure>
<p>此时在查看kafka的topic列表，不出意外的话对应的topic已被删除。</p>
<h1 id="kafka的一些基本概念"><a href="#kafka的一些基本概念" class="headerlink" title="kafka的一些基本概念"></a>kafka的一些基本概念</h1><p>  Kafka是一个分布式流数据系统，使用Zookeeper进行集群的管理。与其他消息系统类似，整个系统由生产者、Broker Server和消费者三部分组成，生产者和消费者由开发人员编写，通过API连接到Broker Server进行数据操作</p>
<h4 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h4><p>Kafka将消息分门别类，每一类的消息称之为一个主题（Topic）。</p>
<h4 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h4><p>发布消息的对象称之为主题生产者（Kafka topic producer）</p>
<h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>订阅消息并处理发布的消息的对象称之为主题消费者（consumers）</p>
<h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><p>已发布的消息保存在一组服务器中，称之为Kafka集群。集群中的每一个服务器都是一个代理（Broker）。 消费者可以订阅一个或多个主题（topic），并从Broker拉数据，从而消费这些已发布的消息。</p>
<p>Topic是发布的消息的类别名，一个topic可以有零个，一个或多个消费者订阅该主题的消息。</p>
<p>对于每个topic，Kafka集群都会维护一个分区log，就像下图中所示：</p>
<p><img src="/2020/07/16/kafka/topic.png" alt></p>
<p>再说说分区。Kafka中采用分区的设计有几个目的。一是可以处理更多的消息，不受单台服务器的限制。Topic拥有多个分区意味着它可以不受限的处理更多的数据。第二，分区可以作为并行处理的单元。Log的分区被分布到集群中的多个服务器上。每个服务器处理它分到的分区。 根据配置每个分区还可以复制到其它服务器作为备份容错。 每个分区有一个leader，零或多个follower。Leader处理此分区的所有的读写请求，而follower被动的复制数据。如果leader宕机，其它的一个follower会被推举为新的leader。 一台服务器可能同时是一个分区的leader，另一个分区的follower。 这样可以平衡负载，避免所有的请求都只让一台或者某几台服务器处理。</p>
<h2 id="消费模型"><a href="#消费模型" class="headerlink" title="消费模型"></a>消费模型</h2><p>通常来讲，消息模型可以分为两种， 队列和发布-订阅式。 队列的处理方式是 一组消费者从服务器读取消息，一条消息只有其中的一个消费者来处理。在发布-订阅模型中，消息被广播给所有的消费者，接收到消息的消费者都可以处理此消息。Kafka为这两种模型提供了单一的消费者抽象模型： 消费者组 （consumer group）。 消费者用一个消费者组名标记自己。 一个发布在Topic上消息被分发给此消费者组中的一个消费者。 假如所有的消费者都在一个组中，那么这就变成了queue模型。 假如所有的消费者都在不同的组中，那么就完全变成了发布-订阅模型。 更通用的， 我们可以创建一些消费者组作为逻辑上的订阅者。每个组包含数目不等的消费者， 一个组内多个消费者可以用来扩展性能和容错。正如下图所示：</p>
<p><img src="/2020/07/16/kafka/消费模型.png" alt></p>
<p>2个kafka集群托管4个分区（P0-P3），2个消费者组，消费组A有2个消费者实例，消费组B有4个。</p>
<p>正像传统的消息系统一样，Kafka保证消息的顺序不变。 再详细扯几句。传统的队列模型保持消息，并且保证它们的先后顺序不变。但是， 尽管服务器保证了消息的顺序，消息还是异步的发送给各个消费者，消费者收到消息的先后顺序不能保证了。这也意味着并行消费将不能保证消息的先后顺序。用过传统的消息系统的同学肯定清楚，消息的顺序处理很让人头痛。如果只让一个消费者处理消息，又违背了并行处理的初衷。 在这一点上Kafka做的更好，尽管并没有完全解决上述问题。 Kafka采用了一种分而治之的策略：分区。 因为Topic分区中消息只能由消费者组中的唯一一个消费者处理，所以消息肯定是按照先后顺序进行处理的。但是它也仅仅是保证Topic的一个分区顺序处理，不能保证跨分区的消息先后处理顺序。 所以，如果你想要顺序的处理Topic的所有消息，那就只提供一个分区。</p>
<h5 id="kafka有比传统的消息系统更强的顺序保证。"><a href="#kafka有比传统的消息系统更强的顺序保证。" class="headerlink" title="kafka有比传统的消息系统更强的顺序保证。"></a>kafka有比传统的消息系统更强的顺序保证。</h5><p>传统的消息系统按顺序保存数据，如果多个消费者从队列消费，则服务器按存储的顺序发送消息，但是，尽管服务器按顺序发送，消息异步传递到消费者，因此消息可能乱序到达消费者。这意味着消息存在并行消费的情况，顺序就无法保证。消息系统常常通过仅设1个消费者来解决这个问题，但是这意味着没用到并行处理。</p>
<p>kafka通过并行topic的parition —— kafka提供了顺序保证和负载均衡。每个partition仅由同一个消费者组中的一个消费者消费到。并确保消费者是该partition的唯一消费者，并按顺序消费数据。每个topic有多个分区，则需要对多个消费者做负载均衡，但请注意，<code>相同的消费者组中不能有比分区更多的消费者，否则多出的消费者一直处于空等待，不会收到消息</code>。</p>
<h1 id="spring-boot-集成kafka"><a href="#spring-boot-集成kafka" class="headerlink" title="spring boot 集成kafka"></a>spring boot 集成kafka</h1><h2 id="简单的演示demo"><a href="#简单的演示demo" class="headerlink" title="简单的演示demo"></a>简单的演示demo</h2><p>创建springboot项目 kafka-demo,下面是一个简单的kafka的集成demo，后续来添加更多详细的使用</p>
<p>引入kafka的依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//这个版本需要跟springboot对应，不然会在连接kafka的时候报错 no broker</span><br><span class="line">implementation group: &apos;org.springframework.kafka&apos;, name: &apos;spring-kafka&apos;, version: &apos;2.1.7.RELEASE&apos;</span><br></pre></td></tr></table></figure>
<p>创建消息发送者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class SendMessageController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    private String topic = &quot;test_1&quot;;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/send&quot;)</span><br><span class="line">    public String send(String params) &#123;</span><br><span class="line">        System.out.println(&quot;[ 收到请求 ]&quot;);</span><br><span class="line"></span><br><span class="line">        kafkaTemplate.send(topic, params);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;[ 返回响应 ]&quot;);</span><br><span class="line">        return &quot;您的任务已提交&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建消息监听者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MessageHandler &#123;</span><br><span class="line">    @KafkaListener(topics = &quot;test_1&quot; ,groupId = &quot;test&quot;)</span><br><span class="line">    public void handle(String message) &#123;</span><br><span class="line">        System.out.println(&quot;[ 处理器开始处理消息 ]&quot; + System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(message);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;[ 处理器处理消息完成 ]&quot; + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    	//任意一个都可以处理消息</span><br><span class="line">        @KafkaListener(topics = &quot;test_1&quot; ,groupId = &quot;test&quot;)</span><br><span class="line">    public void handle(ConsumerRecord&lt;String, String&gt; record) &#123;</span><br><span class="line">        System.out.println(&quot;[ 处理器开始处理消息 ]&quot; + System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(record);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;[ 处理器处理消息完成 ]&quot; + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动文件application.proerties修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 指定kafka server的地址，集群配多个，中间，逗号隔开</span><br><span class="line">spring.kafka.bootstrap-servers=ip:port</span><br><span class="line"></span><br><span class="line">#生产者配置</span><br><span class="line">spring.kafka.producer.bootstrapServers=ip:port</span><br><span class="line"># 当retris为0时，produce不会重复。retirs重发，此时repli节点完全成为leader节点，不会产生消息丢失。</span><br><span class="line">spring.kafka.producer.retries=0</span><br><span class="line"># 每次批量发送消息的数量,produce积累到一定数据，一次发送</span><br><span class="line">spring.kafka.producer.batch-size=16384</span><br><span class="line"># produce积累数据一次发送，缓存大小达到buffer.memory就发送数据</span><br><span class="line">spring.kafka.producer.buffer-memory=33554432</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 指定消息key和消息体的编解码方式</span><br><span class="line">spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line">spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#消费者配置</span><br><span class="line">#procedure要求leader在考虑完成请求之前收到的确认数，用于控制发送记录在服务端的持久化，其值可以为如下：</span><br><span class="line">#acks = 0 如果设置为零，则生产者将不会等待来自服务器的任何确认，该记录将立即添加到套接字缓冲区并视为已发送。在这种情况下，无法保证服务器已收到记录，并且重试配置将不会生效（因为客户端通常不会知道任何故障），为每条记录返回的偏移量始终设置为-1。</span><br><span class="line">#acks = 1 这意味着leader会将记录写入其本地日志，但无需等待所有副本服务器的完全确认即可做出回应，在这种情况下，如果leader在确认记录后立即失败，但在将数据复制到所有的副本服务器之前，则记录将会丢失。</span><br><span class="line">#acks = all 这意味着leader将等待完整的同步副本集以确认记录，这保证了只要至少一个同步副本服务器仍然存活，记录就不会丢失，这是最强有力的保证，这相当于acks = -1的设置。</span><br><span class="line">#可以设置的值为：all, -1, 0, 1</span><br><span class="line">spring.kafka.producer.acks=1</span><br><span class="line"></span><br><span class="line">spring.kafka.consumer.bootstrapServers=ip:port</span><br><span class="line">spring.kafka.consumer.groupId=test</span><br><span class="line">spring.kafka.consumer.autoOffsetReset=earliest</span><br><span class="line">spring.kafka.consumer.enableAutoCommit=true</span><br></pre></td></tr></table></figure>
<p>启动服务，调用send接口，就会在控制台打印出消息处理的信息。</p>
<h2 id="kafka的集成使用详解"><a href="#kafka的集成使用详解" class="headerlink" title="kafka的集成使用详解"></a>kafka的集成使用详解</h2><p>在上面的演示demo中，我们没有在服务器上先创建topic，而是<strong>KafkaTemplate</strong> 在发送消息的时候帮我们手动创建的消息。</p>
<h3 id="手动创建topic"><a href="#手动创建topic" class="headerlink" title="手动创建topic"></a>手动创建topic</h3><p>上述的demo的调用了send方法，在send的时候自动创建了topic。（可以通过设置auto.create.topics.enable=false来设置自动创建topic），我们可以自动逸配置类或者添加方法来实现手动topic的创建、修改、查询等方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class KafkaInitialConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    //创建TopicName为topic.quick.initial的Topic并设置分区数为8以及副本数为1,这个分区数修改后只会增大，不会减少</span><br><span class="line">    @Bean//通过bean创建(bean的名字为initialTopic)</span><br><span class="line">    public NewTopic initialTopic() &#123;</span><br><span class="line">        return new NewTopic(&quot;topic.quick.initial&quot;,12, (short) 1 );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean //创建一个kafka管理类，相当于rabbitMQ的管理类rabbitAdmin,没有此bean无法自定义的使用adminClient创建topic</span><br><span class="line">    public KafkaAdmin kafkaAdmin() &#123;</span><br><span class="line">        Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();</span><br><span class="line">        //配置Kafka实例的连接地址                                                                    //kafka的地址，不是zookeeper</span><br><span class="line">        props.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;ip:port&quot;);</span><br><span class="line">        KafkaAdmin admin = new KafkaAdmin(props);</span><br><span class="line">        return admin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean  //kafka客户端，在spring中创建这个bean之后可以注入并且创建topic</span><br><span class="line">    public AdminClient adminClient() &#123;</span><br><span class="line">        return AdminClient.create(kafkaAdmin().getConfig());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为上文的配置文件，我们定义了AdminClient的实体Bean,所以也可以通过在其他地方注入来使用</p>
<p>AdminClient的更多功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;/addTopic&quot;)</span><br><span class="line">public String addTopic(String topic, Integer partitions, short replicationFactor) &#123;</span><br><span class="line">    NewTopic newTopic = new NewTopic(&quot;topic.manual.create&quot;, partitions, replicationFactor);</span><br><span class="line">    adminClient.createTopics(Arrays.asList(newTopic));</span><br><span class="line">    return &quot;创建topic:&quot; + topic + &quot;成功&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生产者：指定-topic、partition、key-等发送"><a href="#生产者：指定-topic、partition、key-等发送" class="headerlink" title="生产者：指定 topic、partition、key 等发送"></a>生产者：指定 topic、partition、key 等发送</h3><p>在之前的文章中我们都是通过 <strong>KafkaTemplate</strong> 的 <strong>send()</strong> 方法指定一个 <strong>topic</strong> 发送消息，其实 <strong>send()</strong> 方法还支持其他参数，具体如下：</p>
<p><strong>参数说明：</strong></p>
<ul>
<li><strong>topic</strong>：这里填写的是 <strong>Topic</strong> 的名字</li>
<li><strong>partition</strong>：这里填写的是分区的 <strong>id</strong>，其实也是就第几个分区，<strong>id</strong> 从 <strong>0</strong> 开始。表示指定发送到该分区中</li>
<li><strong>timestamp</strong>：时间戳，一般默认当前时间戳</li>
<li><strong>key</strong>：消息的键</li>
<li><strong>data</strong>：消息的数据</li>
<li><strong>ProducerRecord</strong>：消息对应的封装类，包含上述字段</li>
<li><strong>Message</strong>：<strong>Spring</strong> 自带的 <strong>Message</strong> 封装类，包含消息及消息头</li>
</ul>
<p>下面是使用的样例，修改send方法即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//发送带有时间戳的消息</span><br><span class="line">kafkaTemplate.send(&quot;topic.hangge.demo&quot;, 0, System.currentTimeMillis(), &quot;key1&quot;, &quot;message&quot;);</span><br><span class="line"> </span><br><span class="line">//使用ProducerRecord发送消息</span><br><span class="line">ProducerRecord record = new ProducerRecord(&quot;topic.hangge.demo&quot;, &quot;message&quot;);</span><br><span class="line">kafkaTemplate.send(record);</span><br><span class="line"> </span><br><span class="line">//使用Message发送消息</span><br><span class="line">Map map = new HashMap();</span><br><span class="line">map.put(KafkaHeaders.TOPIC, &quot;topic.hangge.demo&quot;);</span><br><span class="line">map.put(KafkaHeaders.PARTITION_ID, 0);</span><br><span class="line">map.put(KafkaHeaders.MESSAGE_KEY, 0);</span><br><span class="line">GenericMessage message = new GenericMessage(&quot;use Message to send message&quot;,new MessageHeaders(map));</span><br><span class="line">kafkaTemplate.send(message);</span><br></pre></td></tr></table></figure>
<h3 id="生产者：消息回调、同步异步发送消息"><a href="#生产者：消息回调、同步异步发送消息" class="headerlink" title="生产者：消息回调、同步异步发送消息"></a>生产者：消息回调、同步异步发送消息</h3><p>当我们发送消息到 <strong>Kafka</strong> 后，有时我们需要确认消息是否发送成功，如果消息发送失败，就要重新发送或者执行对应的业务逻辑。下面分别演示如何在异步或者同步发送消息时，获取发送结果。<br>默认情况下 <strong>KafkaTemplate</strong> 发送消息是采取异步方式，并且 <strong>kafkaTemplate</strong> 提供了一个回调方法 <strong>addCallback</strong>，我们可以在回调方法中监控消息是否发送成功或在失败时做补偿处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/sendCallBack&quot;)</span><br><span class="line">public void sendCallBack(String topic, Integer partition, String key, String data) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    kafkaTemplate.send(topic, partition, key, data).addCallback(success -&gt; &#123;</span><br><span class="line">        // 消息发送到的topic</span><br><span class="line">        String sendTopic = success.getRecordMetadata().topic();</span><br><span class="line">        // 消息发送到的分区</span><br><span class="line">        int sendPartition = success.getRecordMetadata().partition();</span><br><span class="line">        // 消息在分区内的offset</span><br><span class="line">        long sendOffset = success.getRecordMetadata().offset();</span><br><span class="line">        System.out.println(&quot;发送消息成功:&quot; + sendTopic + &quot;-&quot; + sendPartition + &quot;-&quot; + sendOffset);</span><br><span class="line">    &#125;, failure -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;发送消息失败:&quot; + failure.getMessage());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下 <strong>KafkaTemplate</strong> 发送消息是采取异步方式发送的，如果希望同步发送消息只需要在 <strong>send</strong> 方法后面调用 <strong>get</strong> 方法即可，<strong>get</strong> 方法返回的即为结果（如果发送失败则抛出异常）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/sendSynCallBack&quot;)</span><br><span class="line">public void sendSynCallBack() throws InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        SendResult&lt;String, String&gt; sendResult =</span><br><span class="line">                kafkaTemplate.send(&quot;topic1&quot;, &quot;消息回调测试&quot;).get(1, TimeUnit.MICROSECONDS);</span><br><span class="line">        // 消息发送到的topic</span><br><span class="line">        String topic = sendResult.getRecordMetadata().topic();</span><br><span class="line">        // 消息发送到的分区</span><br><span class="line">        int partition = sendResult.getRecordMetadata().partition();</span><br><span class="line">        // 消息在分区内的offset</span><br><span class="line">        long offset = sendResult.getRecordMetadata().offset();</span><br><span class="line">        System.out.println(&quot;发送消息成功:&quot; + topic + &quot;-&quot; + partition + &quot;-&quot; + offset);</span><br><span class="line">    &#125; catch (TimeoutException e) &#123;</span><br><span class="line">        System.out.println(&quot;发送消息超时&quot;);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        System.out.println(&quot;发送消息失败:&quot; + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生产者：事务管理"><a href="#生产者：事务管理" class="headerlink" title="生产者：事务管理"></a>生产者：事务管理</h3><p> <strong>Kafka</strong> 同数据库一样支持事务，当发生异常或者出现特定逻辑判断的时候可以进行回滚，确保消息监听器不会接收到一些错误的或者不需要的消息</p>
<p>使用executeInTransaction 方法添加事务,这种方式开启事务是不需要配置事务管理器的，也可以称为本地事务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">   private KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">   // 发送消息</span><br><span class="line">   @GetMapping(&quot;/test&quot;)</span><br><span class="line">   public void test() &#123;</span><br><span class="line">       // 声明事务：后面报错消息不会发出去</span><br><span class="line">       kafkaTemplate.executeInTransaction(operations -&gt; &#123;</span><br><span class="line">           operations.send(&quot;topic1&quot;,&quot;test executeInTransaction&quot;);</span><br><span class="line">           throw new RuntimeException(&quot;fail&quot;);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>也可以定义配置 <strong>KafkaTransactionManager</strong>，使用生产者工厂来创建这个事务管理类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class KafkaProducerConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;spring.kafka.bootstrap-servers&#125;&quot;)</span><br><span class="line">    private String servers;</span><br><span class="line">    @Value(&quot;$&#123;spring.kafka.producer.retries&#125;&quot;)</span><br><span class="line">    private int retries;</span><br><span class="line">    @Value(&quot;$&#123;spring.kafka.producer.acks&#125;&quot;)</span><br><span class="line">    private String acks;</span><br><span class="line">    @Value(&quot;$&#123;spring.kafka.producer.batch-size&#125;&quot;)</span><br><span class="line">    private int batchSize;</span><br><span class="line">    @Value(&quot;$&#123;spring.kafka.producer.properties.linger.ms&#125;&quot;)</span><br><span class="line">    private int linger;</span><br><span class="line">    @Value(&quot;$&#123;spring.kafka.producer.buffer-memory&#125;&quot;)</span><br><span class="line">    private int bufferMemory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Map&lt;String, Object&gt; producerConfigs() &#123;</span><br><span class="line">        Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();</span><br><span class="line">        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, servers);</span><br><span class="line">        props.put(ProducerConfig.RETRIES_CONFIG, retries);</span><br><span class="line">        props.put(ProducerConfig.ACKS_CONFIG, acks);</span><br><span class="line">        props.put(ProducerConfig.BATCH_SIZE_CONFIG, batchSize);</span><br><span class="line">        props.put(ProducerConfig.LINGER_MS_CONFIG, linger);</span><br><span class="line">        props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, bufferMemory);</span><br><span class="line">        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</span><br><span class="line">        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</span><br><span class="line">        return props;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ProducerFactory&lt;String, Object&gt; producerFactory() &#123;</span><br><span class="line">        DefaultKafkaProducerFactory factory = new DefaultKafkaProducerFactory&lt;&gt;(producerConfigs());</span><br><span class="line">        factory.transactionCapable();</span><br><span class="line">        factory.setTransactionIdPrefix(&quot;tran-&quot;);</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public KafkaTransactionManager transactionManager() &#123;</span><br><span class="line">        KafkaTransactionManager manager = new KafkaTransactionManager(producerFactory());</span><br><span class="line">        return manager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>controller添加方法测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">   private KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">   // 发送消息</span><br><span class="line">   @GetMapping(&quot;/test&quot;)</span><br><span class="line">   @Transactional</span><br><span class="line">   public void test() &#123;</span><br><span class="line">       kafkaTemplate.send(&quot;topic1&quot;,&quot;test executeInTransaction&quot;);</span><br><span class="line">       throw new RuntimeException(&quot;fail&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者：指定topic、partition、offset消费"><a href="#消费者：指定topic、partition、offset消费" class="headerlink" title="消费者：指定topic、partition、offset消费"></a>消费者：指定topic、partition、offset消费</h3><p>使用 topics 指定 topic</p>
<p>监听器主要是使用 <strong>@KafkaListenter</strong> 注解即可，而通过 <strong>topics</strong> 参数设置监听的 <strong>topic</strong>（可监听多个，用逗号隔开）：<strong>id</strong>（消费者 <strong>ID</strong>）、 <strong>groupId</strong>（消费组 <strong>ID</strong>）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@KafkaListener(id = &quot;consumer1&quot;,groupId = &quot;my-group1&quot;, topics = &#123;&quot;topic1&quot;,&quot;topic2&quot;&#125;)</span><br><span class="line">public void listen1(String data) &#123;</span><br><span class="line">    System.out.println(&quot;接收到消息：&quot;+data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 topicPartitions 指定 topic、parition、offset</p>
<p><strong>topicPartitions</strong> 可配置更加详细的监听信息，比如下面代码同样是同时监听 <strong>topic1</strong> 和 <strong>topic2</strong>，不同在于这次：</p>
<ul>
<li>监听 <strong>topic1</strong> 的 <strong>0</strong> 号分区</li>
<li>监听 <strong>topic2</strong> 的 <strong>0</strong> 号和 <strong>1</strong> 号分区（其中 <strong>1</strong> 号分区的初始偏移量为 <strong>100</strong>）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 消费监听</span><br><span class="line">@KafkaListener(id = &quot;consumer1&quot;,groupId = &quot;my-group1&quot;,topicPartitions = &#123;</span><br><span class="line">        @TopicPartition(topic = &quot;topic1&quot;, partitions = &#123; &quot;0&quot; &#125;),</span><br><span class="line">        @TopicPartition(topic = &quot;topic2&quot;, partitions = &quot;0&quot;,</span><br><span class="line">                partitionOffsets = @PartitionOffset(partition = &quot;1&quot;, initialOffset = &quot;100&quot;))</span><br><span class="line">&#125;)</span><br><span class="line">public void listen2(String data) &#123;</span><br><span class="line">    System.out.println(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时想topic中发送不同的分区消息,message2因为没有监听不会被打印出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kafkaTemplate.send(&quot;topic1&quot;, 0, &quot;key1&quot;, &quot;message1&quot;);</span><br><span class="line">     kafkaTemplate.send(&quot;topic1&quot;, 1, &quot;key2&quot;, &quot;message2&quot;);</span><br><span class="line">     kafkaTemplate.send(&quot;topic2&quot;, 0, &quot;key3&quot;, &quot;message3&quot;);</span><br><span class="line">     kafkaTemplate.send(&quot;topic2&quot;, 1, &quot;key4&quot;, &quot;message4&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="消费者：获取消息头和消息实体"><a href="#消费者：获取消息头和消息实体" class="headerlink" title="消费者：获取消息头和消息实体"></a>消费者：获取消息头和消息实体</h3><p>之前的样例中消费者这边都直接获取消息内容并使用，如果我们还想要获取分区信息、消息头等其他内容的话，有如下两种方式。</p>
<p>使用 ConsumerRecord 类方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@KafkaListener(id = &quot;consumer1&quot;,groupId = &quot;my-group1&quot;, topics = &#123;&quot;topic1&quot;,&quot;topic2&quot;&#125;)</span><br><span class="line">public void listen1(ConsumerRecord&lt;String, Object&gt; record) &#123;</span><br><span class="line">    System.out.println(&quot;接收到消息：&quot;+record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用注解的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 消费监听</span><br><span class="line">@KafkaListener(topics = &#123;&quot;topic2&quot;&#125;)</span><br><span class="line">public void listen2(@Payload String data,</span><br><span class="line">                    @Header(KafkaHeaders.RECEIVED_TOPIC) String topic,</span><br><span class="line">                    @Header(KafkaHeaders.RECEIVED_PARTITION_ID) int partition,</span><br><span class="line">                    @Header(KafkaHeaders.RECEIVED_MESSAGE_KEY) String key,</span><br><span class="line">                    @Header(KafkaHeaders.RECEIVED_TIMESTAMP) long ts) &#123;</span><br><span class="line">    System.out.println(data);</span><br><span class="line">    System.out.println(topic);</span><br><span class="line">    System.out.println(partition);</span><br><span class="line">    System.out.println(key);</span><br><span class="line">    System.out.println(ts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者：批量消费"><a href="#消费者：批量消费" class="headerlink" title="消费者：批量消费"></a>消费者：批量消费</h3><p>批量消费,配置文件添加参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#设置消费类型批量消费</span><br><span class="line">spring.kafka.listener.type=batch</span><br><span class="line">#一次最多消费5条</span><br><span class="line">spring.kafka.consumer.max-poll-records=5</span><br><span class="line"># 并发数设为3 并发量根据实际分区数决定，必须小于等于分区数，否则会有线程一直处于空闲状态。</span><br><span class="line">spring.kafka.listener.concurrency=3</span><br></pre></td></tr></table></figure>
<p>修改消费者的接收类型为List</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@KafkaListener(id = &quot;consumer1&quot;,groupId = &quot;my-group1&quot;, topics = &#123;&quot;topic1&quot;,&quot;topic2&quot;&#125;)</span><br><span class="line">public void listen1(List&lt;ConsumerRecord&lt;String, String&gt;&gt; record) &#123;</span><br><span class="line">    System.out.println(&quot;接收到消息：&quot;+record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者：异常处理器"><a href="#消费者：异常处理器" class="headerlink" title="消费者：异常处理器"></a>消费者：异常处理器</h3><p>在KafkaInitialConfiguration配置类中创建异常处理类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    //异常处理器</span><br><span class="line">    @Bean</span><br><span class="line">    public ConsumerAwareListenerErrorHandler myConsumerAwareErrorHandler() &#123;</span><br><span class="line">        return new ConsumerAwareListenerErrorHandler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object handleError(Message&lt;?&gt; message, ListenerExecutionFailedException exception,</span><br><span class="line">                                      Consumer&lt;?, ?&gt; consumer) &#123;</span><br><span class="line">                System.out.println(&quot;--- 发生消费异常 ---&quot;);</span><br><span class="line">                System.out.println(message.getPayload());</span><br><span class="line">                System.out.println(exception);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">//        return (message, exception, consumer) -&gt; &#123;</span><br><span class="line">//            System.out.println(&quot;--- 发生消费异常 ---&quot;);</span><br><span class="line">//            System.out.println(message.getPayload());</span><br><span class="line">//            System.out.println(exception);</span><br><span class="line">//            return null;</span><br><span class="line">//        &#125;;</span><br><span class="line">//    &#125;</span><br></pre></td></tr></table></figure>
<p>使用异常处理器也比较简单，在监听的注解里面指定异常方法里面异常处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 消费监听</span><br><span class="line">@KafkaListener(topics = &#123;&quot;topic3&quot;&#125;, errorHandler = &quot;myConsumerAwareErrorHandler&quot;)</span><br><span class="line">public void listen1(String data) throws Exception &#123;</span><br><span class="line">    throw new Exception(&quot;模拟一个异常&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者：消息过滤器"><a href="#消费者：消息过滤器" class="headerlink" title="消费者：消息过滤器"></a>消费者：消息过滤器</h3><p>  配置消息过滤器十分简单，只需要为监听容器工厂配置一个 <strong>RecordFilterStrategy</strong>（消息过滤策略），返回 <strong>true</strong> 的时候消息将会被抛弃，返回 <strong>false</strong> 时，消息则能正常抵达监听容器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class KafkaInitialConfiguration &#123;</span><br><span class="line"> </span><br><span class="line">    // 监听器工厂</span><br><span class="line">    @Autowired</span><br><span class="line">    private ConsumerFactory consumerFactory;</span><br><span class="line"> </span><br><span class="line">    // 配置一个消息过滤策略</span><br><span class="line">    @Bean</span><br><span class="line">    public ConcurrentKafkaListenerContainerFactory myFilterContainerFactory() &#123;</span><br><span class="line">        ConcurrentKafkaListenerContainerFactory factory =</span><br><span class="line">                new ConcurrentKafkaListenerContainerFactory();</span><br><span class="line">        factory.setConsumerFactory(consumerFactory);</span><br><span class="line">        // 被过滤的消息将被丢弃</span><br><span class="line">        factory.setAckDiscarded(true);</span><br><span class="line">        // 消息过滤策略（将消息转换为long类型，判断是奇数还是偶数，把所有奇数过滤，监听器只接收偶数）</span><br><span class="line">        factory.setRecordFilterStrategy(new RecordFilterStrategy() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean filter(ConsumerRecord consumerRecord) &#123;</span><br><span class="line">                long data = Long.parseLong((String) consumerRecord.value());</span><br><span class="line">                if (data % 2 == 0) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                //返回true将会被丢弃</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用消息过滤器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class KafkaConsumer &#123;</span><br><span class="line">    // 消费监听</span><br><span class="line">    @KafkaListener(topics = &#123;&quot;topic2&quot;&#125;, containerFactory = &quot;myFilterContainerFactory&quot;)</span><br><span class="line">    public void listen1(String data) &#123;</span><br><span class="line">        System.out.println(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者：消息转发"><a href="#消费者：消息转发" class="headerlink" title="消费者：消息转发"></a>消费者：消息转发</h3><p>在实际开发中，我们常常需要使用转发功能实现业务解耦。比如：应用 <strong>A</strong> 从 <strong>topic1</strong> 获取到消息，经过处理后转发到 <strong>topic2</strong>。应用 <strong>B</strong> 监听 <strong>topic2</strong> 获取消息再次进行处理。</p>
<p><strong>@SendTo</strong> 注解即可以实现消息的转发，被注解方法的 <strong>return</strong> 值即转发的消息内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class KafkaConsumer &#123;</span><br><span class="line">    // 消费监听</span><br><span class="line">    @KafkaListener(topics = &#123;&quot;topic1&quot;&#125;)</span><br><span class="line">    @SendTo(&quot;topic2&quot;)</span><br><span class="line">    public String listen1(String data) &#123;</span><br><span class="line">        System.out.println(&quot;业务A收到消息：&quot; + data);</span><br><span class="line">        return data + &quot;(已处理)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 消费监听</span><br><span class="line">    @KafkaListener(topics = &#123;&quot;topic2&quot;&#125;)</span><br><span class="line">    public void listen2(String data) &#123;</span><br><span class="line">        System.out.println(&quot;业务B收到消息：&quot; + data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者：动态启动、停止监听器"><a href="#消费者：动态启动、停止监听器" class="headerlink" title="消费者：动态启动、停止监听器"></a>消费者：动态启动、停止监听器</h3><p> 默认情况下，当项目启动时，监听器就开始工作（监听消费发送到指定 <strong>topic</strong> 的消息）。如果我们不想让监听器立即工作，想在程序运行的过程中能够动态地开启、关闭监听器，可以借助 <strong>KafkaListenerEndpointRegistry</strong> 实现，下面通过样例进行演示。</p>
<p>消费者这边代码没有什么特别的，主要是设置了个消费者 <strong>ID</strong>（监听器 <strong>ID</strong>），后面要根据这个 <strong>ID</strong> 来开启、关闭监听</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class KafkaConsumer &#123;</span><br><span class="line">    // 消费监听</span><br><span class="line">    @KafkaListener(id = &quot;myListener1&quot;, topics = &#123;&quot;topic1&quot;&#125;)</span><br><span class="line">    public void listen1(String data) &#123;</span><br><span class="line">        System.out.println(&quot;监听器收到消息：&quot; + data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>）然后我定义两个 <strong>controller</strong> 接口分别通过 <strong>KafkaListenerEndpointRegistry</strong> 来控制监听器的开启、关闭：</p>
<p><strong>注意：</strong></p>
<ul>
<li><strong>KafkaListenerEndpointRegistry</strong> 在 <strong>SpringIO</strong> 中已经被注册为 <strong>Bean</strong>，直接注入使用即可。</li>
<li>还需要注意一下启动监听容器的方法，<strong>resume</strong> 是恢复的意思不是启动的意思。所以我们需要判断容器是否运行，如果运行则调用 <strong>resume</strong> 方法，否则调用 <strong>start</strong> 方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class KafkaProducer &#123;</span><br><span class="line"> </span><br><span class="line">    @Autowired</span><br><span class="line">    private KafkaListenerEndpointRegistry registry;</span><br><span class="line"> </span><br><span class="line">    @Autowired</span><br><span class="line">    private KafkaTemplate&lt;String, Object&gt; kafkaTemplate;</span><br><span class="line"> </span><br><span class="line">    // 发送消息</span><br><span class="line">    @GetMapping(&quot;/test&quot;)</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        System.out.println(&quot;监听器发送消息!&quot;);</span><br><span class="line">        kafkaTemplate.send(&quot;topic1&quot;, &quot;1条测试消息&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 开启监听</span><br><span class="line">    @GetMapping(&quot;/start&quot;)</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;开启监听&quot;);</span><br><span class="line">        //判断监听容器是否启动，未启动则将其启动</span><br><span class="line">        if (!registry.getListenerContainer(&quot;myListener1&quot;).isRunning()) &#123;</span><br><span class="line">            registry.getListenerContainer(&quot;myListener1&quot;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        registry.getListenerContainer(&quot;myListener1&quot;).resume();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 关闭监听</span><br><span class="line">    @GetMapping(&quot;/stop&quot;)</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        System.out.println(&quot;关闭监听&quot;);</span><br><span class="line">        //判断监听容器是否启动，未启动则将其启动</span><br><span class="line">        registry.getListenerContainer(&quot;myListener1&quot;).pause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>禁止监听器自启动</p>
<p>默认情况下，当项目启动的时候，监听器就开始工作。如果想要禁止监听器自启动，首先我们定义一个不自动启动的监听容器工厂：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class KafkaInitialConfiguration &#123;</span><br><span class="line"> </span><br><span class="line">    // 监听器工厂</span><br><span class="line">    @Autowired</span><br><span class="line">    private ConsumerFactory consumerFactory;</span><br><span class="line"> </span><br><span class="line">    // 监听器容器工厂(设置禁止KafkaListener自启动)</span><br><span class="line">    @Bean</span><br><span class="line">    public ConcurrentKafkaListenerContainerFactory delayContainerFactory() &#123;</span><br><span class="line">        ConcurrentKafkaListenerContainerFactory container =</span><br><span class="line">                new ConcurrentKafkaListenerContainerFactory();</span><br><span class="line">        container.setConsumerFactory(consumerFactory);</span><br><span class="line">        //禁止自动启动</span><br><span class="line">        container.setAutoStartup(false);</span><br><span class="line">        return container;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将这个容器工厂的 <strong>BeanName</strong> 放到 <strong>@KafkaListener</strong> 注解的 <strong>containerFactory</strong> 属性里面。这样该监听器就不会自动启动了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class KafkaConsumer &#123;</span><br><span class="line">    // 消费监听</span><br><span class="line">    @KafkaListener(id = &quot;myListener1&quot;, topics = &#123;&quot;topic1&quot;&#125;,</span><br><span class="line">            containerFactory = &quot;delayContainerFactory&quot;)</span><br><span class="line">    public void listen1(String data) &#123;</span><br><span class="line">        System.out.println(&quot;监听器收到消息：&quot; + data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm内存模型</title>
    <url>/2020/03/31/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="java虚拟机内存区域"><a href="#java虚拟机内存区域" class="headerlink" title="java虚拟机内存区域"></a>java虚拟机内存区域</h1><p><img src="/2020/03/31/jvm内存模型/jvm内存模型.png" width="500" height="500" alt="栈帧模型" align="center"></p>
<h2 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h2><p>​    程序计数器是一块很小的内存空间，它是线程私有的，可以认作为当前线程的行号指示器。我们知道对于一个处理器(如果是多核cpu那就是一核)，在一个确定的时刻都只会执行一条线程中的指令，一条线程中有多个指令，为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器，不同线程之间的程序计数器互不影响，独立存储。</p>
<p>如果线程执行的是个java方法，那么计数器记录虚拟机字节码指令的地址。如果为native【底层方法】，那么计数器为空。这块内存区域是虚拟机规范中唯一没有OutOfMemoryError的区域。</p>
<h2 id="2、java栈（虚拟机栈）"><a href="#2、java栈（虚拟机栈）" class="headerlink" title="2、java栈（虚拟机栈）"></a>2、java栈（虚拟机栈）</h2><p>同计数器也为线程私有，生命周期与相同，就是我们平时说的栈，<strong>栈描述的是Java方法执行的内存模型</strong>。</p>
<p><strong>每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。【栈先进后出】</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">栈帧: 是用来存储数据和部分过程结果的数据结构。</span><br><span class="line">栈帧的位置:  内存 -&gt; 运行时数据区 -&gt; 某个线程对应的虚拟机栈 -&gt; here[在这里]</span><br><span class="line">栈帧大小确定时间: 编译期确定，不受运行期数据影响。</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/31/jvm内存模型/栈帧模型.png" width="300" height="300" alt="栈帧模型" align="center"></p>
<p><strong>平时说的栈一般指局部变量表部分。</strong></p>
<p>局部变量表:一片连续的内存空间，用来存放方法参数，以及方法内定义的局部变量，存放着编译期间已知的数据类型(八大基本类型和对象引用(reference类型),returnAddress类型。它的最小的局部变量表空间单位为Slot，虚拟机没有指明Slot的大小.</p>
<h2 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h2><p>本地方法栈是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务，可能底层调用的c或者c++，</p>
<h2 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h2><p>对于大多数应用来说，堆是java虚拟机管理内存最大的一块内存区域，因为堆存放的对象是线程共享的，所以多线程的时候也需要同步机制。</p>
<p>java虚拟机规范对这块的描述是:所有对象实例及数组都要在堆上分配内存，但随着JIT编译器的发展和逃逸分析技术的成熟，这个说法也不是那么绝对，但是大多数情况都是这样的。</p>
<p>即时编译器:可以把把Java的字节码，包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的程序)</p>
<p>逃逸分析:通过逃逸分析来决定某些实例或者变量是否要在堆中进行分配，如果开启了逃逸分析，即可将这些变量直接在栈上进行分配，而非堆上进行分配。这些变量的指针可以被全局所引用，或者其其它线程所引用。</p>
<p>它是所有线程共享的，它的目的是存放对象实例。同时它也是GC所管理的主要区域，因此常被称为GC堆，又由于现在收集器常使用分代算法，Java堆中还可以细分为新生代和老年代。</p>
<h2 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h2><p>方法区同堆一样，是所有线程共享的内存区域，为了区分堆，又被称为非堆。</p>
<p>主要是存储已被虚拟机加载的<strong>类信息、常量、静态变量</strong>，如static修饰的变量加载类的时候就被加载到方法区中。（jdk1.8将方法移掉到直接内存中）</p>
<p>运行时常量池也是方法区的一部分，class文件除了有类的字段、接口、方法等描述信息之外，还有常量池用于存放编译期间生成的各种字面量和符号引用。</p>
<p>在老版jdk，方法区也被称为永久代，因为没有强制要求必须实现垃圾回收，HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。</p>
<p><strong>jdk8真正开始废弃永久代，而使用元空间(Metaspace)</strong></p>
<p>java虚拟机对方法区比较宽松，除了跟堆一样可以不存在连续的内存空间，定义空间和可扩展空间，还可以选择不实现垃圾收集。</p>
<h1 id="Java对象的内存布局"><a href="#Java对象的内存布局" class="headerlink" title="Java对象的内存布局"></a>Java对象的内存布局</h1><p>在HotSpot虚拟机中。对象在内存中存储的布局分为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.对象头</span><br><span class="line">2.实例数据</span><br><span class="line">3.对齐填充</span><br></pre></td></tr></table></figure>
<h2 id="对象头【markword】"><a href="#对象头【markword】" class="headerlink" title="对象头【markword】"></a>对象头【markword】</h2><p>这其中锁标识位需要特别关注下。<strong>锁标志位与是否为偏向锁对应到唯一的锁状态</strong>。</p>
<p>锁的状态分为四种<code>无锁状态</code>、<code>偏向锁</code>、<code>轻量级锁</code>和<code>重量级锁</code></p>
<p>不同状态时对象头的区间含义，如图所示。</p>
<p>在32位系统下，对象头8字节，64位则是16个字节</p>
<p><img src="/2020/03/31/jvm内存模型/对象锁.png" width="500" height="500" alt="锁类型" align="center"></p>
<p>关于对象头和锁之间的转换</p>
<p><img src="/2020/03/31/jvm内存模型/锁流程.png" width="500" height="500" alt="锁流程" align="center"></p>
<h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">存放对象程序中各种类型的字段类型，不管是从父类中继承下来的还是在子类中定义的。</span><br><span class="line">分配策略:相同宽度的字段总是放在一起，比如<span class="keyword">double</span>和<span class="keyword">long</span></span><br></pre></td></tr></table></figure>
<h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>这部分没有特殊的含义，仅仅起到占位符的作用满足JVM要求。由于HotSpot规定对象的大小必须是8的整数倍，对象头刚好是整数倍，如果实例数据不是的话，就需要占位符对齐填充</p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>java程序需要通过引用(ref)数据来操作堆上面的对象，那么如何通过引用定位、访问到对象的具体位置。</p>
<p>对象的访问方式由虚拟机决定，java虚拟机提供两种主流的方式<br>1.句柄访问对象<br>2.直接指针访问对象。(Sun HotSpot使用这种方式)</p>
<h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p>简单来说就是java堆划出一块内存作为句柄池,引用中存储对象的句柄地址,句柄中包含对象实例数据、类型数据的地址信息。</p>
<p>优点:引用中存储的是稳定的句柄地址,在对象被移动【垃圾收集时移动对象是常态】只需改变句柄中实例数据的指针，不需要改动引用【ref】本身。</p>
<p><img src="/2020/03/31/jvm内存模型/句柄访问.png" width="500" height="500" alt="句柄访问" align="center"></p>
<h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3><p>与句柄访问不同的是，ref中直接存储的就是对象的实例数据,但是类型数据跟句柄访问方式一样。</p>
<p>优点:优势很明显，就是速度快，<strong>相比于句柄访问少了一次指针定位的开销时间</strong>。【可能是出于Java中对象的访问时十分频繁的,平时我们常用的JVM HotSpot采用此种方式】</p>
<p><img src="/2020/03/31/jvm内存模型/直接指针.png" width="500" height="500" alt="直接指针" align="center"></p>
<h1 id="GC简介"><a href="#GC简介" class="headerlink" title="GC简介"></a>GC简介</h1><p>java GC泛指java的垃圾回收机制，该机制是java与C/C++的主要区别之一，我们在日常写java代码的时候，一般都不需要编写内存回收或者垃圾清理的代码，也不需要像C/C++那样做类似delete/free的操作。</p>
<p>没必要深入到GC的底层实现，但是要学会看懂gc及定位一些内存泄漏问题。</p>
<h2 id="那些内存需要回收"><a href="#那些内存需要回收" class="headerlink" title="那些内存需要回收"></a>那些内存需要回收</h2><p>上面中JVM中程序计数器、虚拟机栈、本地方法栈都是线程私有，随线程存活死亡，而其中的栈帧随着方法的执行顺序执行入栈和出栈操作，一个栈帧需要多少内存取决于具体的虚拟机实现并且在编译期间确定，当方法执行完，内存就会回收。</p>
<p>而<code>Java堆</code>、<code>方法区</code>则不一样。方法区存放着类加载信息，但是一个接口中多个实现类需要的内存可能不太一样，一个方法中多个分支需要的内存也可能不一样【只有在运行期间才可知道这个方法创建了哪些对象没需要多少内存】，这部分内存的分配和回收都是动态的，gc关注的也正是这部分的内存。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Java</span>堆是<span class="selector-tag">GC</span>回收的“重点区域”。堆中基本存放着所有对象实例，<span class="selector-tag">gc</span>进行回收前，第一件事就是确认哪些对象存活，哪些死去</span><br></pre></td></tr></table></figure>
<h2 id="堆的回收区域"><a href="#堆的回收区域" class="headerlink" title="堆的回收区域"></a>堆的回收区域</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">为了高效的回收，<span class="selector-tag">jvm</span>将堆分为三个区域</span><br><span class="line">1.新生代（<span class="selector-tag">Young</span> <span class="selector-tag">Generation</span>）<span class="selector-tag">NewSize</span>和<span class="selector-tag">MaxNewSize</span>分别可以控制年轻代的初始大小和最大的大小</span><br><span class="line">2.老年代（<span class="selector-tag">Old</span> <span class="selector-tag">Generation</span>）</span><br><span class="line">3.永久代（<span class="selector-tag">Permanent</span> <span class="selector-tag">Generation</span>）【1<span class="selector-class">.8</span>以后采用元空间，就不在堆中了】</span><br></pre></td></tr></table></figure>
<h2 id="判断对象是否存活算法"><a href="#判断对象是否存活算法" class="headerlink" title="判断对象是否存活算法"></a>判断对象是否存活算法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.引用计数算法</span><br><span class="line">早期判断对象是否存活大多都是以这种算法，这种算法判断很简单，简单来说就是给对象添加一个引用计数器，每当对象被引用一次就加1，引用失效时就减1。当为0的时候就判断对象不会再被引用。</span><br><span class="line">优点:实现简单效率高，被广泛使用与如python何游戏脚本语言上。</span><br><span class="line">缺点:难以解决循环引用的问题，就是假如两个对象互相引用已经不会再被其它其它引用，导致一直不会为0就无法进行回收。</span><br><span class="line"></span><br><span class="line">2.可达性分析算法</span><br><span class="line">目前主流的商用语言[如java、c<span class="comment">#]采用的是可达性分析算法判断对象是否存活。这个算法有效解决了循环利用的弊端。</span></span><br><span class="line">它的基本思路是通过一个称为“GC Roots”的对象为起始点，搜索所经过的路径称为引用链，当一个对象到GC Roots没有任何引用跟它连接则证明对象是不可用的。</span><br></pre></td></tr></table></figure>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>jvm中，可达性分析算法帮我们解决了哪些对象可以回收的问题，垃圾收集算法则关心怎么回收。</p>
<h3 id="三大垃圾收集算法"><a href="#三大垃圾收集算法" class="headerlink" title="三大垃圾收集算法"></a>三大垃圾收集算法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>标记/清除算法【最基础】</span><br><span class="line"><span class="number">2.</span>复制算法</span><br><span class="line"><span class="number">3.</span>标记/整理算法</span><br><span class="line">jvm采用<span class="string">`分代收集算法`</span>对不同区域采用不同的回收算法。</span><br></pre></td></tr></table></figure>
<p><strong>新生代采用复制算法</strong></p>
<p>新生代中因为对象都是”朝生夕死的”，【深入理解JVM虚拟机上说98%的对象,不知道是不是这么多，总之就是存活率很低】，适用于复制算法【复制算法比较适合用于存活率低的内存区域】。它优化了标记/清除算法的效率和内存碎片问题，且JVM不以5:5分配内存【由于存活率低，不需要复制保留那么大的区域造成空间上的浪费，因此不需要按1:1【原有区域:保留空间】划分内存区域，而是将内存分为一块Eden空间和From Survivor、To Survivor【保留空间】，三者默认比例为8:1:1，优先使用Eden区，若Eden区满，则将对象复制到第二块内存区上。但是不能保证每次回收都只有不多于10%的对象存货，所以Survivor区不够的话，则会依赖老年代年存进行分配】</p>
<p>GC开始时，对象只会存于Eden和From Survivor区域，To Survivor【保留空间】为空。</p>
<p>GC进行时，Eden区所有存活的对象都被复制到To Survivor区，而From Survivor区中，仍存活的对象会根据它们的年龄值决定去向，年龄值达到年龄阈值(默认15是因为对象头中年龄战4bit，新生代每熬过一次垃圾回收，年龄+1)，则移到老年代，没有达到则复制到To Survivor。</p>
<p><strong>老年代采用<code>标记/清除算法</code>或<code>标记/整理算法</code></strong></p>
<p>由于老年代存活率高，没有额外空间给他做担保，必须使用这两种算法。</p>
<h3 id="枚举根节点算法"><a href="#枚举根节点算法" class="headerlink" title="枚举根节点算法"></a>枚举根节点算法</h3><p>可作为GC Roos的节点主要是在一些全局引用【如常量或静态属性】、执行上下文【如栈帧中本地变量表】中。那么如何在这么多全局变量和本地变量表找到【枚举】根节点将是个问题。</p>
<p>可达性分析算法需考虑</p>
<p>1.如果方法区几百兆，一个个检查里面的引用，将耗费大量资源。</p>
<p>2.在分析时，需保证这个对象引用关系不再变化，否则结果将不准确。【因此GC进行时需停掉其它所有java执行线程(Sun把这种行为称为‘Stop the World’)，即使是号称几乎不会停顿的CMS收集器，枚举根节点时也需停掉线程】</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">年轻代收集器</span><br><span class="line"><span class="selector-tag">Serial</span>、<span class="selector-tag">ParNew</span>、<span class="selector-tag">Parallel</span> <span class="selector-tag">Scavenge</span></span><br><span class="line">老年代收集器</span><br><span class="line"><span class="selector-tag">Serial</span> <span class="selector-tag">Old</span>、<span class="selector-tag">Parallel</span> <span class="selector-tag">Old</span>、<span class="selector-tag">CMS</span>收集器</span><br><span class="line">特殊收集器</span><br><span class="line"><span class="selector-tag">G1</span>收集器<span class="selector-attr">[新型，不在年轻、老年代范畴内]</span></span><br></pre></td></tr></table></figure>
<h2 id="Minor-GC、Major-GC、FULL-GC、mixed-gc"><a href="#Minor-GC、Major-GC、FULL-GC、mixed-gc" class="headerlink" title="Minor GC、Major GC、FULL GC、mixed gc"></a>Minor GC、Major GC、FULL GC、mixed gc</h2><h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><blockquote>
<p>在年轻代<code>Young space</code>(包括Eden区和Survivor区)中的垃圾回收称之为 Minor GC,Minor GC只会清理年轻代.</p>
</blockquote>
<h3 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h3><blockquote>
<p>Major GC清理老年代(old GC)，但是通常也可以指和Full GC是等价，因为收集老年代的时候往往也会伴随着升级年轻代，收集整个Java堆。所以有人问的时候需问清楚它指的是full GC还是old GC。</p>
</blockquote>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><blockquote>
<p>full gc是对新生代、老年代、永久代【jdk1.8后没有这个概念了】统一的回收。</p>
<p>【知乎R大的回答:收集整个堆，包括young gen、old gen、perm gen（如果存在的话)、元空间(1.8及以上)等所有部分的模式】</p>
</blockquote>
<h3 id="mixed-GC【g1特有】"><a href="#mixed-GC【g1特有】" class="headerlink" title="mixed GC【g1特有】"></a>mixed GC【g1特有】</h3><blockquote>
<p>混合GC</p>
<p>收集整个young gen以及部分old gen的GC。只有G1有这个模式</p>
</blockquote>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>linux redis 安装</title>
    <url>/2019/08/08/linuz-redis-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#下载文件或者传到centos</span><br><span class="line">wget http://download.redis.io/releases/redis-5.0.3.tar.gz</span><br><span class="line">#解压文件</span><br><span class="line">tar -zxvf redis-5.0.3.tar.gz</span><br><span class="line">#cd切换到redis解压目录下，执行编译</span><br><span class="line">cd redis-5.0.3</span><br><span class="line">#编译</span><br><span class="line">make</span><br><span class="line">#安装并指定安装目录</span><br><span class="line">make install PREFIX=/usr/local/redis</span><br><span class="line">#修改 redis.conf 文件</span><br><span class="line"> vi redis.conf</span><br><span class="line"> //修改内容为daemonize no 改为 daemonize yes</span><br><span class="line"> //		   bind 127.0.0.0 改为bind 0.0.0.0</span><br><span class="line"> //        protected mode yes 改为 no</span><br><span class="line">#指定配置文件启动 </span><br><span class="line">./redis-server redis.conf</span><br><span class="line">#添加开机启动服务</span><br><span class="line">vi /etc/systemd/system/redis.service</span><br><span class="line">//内容为</span><br><span class="line">	[Unit]</span><br><span class="line">	Description=redis-server</span><br><span class="line">	After=network.target</span><br><span class="line">	[Service]</span><br><span class="line">	Type=forking</span><br><span class="line">	ExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/bin/redis.conf</span><br><span class="line">	PrivateTmp=true</span><br><span class="line">	[Install]</span><br><span class="line">	WantedBy=multi-user.target</span><br><span class="line">#设置开机启动</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start redis.service</span><br><span class="line">systemctl enable redis.service</span><br><span class="line">#创建 redis 命令软链接</span><br><span class="line">ln -s /usr/local/redis/bin/redis-cli /usr/bin/redis</span><br><span class="line"></span><br><span class="line">#服务操作命令</span><br><span class="line">systemctl start redis.service   #启动redis服务</span><br><span class="line">systemctl stop redis.service   #停止redis服务</span><br><span class="line">systemctl restart redis.service   #重新启动服务</span><br><span class="line">systemctl status redis.service   #查看服务当前状态</span><br><span class="line">systemctl enable redis.service   #设置开机自启动</span><br><span class="line">systemctl disable redis.service   #停止开机自启动</span><br><span class="line">#其他常用命令</span><br><span class="line">pkill redis  //停止redis</span><br><span class="line">卸载redis：</span><br><span class="line">rm -rf /usr/local/redis //删除安装目录</span><br><span class="line">rm -rf /usr/bin/redis-* //删除所有redis相关命令脚本</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linx</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql解决乱码</title>
    <url>/2019/08/05/mysql%E8%A7%A3%E5%86%B3%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<h1 id="解决数据在MYSQL中文乱码的问题"><a href="#解决数据在MYSQL中文乱码的问题" class="headerlink" title="解决数据在MYSQL中文乱码的问题"></a>解决数据在MYSQL中文乱码的问题</h1><p>@nbsp;@nbsp;@nbsp;@nbsp;最近自己在往阿里云服务器的数据库写数据的时候发现了中文乱码的问题<br>第一反应就编码格式不对，改成了utf还是乱码~~~唉,其实解决并不复杂</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//首先编辑mysql的文件</span><br><span class="line">vi /etc/my.cnf</span><br><span class="line">//在[mysql]下添加</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br><span class="line">//在[client]下添加</span><br><span class="line">default-character-set=utf8</span><br><span class="line">//然后 esc  </span><br><span class="line">//:wq  退出并保存</span><br><span class="line">退出以后重启mysql</span><br><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>redis知识点总结</title>
    <url>/2020/07/31/redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h1><p>reids 是由C语言编写的一个存储Key-value型的内存数据库，它是一种 NoSQL（not-only sql，泛指非关系型数据库）的数据库。</p>
<p>redis有如下有点</p>
<p>性能优秀，数据在内存中，读写速度非常快，支持并发 10W QPS。</p>
<p>单进程单线程，是线程安全的，采用 IO 多路复用机制。</p>
<p>丰富的数据类型，支持字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等。</p>
<p>支持数据持久化。<br>可以将内存中数据保存在磁盘中，重启时加载。</p>
<p>主从复制，哨兵，高可用。</p>
<p>可以用作分布式锁。</p>
<p>可以作为消息中间件使用，支持发布订阅。</p>
<h1 id="redis的数据结构"><a href="#redis的数据结构" class="headerlink" title="redis的数据结构"></a>redis的数据结构</h1><p>redis主要有五种数据结构 分别是String.list，hash,set,sorted set。</p>
<p>reids内部是使用redisObject对象来表实key-value。</p>
<p><img src="/2020/07/31/redis知识点总结/E:/blog\source\_posts\redis知识点总结\redis-object.png" alt></p>
<p>edisObject 最主要的信息如上图所示：type 表示一个 value 对象具体是何种数据类型，encoding 是不同数据类型在 Redis 内部的存储方式。</p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>String 是redis的最基本的数据，一个 Key 对应一个 Value。Value 不仅是 String，也可以是数字。</p>
<p>String 类型是二进制安全的，意思是 Redis 的 String 类型可以包含任何数据，比如 jpg 图片或者序列化的对象。String 类型的值最大能存储 512M。</p>
<p>实战场景：</p>
<p>1.缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</p>
<p>2.计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。</p>
<p>3.session：常见方案spring session + redis实现session共享，</p>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>Hash是一个键值（key-value）的集合。Redis 的 Hash 是一个 String 的 Key 和 Value 的映射表，Hash 特别适合存储对象。常用命令：hget，hset，hgetall 等。</p>
<p>实战场景：</p>
<p>1.缓存： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List 说白了就是链表（redis 使用双端链表实现的 List），是有序的，value可以重复，可以通过下标取出对应的value值，左右两边都能进行插入和删除数据。</p>
<p>实战场景：</p>
<p>1.timeline：例如微博的时间轴，有人发布微博，用lpush加入时间轴，展示新的列表信息。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>集合类型也是用来保存多个字符串的元素，但和列表不同的是集合中 1. 不允许有重复的元素，2.集合中的元素是无序的，不能通过索引下标获取元素，3.支持集合间的操作，可以取多个集合取交集、并集、差集。</p>
<p>实战场景;</p>
<p>1.标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</p>
<p>2.点赞，或点踩，收藏等，可以放到set中实现</p>
<h2 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h2><p>有序集合和集合有着必然的联系，保留了集合不能有重复成员的特性，区别是，有序集合中的元素是可以排序的，它给每个元素设置一个分数，作为排序的依据。</p>
<p>实战场景：</p>
<p>1.排行榜：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。</p>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制。</p>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</p>
<p>优点：</p>
<ul>
<li>1、只有一个文件 dump.rdb，方便持久化。</li>
<li>2、容灾性好，一个文件可以保存到安全的磁盘。</li>
<li>3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</li>
<li>4.相对于数据集大时，比 AOF 的启动效率更高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</li>
<li>2、AOF（Append-only file)持久化方式： 是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件。</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。</p>
<p>当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。</p>
<p>优点：</p>
<ul>
<li>1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</li>
<li>2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li>
<li>3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</li>
</ul>
<p>缺点：</p>
<ul>
<li>1、AOF 文件比 RDB 文件大，且恢复速度慢。</li>
<li>2、数据集大的时候，比 rdb 启动效率低。</li>
</ul>
<h2 id="Redis持久化数据和缓存问题"><a href="#Redis持久化数据和缓存问题" class="headerlink" title="Redis持久化数据和缓存问题"></a>Redis持久化数据和缓存问题</h2><ul>
<li>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li>
<li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</li>
</ul>
<h2 id="过期的删除策略"><a href="#过期的删除策略" class="headerlink" title="过期的删除策略"></a>过期的删除策略</h2><p><strong>EXPIREAT PEXPIREAT</strong> 定义过期时间</p>
<blockquote>
<p>　　　　<strong>EXPIREAT</strong> 接口定义：EXPIREAT key “timestamp”<br>　　　　接口描述：设置一个key在”timestamp”(时间戳(秒))之后过期。返回1代表设置成功，返回0代表key不存在或者无法设置过期时间。</p>
<p>　　　　<strong>PEXPIREAT</strong> 接口定义：PEXPIREAT key “milliseconds-timestamp”<br>　　　　接口描述：设置一个key在”milliseconds-timestamp”(时间戳(毫秒))之后过期。返回1代表设置成功，返回0代表key不存在或者无法设置过期时间</p>
</blockquote>
<p><strong>TTL PTTL</strong> 查询过期的剩余时间</p>
<blockquote>
<p>　　　　<strong>TTL</strong> 接口定义：TTL key<br>　　　　接口描述：获取key的过期时间。如果key存在过期时间，返回剩余生存时间(秒)；如果key是永久的，返回-1；如果key不存在或者已过期，返回-2。</p>
<p>　　　　<strong>PTTL</strong> 接口定义：PTTL key<br>　　　　接口描述：获取key的过期时间。如果key存在过期时间，返回剩余生存时间(毫秒)；如果key是永久的，返回-1；如果key不存在或者已过期，返回-2。</p>
</blockquote>
<p>常见的过期处理策略有两种</p>
<p>1、定时去清理过期的数据</p>
<p>2、当有请求过来的时候再判断数据是否过期</p>
<p>3、内存不足时，redis也会自动清理数据</p>
<h2 id="reis的内存淘汰策略"><a href="#reis的内存淘汰策略" class="headerlink" title="reis的内存淘汰策略"></a>reis的内存淘汰策略</h2><p>redis作为一个基于内存的数据库 ，redis再redis用于缓存的内存不足时 ，需要新写入申请额外的空间</p>
<p><strong>全局键空间选择性移除</strong></p>
<ul>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是<strong>最常用</strong>的）</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li>
</ul>
<p><strong>设置了过期时间的键空间选择性移除</strong></p>
<ul>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li>
</ul>
<h1 id="redis的线程模型"><a href="#redis的线程模型" class="headerlink" title="redis的线程模型"></a>redis的线程模型</h1><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型</p>
<ul>
<li>文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<h1 id="redis的事务"><a href="#redis的事务" class="headerlink" title="redis的事务"></a>redis的事务</h1><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<h3 id="Redis事务的概念"><a href="#Redis事务的概念" class="headerlink" title="Redis事务的概念"></a>Redis事务的概念</h3><p>Redis 事务的本质是通过MULTI、EXEC、DISCARD、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<p>总结说：<strong>redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</strong></p>
<p>因为redis是将一个事务中中的命令序列化并按顺序执行。所有有下面的特性</p>
<ol>
<li><strong>redis 不支持回滚</strong>。</li>
<li><strong>如果在一个事务中的命令出现错误，那么所有的命令都不会执行</strong>；</li>
<li><strong>如果在一个事务中出现运行错误，那么正确的命令会被执行</strong>。</li>
</ol>
<p>multi:开启一个事务，exec:执行一个事务，DISCARD:清空事务并放弃执行、watch:watch是类似于乐观锁，为事务提供check-and-set。</p>
<h3 id="事务管理（ACID）概述"><a href="#事务管理（ACID）概述" class="headerlink" title="事务管理（ACID）概述"></a>事务管理（ACID）概述</h3><p>原子性（Atomicity）<br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<p>一致性（Consistency）<br>事务前后数据的完整性必须保持一致。</p>
<p>隔离性（Isolation）<br>多个事务并发执行时，一个事务的执行不应影响其他事务的执行</p>
<p>持久性（Durability）<br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</p>
<p><strong>Redis的事务总是具有ACID中的一致性和隔离性</strong>，其他特性是不支持的。当服务器运行在<em>AOF</em>持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</p>
<h3 id="Redis事务支持隔离性吗"><a href="#Redis事务支持隔离性吗" class="headerlink" title="Redis事务支持隔离性吗"></a>Redis事务支持隔离性吗</h3><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性的</strong>。</p>
<h3 id="Redis事务保证原子性吗，支持回滚吗"><a href="#Redis事务保证原子性吗，支持回滚吗" class="headerlink" title="Redis事务保证原子性吗，支持回滚吗"></a>Redis事务保证原子性吗，支持回滚吗</h3><p>Redis中，单条命令是原子性执行的，但<strong>事务不保证原子性，且没有回滚</strong>。事务中任意命令执行失败，其余的命令仍会被执行。</p>
<h1 id="redis的集群方案"><a href="#redis的集群方案" class="headerlink" title="redis的集群方案"></a>redis的集群方案</h1><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p><img src="/2020/07/31/redis知识点总结/sentinel.png" alt></p>
<p><strong>哨兵的作用</strong></p>
<ul>
<li>集群监控：负责监控 redis master 和 slave 进程是否正常工作。</li>
<li>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li>
<li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li>
<li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li>
</ul>
<p><strong>哨兵的核心知识</strong></p>
<ul>
<li>哨兵至少需要 3 个实例，来保证自己的健壮性。</li>
<li>哨兵 + redis 主从的部署架构，是<strong>不保证数据零丢失</strong>的，只能保证 redis 集群的高可用性。</li>
<li>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li>
</ul>
<h3 id="Redis-Cluster-方案"><a href="#Redis-Cluster-方案" class="headerlink" title="Redis Cluster 方案"></a>Redis Cluster 方案</h3><p><img src="/2020/07/31/redis知识点总结/cluster.png" alt></p>
<p><strong>redis的集群模式的工作原理</strong></p>
<ol>
<li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384 个槽位</li>
<li>每份数据分片会存储在多个互为主从的多节点上</li>
<li>数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)</li>
<li>同一分片多个节点间的数据不保持一致性</li>
<li>读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点</li>
<li>扩容时时需要需要把旧节点的数据迁移一部分到新节点</li>
</ol>
<p><strong>节点通信机制</strong></p>
<p>也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，<code>gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p>
<p><strong>分布式寻址算法</strong></p>
<ul>
<li>hash 算法（大量缓存重建）</li>
<li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li>
<li>redis cluster 的 hash slot 算法</li>
</ul>
<h3 id="Redis-主从架构"><a href="#Redis-主从架构" class="headerlink" title="Redis 主从架构"></a>Redis 主从架构</h3><p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑<strong>读高并发</strong>的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的<strong>读请求全部走从节点</strong>。这样也可以很轻松实现水平扩容，<strong>支撑读高并发</strong>。</p>
<p><img src="/2020/07/31/redis知识点总结/主从.png" alt></p>
<p><strong>redis replication 的核心机制</strong></p>
<ul>
<li>redis 采用<strong>异步方式</strong>复制数据到 slave 节点，不过 redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li>
<li>一个 master node 是可以配置多个 slave node 的；</li>
<li>slave node 也可以连接其他的 slave node；</li>
<li>slave node 做复制的时候，不会 block master node 的正常工作；</li>
<li>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li>
<li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li>
</ul>
<p><strong>redis 主从复制的核心原理</strong></p>
<ol>
<li>当从库和主库建立MS关系后，会向主数据库发送SYNC命令</li>
<li>主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程)，并将期间接收到的写命令缓存起来</li>
<li>当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis</li>
<li>从Redis接收到后，会载入快照文件并且执行收到的缓存的命令</li>
<li>之后，主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致</li>
</ol>
<h1 id="redis分区"><a href="#redis分区" class="headerlink" title="redis分区"></a>redis分区</h1><p>Redis是单线程的，可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升，Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</li>
<li>同时操作多个key,则不能使用Redis事务.</li>
<li>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set）</li>
<li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件。</li>
<li>分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。</li>
</ul>
<h1 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h1><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>缓存雪崩</strong>是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p><strong>解决方案</strong></p>
<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。</li>
<li>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。</li>
</ol>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><strong>缓存穿透</strong>是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p><strong>解决方案</strong></p>
<ol>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</li>
</ol>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><strong>缓存击穿</strong>是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p><strong>解决方案</strong></p>
<ol>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁，互斥锁</li>
</ol>
<h2 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h2><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p><strong>缓存降级</strong>的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<ol>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ol>
<p>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p>
<h2 id="热点数据和冷数据"><a href="#热点数据和冷数据" class="headerlink" title="热点数据和冷数据"></a>热点数据和冷数据</h2><p>热点数据，缓存才有价值</p>
<p>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存</p>
<p>对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。</p>
<p>数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了</p>
<h1 id="简单的分布式锁代码"><a href="#简单的分布式锁代码" class="headerlink" title="简单的分布式锁代码"></a>简单的分布式锁代码</h1><p>redis本身是单线程的，所以是线程安全的，redis的事务执行是隔离的，所以可以利用redis的这些特性实现同一时刻只有一个线程能获取到对应的方法锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RedisLock &#123;</span><br><span class="line"></span><br><span class="line">    //锁名称</span><br><span class="line">    public static final String LOCK_PREFIX = &quot;REDIS_LOCK_&quot;;</span><br><span class="line">    //加锁失效时间，毫秒</span><br><span class="line">    public static final int LOCK_EXPIRE = 300; // ms</span><br><span class="line"></span><br><span class="line">    private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setRedisTemplate(StringRedisTemplate stringRedisTemplate) &#123;</span><br><span class="line">        this.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key 分布式锁加锁的方法名称</span><br><span class="line">     * @Description: 分布式锁</span><br><span class="line">     * @return: boolean</span><br><span class="line">     * @Date: 2020/8/3</span><br><span class="line">     * @Author: WXY</span><br><span class="line">     */</span><br><span class="line">    public boolean lock(String key) &#123;</span><br><span class="line">        //锁名称</span><br><span class="line">        String lock = LOCK_PREFIX + key;</span><br><span class="line">        // 利用lambda表达式 回调加锁的结果</span><br><span class="line">        return (boolean) stringRedisTemplate.execute((RedisCallback) connection -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Long threadId = Thread.currentThread().getId();</span><br><span class="line">                //当key不存在的时候新建key,value</span><br><span class="line">                Boolean acquire = connection.setNX(lock.getBytes(), String.valueOf(threadId).getBytes());</span><br><span class="line">                if (acquire) &#123;</span><br><span class="line">                    //加锁成功,并设置过期的时间</span><br><span class="line">                    stringRedisTemplate.expire(lock, LOCK_EXPIRE, TimeUnit.MILLISECONDS);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //已经有线程持有锁，自旋请求10次获取锁</span><br><span class="line">                    AtomicInteger count = new AtomicInteger(0);</span><br><span class="line">                    while (count.get() &lt; 10) &#123;</span><br><span class="line">                        byte[] value = connection.get(lock.getBytes());</span><br><span class="line">                        count.getAndIncrement();</span><br><span class="line">                        //判断锁是否还存在，不存在就开始创建新锁</span><br><span class="line">                        if (Objects.isNull(value)) &#123;</span><br><span class="line">                            //尝试创建锁</span><br><span class="line">                            acquire = connection.setNX(lock.getBytes(), String.valueOf(threadId).getBytes());</span><br><span class="line">                            if (acquire) &#123;</span><br><span class="line">                                //加锁成功,并设置过期的时间</span><br><span class="line">                                stringRedisTemplate.expire(lock, LOCK_EXPIRE, TimeUnit.MILLISECONDS);</span><br><span class="line">                                return true;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return false;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                //TODO 打印日志</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void delete(String key) &#123;</span><br><span class="line">        stringRedisTemplate.delete(LOCK_PREFIX+key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分布式锁的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/test3&quot;)</span><br><span class="line">public void test3() &#123;</span><br><span class="line">    Boolean acquire = redisLock.lock(&quot;test3&quot;);</span><br><span class="line">    if (acquire) &#123;</span><br><span class="line">        System.out.println(&quot;获取锁成功&quot;);</span><br><span class="line">        redisLock.delete(&quot;test3&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        System.out.println(&quot;获取锁失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot log4j记录日志</title>
    <url>/2019/08/22/spring-boot-log4j%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="spring-boot-集成日志"><a href="#spring-boot-集成日志" class="headerlink" title="spring boot 集成日志"></a>spring boot 集成日志</h1><p>spring boot 框架本身依赖 spring-boot-starter 中包含的就有logback,如果我们引入log4j或则log4j2的时候，为了必变jar报冲突，需要排除该包的依赖<br>我是用的是grdle构建的项目，如下配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	dependencies&#123;</span><br><span class="line">	//其他的省略</span><br><span class="line">	compile group: &apos;org.springframework.boot&apos;, name: &apos;spring-boot-starter-log4j&apos;, version: &apos;1.3.8.RELEASE&apos;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	configurations &#123;</span><br><span class="line">        all*.exclude group: &apos;org.springframework.boot&apos;, module: &apos;spring-boot-starter-logging&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在resource目录下创建log4j.properties文件,按需求配置log的输出路径和级别，这里不介绍太多<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># LOG4J配置,控制台的输出 、</span><br><span class="line"># 日志输出级别 info, appender为控制台输出stdout</span><br><span class="line">#log4j.rootCategory=INFO, stdout</span><br><span class="line"># 控制台输出</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; %5p %c&#123;1&#125;:%L - %m%n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#输出到文件里面</span><br><span class="line">log4j.rootCategory=INFO, stdout, file</span><br><span class="line"># root日志输出</span><br><span class="line">log4j.appender.file=org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">#默认的路径是在根目录下 + logs/all.log ,启动时会自动创建目录和文件，在linux下还未测试</span><br><span class="line">log4j.appender.file.file=logs/all.log</span><br><span class="line">log4j.appender.file.DatePattern=&apos;.&apos;yyyy-MM-dd</span><br><span class="line">log4j.appender.file.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; %5p %c&#123;1&#125;:%L - %m%n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># com.cloud.controller包下的日志配置</span><br><span class="line">log4j.category.com.cloud.controller=DEBUG, controller</span><br><span class="line"># com.cloud.controller下的日志输出</span><br><span class="line">log4j.appender.controller=org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">log4j.appender.controller.file=logs/my.log</span><br><span class="line">log4j.appender.controller.DatePattern=&apos;.&apos;yyyy-MM-dd</span><br><span class="line">log4j.appender.controller.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.controller.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; %5p %c&#123;1&#125;:%L ---- %m%n</span><br></pre></td></tr></table></figure></p>
<p>此时启动项目，控制台会打印出日志信息，并在设置下的日志文件路径创建日志文件，记录日志信息。</p>
<h1 id="使用AOP记录请求到日志中"><a href="#使用AOP记录请求到日志中" class="headerlink" title="使用AOP记录请求到日志中"></a>使用AOP记录请求到日志中</h1><p>AOP是Spring框架中的一个重要内容，是对既有的一个程序定义切入点，在切入的前后执行不同的内容。在项目中引入AOP的依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// aop切面 @Aspect</span><br><span class="line">       compile group: &apos;org.springframework.boot&apos;, name: &apos;spring-boot-starter-aop&apos;, version: &apos;2.1.6.RELEASE&apos;</span><br></pre></td></tr></table></figure></p>
<p>在完成了引入AOP依赖包后，不需要去做其他配置。不需要在程序主类中增加@EnableAspectJAutoProxy来启用，默认就是已启用。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实现AOP的切面主要有以下几个注解：</span><br><span class="line">使用@Aspect注解将一个java类定义为切面类</span><br><span class="line">使用@Pointcut定义一个切入点，可以是一个规则表达式，比如下例中某个package下的所有函数，也可以是一个注解等。</span><br><span class="line">根据需要在切入点不同位置的切入内容</span><br><span class="line">使用@Before在切入点开始处切入内容</span><br><span class="line">使用@After在切入点结尾处切入内容</span><br><span class="line">使用@AfterReturning在切入点return内容之后切入内容（可以用来对处理返回值做一些加工处理）</span><br><span class="line">使用@Around在切入点前后切入内容，并自己控制何时执行切入点自身的内容</span><br><span class="line">使用@AfterThrowing用来处理当切入内容部分抛出异常之后的处理逻辑</span><br><span class="line">使用@Order(i)注解来标识切面的优先级。i的值越小，优先级越高</span><br><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class WebLogAspect &#123;</span><br><span class="line"></span><br><span class="line">    private Logger logger = Logger.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">   @Pointcut(&quot;execution(public * com.cloud.controller..*.*(..))&quot;)</span><br><span class="line">    public void webLog()&#123;&#125;</span><br><span class="line"></span><br><span class="line">       @Before(&quot;webLog()&quot;)</span><br><span class="line">    public void doBefore(JoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        // 接收到请求，记录请求内容</span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line"></span><br><span class="line">        // 记录下请求内容</span><br><span class="line">        logger.info(&quot;URL : &quot; + request.getRequestURL().toString());</span><br><span class="line">        logger.info(&quot;HTTP_METHOD : &quot; + request.getMethod());</span><br><span class="line">        logger.info(&quot;IP : &quot; + request.getRemoteAddr());</span><br><span class="line">        logger.info(&quot;CLASS_METHOD : &quot; + joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName());</span><br><span class="line">        logger.info(&quot;ARGS : &quot; + Arrays.toString(joinPoint.getArgs()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;webLog()&quot;)</span><br><span class="line">    public void doAfterReturning(Object ret) throws Throwable &#123;</span><br><span class="line">        // 处理完请求，返回内容</span><br><span class="line">        logger.info(&quot;RESPONSE : &quot; + ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候启动服务，并调用controller下的服务，就会在日志中记录请求和返回的信息（实际中项目记录我们是保存在数据库的）</p>
<h1 id="日志记录存放到mongodb"><a href="#日志记录存放到mongodb" class="headerlink" title="日志记录存放到mongodb"></a>日志记录存放到mongodb</h1><p>添加mongodb的驱动依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// mongodb-driver，使用切面蒋日志文件写入Mongodb</span><br><span class="line">     compile group: &apos;org.mongodb&apos;, name: &apos;mongodb-driver&apos;, version: &apos;3.10.2&apos;</span><br></pre></td></tr></table></figure></p>
<p>创建写入的实现类<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MongoAppender extends AppenderSkeleton &#123;</span><br><span class="line">    private MongoClient mongoClient;</span><br><span class="line">    private MongoDatabase mongoDatabase;</span><br><span class="line">    private MongoCollection&lt;BasicDBObject&gt; logsCollection;</span><br><span class="line"></span><br><span class="line">    private  String connectionUrl ;</span><br><span class="line">    private  String databaseName;</span><br><span class="line">    private  String collectionName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void append(LoggingEvent loggingEvent) &#123;</span><br><span class="line">        if(mongoDatabase == null) &#123;</span><br><span class="line">            MongoClientURI connectionString = new MongoClientURI(connectionUrl);</span><br><span class="line">            mongoClient = new MongoClient(connectionString);</span><br><span class="line">            mongoDatabase = mongoClient.getDatabase(databaseName);</span><br><span class="line">            logsCollection = mongoDatabase.getCollection(collectionName, BasicDBObject.class);</span><br><span class="line">        &#125;</span><br><span class="line">        logsCollection.insertOne((BasicDBObject) loggingEvent.getMessage());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        if(mongoClient != null) &#123;</span><br><span class="line">            mongoClient.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean requiresLayout() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>修改存放到mongodb的数据类型为BasicDBObject<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Order(1)</span><br><span class="line">@Component</span><br><span class="line">public class WebLogAspect &#123;</span><br><span class="line">    private Logger logger = Logger.getLogger(&quot;mongodb&quot;);</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;execution(public * com.cloud.controller..*.*(..))&quot;)</span><br><span class="line">    public void webLog()&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Before(&quot;webLog()&quot;)</span><br><span class="line">    public void doBefore(JoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        // 获取HttpServletRequest</span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line">        // 获取要记录的日志内容</span><br><span class="line">        BasicDBObject logInfo = getBasicDBObject(request, joinPoint);</span><br><span class="line">        logger.info(logInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private BasicDBObject getBasicDBObject(HttpServletRequest request, JoinPoint joinPoint) &#123;</span><br><span class="line">        // 基本信息</span><br><span class="line">        BasicDBObject r = new BasicDBObject();</span><br><span class="line">        r.append(&quot;requestURL&quot;, request.getRequestURL().toString());</span><br><span class="line">        r.append(&quot;requestURI&quot;, request.getRequestURI());</span><br><span class="line">        r.append(&quot;queryString&quot;, request.getQueryString());</span><br><span class="line">        r.append(&quot;remoteAddr&quot;, request.getRemoteAddr());</span><br><span class="line">        r.append(&quot;remoteHost&quot;, request.getRemoteHost());</span><br><span class="line">        r.append(&quot;remotePort&quot;, request.getRemotePort());</span><br><span class="line">        r.append(&quot;localAddr&quot;, request.getLocalAddr());</span><br><span class="line">        r.append(&quot;localName&quot;, request.getLocalName());</span><br><span class="line">        r.append(&quot;method&quot;, request.getMethod());</span><br><span class="line">        r.append(&quot;headers&quot;, getHeadersInfo(request));</span><br><span class="line">        r.append(&quot;parameters&quot;, request.getParameterMap());</span><br><span class="line">        r.append(&quot;classMethod&quot;, joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName());</span><br><span class="line">        r.append(&quot;args&quot;, Arrays.toString(joinPoint.getArgs()));</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, String&gt; getHeadersInfo(HttpServletRequest request) &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        Enumeration headerNames = request.getHeaderNames();</span><br><span class="line">        while (headerNames.hasMoreElements()) &#123;</span><br><span class="line">            String key = (String) headerNames.nextElement();</span><br><span class="line">            String value = request.getHeader(key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在 log4j.properties配置mongodb的参数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mongodb输出</span><br><span class="line">log4j.logger.mongodb=INFO, mongodb</span><br><span class="line">#写入的实现类全路径</span><br><span class="line">log4j.appender.mongodb=com.cloud.config.MongoAppender</span><br><span class="line">#路径</span><br><span class="line">log4j.appender.mongodb.connectionUrl=mongodb://47.102.99.95:27017</span><br><span class="line">#数据库名称</span><br><span class="line">log4j.appender.mongodb.databaseName=cloud</span><br><span class="line">#mongodb中集合名称</span><br><span class="line">log4j.appender.mongodb.collectionName=logs_request</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>log4j</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot 发送邮件</title>
    <url>/2019/04/20/spring-boort-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="使用springboot-发送邮件功能"><a href="#使用springboot-发送邮件功能" class="headerlink" title="使用springboot 发送邮件功能"></a>使用springboot 发送邮件功能</h1><p>项目结构<br><img src="/2019/04/20/spring-boort-一/construct.png" alt><br> 首先在build.gradle中加入邮件依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile group: &apos;org.springframework.boot&apos;, name: &apos;spring-boot-starter-mail&apos;, version: &apos;2.1.3.RELEASE&apos;</span><br></pre></td></tr></table></figure></p>
<p> 然后在application.properties中添加邮箱的信息，我用的是QQ邮箱，在使用QQ邮箱时要先设置，<br> 进入邮箱-&gt; 设置 -&gt;账户-&gt;POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务-&gt; 开启POP3/SMTP服务<br><img src="/2019/04/20/spring-boort-一/邮箱验证密码.png" alt><br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line">#邮箱账户</span><br><span class="line">spring.mail.username=用户名</span><br><span class="line">#这里的密码就是开通SMTP服务后上图的密码</span><br><span class="line">spring.mail.password=密码</span><br><span class="line">spring.mail.properties.mail.smtp.auth=true</span><br><span class="line">spring.mail.properties.mail.smtp.starttls.enable=true</span><br><span class="line">spring.mail.properties.mail.smtp.starttls.required=true</span><br></pre></td></tr></table></figure></p>
<p> 会根据配置文件中的内容去创建JavaMailSender实例，因此我们可以直接在需要使用的地方直接@Autowired来引入邮件发送对象。</p>
<h2 id="简单文本邮件发送"><a href="#简单文本邮件发送" class="headerlink" title="简单文本邮件发送"></a>简单文本邮件发送</h2> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class MailSendController &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据配置文件创建发送邮件的实例</span><br><span class="line">     */</span><br><span class="line">    @Autowired</span><br><span class="line">    private JavaMailSender javaMailSender;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private VelocityEngine velocityEngine;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 简单文字邮件发送</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/sendEmail&quot;)</span><br><span class="line">    public OperateResult sendEmail()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //邮件内容</span><br><span class="line">            SimpleMailMessage message = new SimpleMailMessage();</span><br><span class="line">            message.setFrom( &quot;from&quot;);</span><br><span class="line">            message.setTo( &quot;to&quot; );</span><br><span class="line">            message.setSubject( &quot;主题：简单邮件&quot; );</span><br><span class="line">            message.setText( &quot;测试邮件内容&quot; );</span><br><span class="line">            javaMailSender.send( message );</span><br><span class="line">            return OperateResult.operationSuccess( &quot;发送邮件成功&quot; );</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return OperateResult.operationFailure( e.getMessage() );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="包含附件的邮件发送"><a href="#包含附件的邮件发送" class="headerlink" title="包含附件的邮件发送"></a>包含附件的邮件发送</h2><p> 实际过程中，我们很可能会发送附件给对方<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 发送带附件的邮件</span><br><span class="line">   */</span><br><span class="line">  @PostMapping(&quot;/sendEmailFile&quot;)</span><br><span class="line">  public OperateResult sendEmailFile()&#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          //邮件内容</span><br><span class="line">          MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">          MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);</span><br><span class="line">          helper.setFrom( &quot;from&quot; );</span><br><span class="line">          helper.setTo( &quot;to&quot; );</span><br><span class="line">          helper.setSubject( &quot;主题：附件邮件&quot; );</span><br><span class="line">          helper.setText( &quot;附件邮件内容&quot; );</span><br><span class="line">	//附件我放在了resources下</span><br><span class="line">          FileSystemResource file = new FileSystemResource(new File(Thread.currentThread().getContextClassLoader().getResource(&quot;test.jpg&quot;).getFile()));</span><br><span class="line">          helper.addAttachment(&quot;附件-1.jpg&quot;, file);</span><br><span class="line">          helper.addAttachment(&quot;附件-2.jpg&quot;, file);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          javaMailSender.send( mimeMessage );</span><br><span class="line">          return OperateResult.operationSuccess( &quot;发送邮件成功&quot; );</span><br><span class="line">      &#125;catch (Exception e)&#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          return OperateResult.operationFailure( e.getMessage() );</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="潜入静态资源的邮件"><a href="#潜入静态资源的邮件" class="headerlink" title="潜入静态资源的邮件"></a>潜入静态资源的邮件</h2> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/sendEmailQuiet&quot;)</span><br><span class="line"> public OperateResult sendEmailQuiet()&#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         //邮件内容</span><br><span class="line">         MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">         MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);</span><br><span class="line">         helper.setFrom( &quot;from&quot; );</span><br><span class="line">         helper.setTo( &quot;to&quot; );</span><br><span class="line">         helper.setSubject( &quot;主题：嵌入静态资源邮件&quot; );</span><br><span class="line">         helper.setText( &quot;嵌入静态资源邮件邮件内容&quot; );</span><br><span class="line">         helper.setText(&quot;&lt;html&gt;&lt;body&gt;&lt;img src=\&quot;cid:test\&quot; &gt;&lt;/body&gt;&lt;/html&gt;&quot;, true);</span><br><span class="line"></span><br><span class="line">         FileSystemResource file = new FileSystemResource(new File(Thread.currentThread().getContextClassLoader().getResource(&quot;test.jpg&quot;).getFile()));</span><br><span class="line">         helper.addInline(&quot;test&quot;, file);</span><br><span class="line">         javaMailSender.send( mimeMessage );</span><br><span class="line">         return OperateResult.operationSuccess( &quot;发送邮件成功&quot; );</span><br><span class="line">     &#125;catch (Exception e)&#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">         return OperateResult.operationFailure( e.getMessage() );</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="发送模板邮件"><a href="#发送模板邮件" class="headerlink" title="发送模板邮件"></a>发送模板邮件</h2><p> 项目中引入模板的依赖<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//        邮件嵌入静态资源</span><br><span class="line">       compile group: &apos;org.springframework.boot&apos;, name: &apos;spring-boot-starter-velocity&apos;, version: &apos;1.4.7.RELEASE&apos;</span><br></pre></td></tr></table></figure></p>
<p> 在路径resources/templates/下，创建一个模板页面template.vm，内容如下<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h3&gt;你好， $&#123;username&#125;, 这是一封模板邮件!&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p> 发送模板的邮件<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/sendEmailQuiet&quot;)</span><br><span class="line">   public OperateResult sendEmailQuiet()&#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           //邮件内容</span><br><span class="line">           MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">           MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);</span><br><span class="line">           helper.setFrom( &quot;from&quot; );</span><br><span class="line">           helper.setTo( &quot;to&quot; );</span><br><span class="line">           helper.setSubject( &quot;主题：嵌入静态资源邮件&quot; );</span><br><span class="line">           helper.setText( &quot;嵌入静态资源邮件邮件内容&quot; );</span><br><span class="line">           helper.setText(&quot;&lt;html&gt;&lt;body&gt;&lt;img src=\&quot;cid:test\&quot; &gt;&lt;/body&gt;&lt;/html&gt;&quot;, true);</span><br><span class="line"></span><br><span class="line">           FileSystemResource file = new FileSystemResource(new File(Thread.currentThread().getContextClassLoader().getResource(&quot;test.jpg&quot;).getFile()));</span><br><span class="line">           helper.addInline(&quot;test&quot;, file);</span><br><span class="line">           javaMailSender.send( mimeMessage );</span><br><span class="line">           return OperateResult.operationSuccess( &quot;发送邮件成功&quot; );</span><br><span class="line">       &#125;catch (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           return OperateResult.operationFailure( e.getMessage() );</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">``</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot flyway管理数据库版本</title>
    <url>/2019/08/18/spring-boot-flyway%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="使用flyway管理数据库版本"><a href="#使用flyway管理数据库版本" class="headerlink" title="使用flyway管理数据库版本"></a>使用flyway管理数据库版本</h1><p>Flyway是一个简单开源数据库版本控制器（约定大于配置），主要提供migrate、clean、info、validate、baseline、repair等命令。它支持SQL（PL/SQL、T-SQL）方式和Java方式，支持命令行客户端等，还提供一系列的插件支持（Maven、Gradle、SBT、ANT等）。<br>更多用法详情，flyway的官方网站：<a href="https://flywaydb.org/，" target="_blank" rel="noopener">https://flywaydb.org/，</a><br>因为我们项目是用的flyway来管理数据库版本的，这样子每次更新数据库设计的时候就能对比出表之间的变化，然后我也研究了下spring boot 和flyway的用法。我创建用的项目是gradle的多模块。如果你使用的是maven也可以当作参考<br>第一步当然是引入fayway的依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// flyway</span><br><span class="line">compile group: &apos;org.flywaydb&apos;, name: &apos;flyway-core&apos;, version: &apos;4.1.2</span><br></pre></td></tr></table></figure></p>
<p>flyway的默认读取路径是resource的 db/migration,若果你的路径不一样，那就要在application.properties中写入 flyway.locations指明你的文件路径,在db/migration文件内创建文件 V1__Base_version.sql<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS user ;</span><br><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;,</span><br><span class="line">  `name` varchar(20) NOT NULL COMMENT &apos;姓名&apos;,</span><br><span class="line">  `age` int(5) DEFAULT NULL COMMENT &apos;年龄&apos;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure></p>
<p>这个时候启动Application就能发现数据库中自动创建了实体表，如果你的数据中已经存在了表，只要加上flyway.baselineOnMigrate=true加上这句就阔以喽。<br>下面是flyway的一些常用配置，可以根据具体使用配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 设定 flyway 属性</span><br><span class="line">flyway.enabled = true</span><br><span class="line"># 启用或禁用 flyway</span><br><span class="line">flyway.locations =classpath:/db.migration</span><br><span class="line"># 设定 SQL 脚本的目录,多个路径使用逗号分隔, 比如取值为 classpath:db/migration,filesystem:/sql-migrations</span><br><span class="line">flyway.baselineOnMigrate=true</span><br><span class="line"># 如果指定 schema 包含了其他表,但没有 flyway schema history 表的话, 在执行 flyway migrate 命令之前, 必须先执行 flyway baseline 命令.</span><br><span class="line"># 设置 spring.flyway.baseline-on-migrate 为 true 后, flyway 将在需要 baseline 的时候, 自动执行一次 baseline.</span><br><span class="line">flyway.baselineVersion=1</span><br><span class="line"># 指定 baseline 的版本号,缺省值为 1, 低于该版本号的 SQL 文件, migrate 的时候被忽略.</span><br><span class="line">#spring.flyway.encoding=</span><br><span class="line"># Encoding of SQL migrations (default: UTF-8)</span><br><span class="line">flyway.table=flyway_schema_history_myapp</span><br><span class="line"># 设定 flyway 的 metadata 表名, 缺省为 flyway_schema_history</span><br><span class="line">flyway.outOfOrder=true</span><br><span class="line"># 开发环境最好开启 outOfOrder, 生产环境关闭 outOfOrder .</span><br><span class="line">#spring.flyway.schemas=</span><br><span class="line">需要 flyway 管控的 schema list, 缺省的话, 使用的时 dbsource.connection直连上的那个 schema, 可以指定多个schema, 但仅会在第一个schema下建立 metadata 表, 也仅在第一个schema应用migration sql 脚本. 但flyway Clean 命令会依次在这些schema下都执行一遍.</span><br></pre></td></tr></table></figure></p>
<h1 id="第二种使用flyway的方法"><a href="#第二种使用flyway的方法" class="headerlink" title="第二种使用flyway的方法"></a>第二种使用flyway的方法</h1><p>项目结构如下图<br><img src="/2019/08/18/spring-boot-flyway管理数据库版本/struct.png" alt><br>flyway在gradle中的使用。官方文档中有实例，这里我贴出我的代码,首先flyway的依赖和上面相同，然后再再根目录下创建gradle.properties文件，再里面配置数据源信息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//gradle.properties内</span><br><span class="line"># ####################### flyway ##############################</span><br><span class="line">flyway_driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">flyway_url=jdbc:mysql://localhost:3306/weixy?useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">flyway_user=root</span><br><span class="line">flyway_password=123456</span><br></pre></td></tr></table></figure></p>
<p>然后在entity的模块的build中添加<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: &apos;org.springframework.boot&apos;</span><br><span class="line">apply plugin: &apos;org.flywaydb.flyway&apos;</span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        //使用的仓库优先级</span><br><span class="line">        mavenLocal()</span><br><span class="line">        maven &#123; url &quot;http://maven.aliyun.com/nexus/content/groups/public&quot; &#125;</span><br><span class="line">        maven &#123; url &quot;http://repo.spring.io/snapshot&quot; &#125;</span><br><span class="line">        maven &#123; url &quot;http://repo.spring.io/milestone&quot; &#125;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(group: &apos;org.flywaydb&apos;, name: &apos;flyway-gradle-plugin&apos;, version: &quot;4.1.2&quot;)</span><br><span class="line">        classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:1.4.5.RELEASE&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">flyway&#123;</span><br><span class="line">    driver = &quot;$&#123;flyway_driver&#125;&quot;</span><br><span class="line">    url = &quot;$flyway_url&quot;</span><br><span class="line">    user = &quot;$flyway_user&quot;</span><br><span class="line">    password = &quot;$flyway_password&quot;</span><br><span class="line">    //flyway发布版本记录的表名称</span><br><span class="line">    table = &apos;flyway_version&apos;</span><br><span class="line">    locations =&apos;db/migration&apos;</span><br><span class="line">//    locations = &apos;db/migrations&apos;</span><br><span class="line">    baselineOnMigrate=true</span><br><span class="line">    //</span><br><span class="line">    //sqlMigrationPrefix = &apos;V&apos;</span><br><span class="line">    // 禁止flywayClean，在生产环境中非常重要</span><br><span class="line">    cleanDisabled = false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候刷新gradle ,点击flyway下的<br><img src="/2019/08/18/spring-boot-flyway管理数据库版本/gradle.png" alt></p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>flyway</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot rabbit</title>
    <url>/2019/08/25/spring-boot-rabbit/</url>
    <content><![CDATA[<h1 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h1><p>消息队列（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message而已。主要用于不同进程Process/线程Thread之间通信。<br>消息队列的好处：<br>不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个。<br>不同进程（process）之间传递消息时，为了实现标准化，将消息的格式规范化了，并且，某一个进程接受的消息太多，一下子无法处理完，并且也有先后顺序，必须对收到的消息进行排队，因此诞生了事实上的消息队列。<br>MQ框架非常之多，比较流行的有RabbitMq、ActiveMq、ZeroMq、kafka，以及阿里开源的RocketMQ。</p>
<h1 id="RabbitMQ的安装"><a href="#RabbitMQ的安装" class="headerlink" title="RabbitMQ的安装"></a>RabbitMQ的安装</h1><p>linux（centos7.6）下的安装，因为是erlang语言写的，所以首先需要安装erlang,我的习惯是创建/usr/local/erlang,/usr/local/rabbitMQ两个文件夹。<br>首先是安装erlang<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//切换目录到/usr/local/erlang</span><br><span class="line">cd  /usr/local/erlang</span><br><span class="line">//下载</span><br><span class="line">wget http://www.rabbitmq.com/releases/erlang/erlang-19.0.4-1.el7.centos.x86_64.rpm</span><br><span class="line">//安装</span><br><span class="line">rpm -ivh erlang-19.0.4-1.el7.centos.x86_64.rpm</span><br><span class="line">//查看erlang版本</span><br><span class="line">erl</span><br></pre></td></tr></table></figure></p>
<p>出现下面的图样，说明安装成功了<br><img src="/2019/08/25/spring-boot-rabbit/erlang.png" alt><br>接着就是安装rabbitMQ,需要注意的是erlang 和 rabbitMQ的版本关系，最好取官网上查询对应的安装版本。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//切换目录到rabbitMQ</span><br><span class="line">cd /usr/local/rabbitMq</span><br><span class="line">//下载</span><br><span class="line">wget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.15/rabbitmq-server-3.6.15-1.el7.noarch.rpm</span><br><span class="line">//安装</span><br><span class="line">rpm -ivh rabbitmq-server-3.6.15-1.el7.noarch.rpm</span><br><span class="line">//检查rabbitMq是否安装成功</span><br><span class="line">rpm -qa|grep rabbitmq</span><br></pre></td></tr></table></figure></p>
<p>同样输入rpm -qa|grep rabbitmq会出现下面的图片<br><img src="/2019/08/25/spring-boot-rabbit/rabbitmq.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//启动rabbitmq</span><br><span class="line">systemctl start rabbitmq-server</span><br><span class="line">//关闭rabbitmq</span><br><span class="line">systemctl stop rabbitmq-server</span><br><span class="line">//查看运行状态</span><br><span class="line">systemctl status rabbitmq-server</span><br><span class="line">//启动网页插件</span><br><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>
<p>但是这个时候还需要开通服务器的端口，5672（服务端口）和15672（网页插件）<br>出现绿色running说明运行起来了<br><img src="/2019/08/25/spring-boot-rabbit/rabbitmqstatus.png" alt><br>但是因为默认的rabbirmq.conf的默认配置是# loopback_users.guest = true，不能在本机外登陆guest账号，(也能改成false,就可以了)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//列出角色</span><br><span class="line">rabbitmqctl list_users</span><br><span class="line">//新增角色</span><br><span class="line">rabbitmqctl add_user wxy wxy</span><br><span class="line">//添加权限</span><br><span class="line">rabbitmqctl set_permissions -p / wxy &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line">//修改用户的角色(我设置的是超级管理员，还有监控者，管理者等，了解更多去官网吧)</span><br><span class="line">rabbitmqctl set_user_tags wxy administrator</span><br><span class="line">//删除用户</span><br><span class="line">rabbitmqctl delete_user Username</span><br><span class="line">//修改密码</span><br><span class="line">rabbitmqctl change_password Username Newpassword</span><br></pre></td></tr></table></figure></p>
<h1 id="rabbitmq的五种队列"><a href="#rabbitmq的五种队列" class="headerlink" title="rabbitmq的五种队列"></a>rabbitmq的五种队列</h1><p>创建一个虚拟的virtualhost,给用户这个分配这个虚拟服务的权限<br><img src="/2019/08/25/spring-boot-rabbit/virtualhost.png" alt><br><img src="/2019/08/25/spring-boot-rabbit/hostpermission.png" alt><br><img src="/2019/08/25/spring-boot-rabbit/view.png" alt><br><img src="/2019/08/25/spring-boot-rabbit/view2.png" alt></p>
<h2 id="简单队列"><a href="#简单队列" class="headerlink" title="简单队列"></a>简单队列</h2><p>创建一个简单的springboot服务，向消息对类中发送一段消息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//在build.gralde中加入依赖</span><br><span class="line">//amqp-client</span><br><span class="line">compile group: &apos;com.rabbitmq&apos;, name: &apos;amqp-client&apos;, version: &apos;3.4.1&apos;</span><br><span class="line"></span><br><span class="line">//创建连接RabbitMQ</span><br><span class="line">public class ConnectionUtil &#123;</span><br><span class="line">    public static Connection getConnection() throws Exception &#123;</span><br><span class="line">        //定义连接工厂</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        //设置服务地址</span><br><span class="line">        factory.setHost(&quot;localhost&quot;);</span><br><span class="line">        //端口</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        //设置账号信息，用户名、密码、vhost</span><br><span class="line">        factory.setVirtualHost(&quot;testhost&quot;);</span><br><span class="line">        factory.setUsername(&quot;wxy&quot;);</span><br><span class="line">        factory.setPassword(&quot;wxy&quot;);</span><br><span class="line">        // 通过工程获取连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        return connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编写测试方法发送消息到队列中</span><br><span class="line">public class Send &#123;</span><br><span class="line">    private final static String QUEUE_NAME = &quot;q_test_01&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接以及mq通道</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        // 从连接中创建通道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line"></span><br><span class="line">        // 消息内容</span><br><span class="line">        String message = &quot;Hello World!&quot;;</span><br><span class="line">        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());</span><br><span class="line">        System.out.println(&quot; [x] Sent &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line">        //关闭通道和连接</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编辑测试方法接收消息</span><br><span class="line">public class Recive &#123;</span><br><span class="line">    private final static String QUEUE_NAME = &quot;q_test_01&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接以及mq通道</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        // 从连接中创建通道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        // 声明队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line">        // 定义队列的消费者</span><br><span class="line">        QueueingConsumer consumer = new QueueingConsumer(channel);</span><br><span class="line">        // 监听队列</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, true, consumer);</span><br><span class="line">        // 获取消息</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = new String(delivery.getBody());</span><br><span class="line">            System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行程序后打开rabbitmq的web页面，可以发现页面上如下图所示<br><img src="/2019/08/25/spring-boot-rabbit/simplesend.png" alt></p>
<h2 id="work模式"><a href="#work模式" class="headerlink" title="work模式"></a>work模式</h2><p>编辑消息发送者，队列中发送一百个消息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class WorkSend &#123;</span><br><span class="line">    private final static String QUEUE_NAME = &quot;test_queue_work&quot;;</span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接以及mq通道</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            // 消息内容</span><br><span class="line">            String message = &quot;&quot; + i;</span><br><span class="line">            channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());</span><br><span class="line">            System.out.println(&quot; [x] Sent &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(i * 10);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在编辑两个消费者来接受消息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Recv1 &#123;</span><br><span class="line">    private final static String QUEUE_NAME = &quot;test_queue_work&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        // 获取到连接以及mq通道</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line"></span><br><span class="line">        // 同一时刻服务器只会发一条消息给消费者</span><br><span class="line">        channel.basicQos(0);</span><br><span class="line"></span><br><span class="line">        // 定义队列的消费者</span><br><span class="line">        QueueingConsumer consumer = new QueueingConsumer(channel);</span><br><span class="line">        // 监听队列，false表示手动返回完成状态，true表示自动</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, true, consumer);</span><br><span class="line"></span><br><span class="line">        // 获取消息</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = new String(delivery.getBody());</span><br><span class="line">            System.out.println(&quot; [recv1] Received &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line">            //休眠</span><br><span class="line">            Thread.sleep(10);</span><br><span class="line">            // 返回确认状态，注释掉表示使用自动确认模式</span><br><span class="line">            //channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Recv2 &#123;</span><br><span class="line">    private final static String QUEUE_NAME = &quot;test_queue_work&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        // 获取到连接以及mq通道</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line"></span><br><span class="line">        // 同一时刻服务器只会发一条消息给消费者</span><br><span class="line">        channel.basicQos(0);</span><br><span class="line"></span><br><span class="line">        // 定义队列的消费者</span><br><span class="line">        QueueingConsumer consumer = new QueueingConsumer(channel);</span><br><span class="line">        // 监听队列，false表示手动返回完成状态，true表示自动</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, true, consumer);</span><br><span class="line"></span><br><span class="line">        // 获取消息</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = new String(delivery.getBody());</span><br><span class="line">            System.out.println(&quot; [recv2] Received &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line">            // 休眠1秒</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            //下面这行注释掉表示使用自动确认模式</span><br><span class="line">            //channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试的结果：<br>消费者1和消费者2获取到的消息内容是不同的，同一个消息只能被一个消费者获取。一个是消费奇数号消息，一个是偶数。<br>其实，这样是不合理的，因为消费者1线程停顿的时间短。应该是消费者1要比消费者2获取到的消息多才对。RabbitMQ 默认将消息顺序发送给下一个消费者，这样，每个消费者会得到相同数量的消息。即轮询（round-robin）分发消息。<br>怎样才能做到按照每个消费者的能力分配消息呢？联合使用 Qos 和 Acknowledge 就可以做到。<br>basicQos 方法设置了当前信道最大预获取（prefetch）消息数量为1。消息从队列异步推送给消费者，消费者的 ack 也是异步发送给队列，从队列的视角去看，总是会有一批消息已推送但尚未获得 ack 确认，Qos 的 prefetchCount 参数就是用来限制这批未确认消息数量的。设为1时，队列只有在收到消费者发回的上一条消息 ack 确认后，才会向该消费者发送下一条消息。prefetchCount 的默认值为0，即没有限制，队列会将所有消息尽快发给消费者。<br>两个概念：<br>轮询分发 ：使用任务队列的优点之一就是可以轻易的并行工作。如果我们积压了好多工作，我们可以通过增加工作者（消费者）来解决这一问题，使得系统的伸缩性更加容易。在默认情况下，RabbitMQ将逐个发送消息到在序列中的下一个消费者(而不考虑每个任务的时长等等，且是提前一次性分配，并非一个一个分配)。平均每个消费者获得相同数量的消息。这种方式分发消息机制称为Round-Robin（轮询）<br>公平分发 ：虽然上面的分配法方式也还行，但是有个问题就是：比如：现在有2个消费者，所有的奇数的消息都是繁忙的，而偶数则是轻松的。按照轮询的方式，奇数的任务交给了第一个消费者，所以一直在忙个不停。偶数的任务交给另一个消费者，则立即完成任务，然后闲得不行。而RabbitMQ则是不了解这些的。这是因为当消息进入队列，RabbitMQ就会分派消息。它不看消费者为应答的数目，只是盲目的将消息发给轮询指定的消费者。<br>为了解决这个问题，我们使用basicQos( prefetchCount = 1)方法，来限制RabbitMQ只发不超过1条的消息给同一个消费者。当消息处理完毕后，有了反馈，才会进行第二次发送。还有一点需要注意，使用公平分发，必须关闭自动应答，改为手动应答。<br>设置,只需要改动三个地方<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 同一时刻服务器只会发一条消息给消费者,默认是0，就算轮询的模式</span><br><span class="line">channel.basicQos(1);</span><br><span class="line">// 监听队列，false表示手动返回完成状态，true表示自动确认	</span><br><span class="line">//只要消息从队列中获取，无论消费者获取到消息后是否成功消息，都认为是消息已经成功消费。</span><br><span class="line">channel.basicConsume(QUEUE_NAME, false, consumer);</span><br><span class="line">//开启手动确认</span><br><span class="line">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);</span><br></pre></td></tr></table></figure></p>
<h2 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h2><p>创建消息生产这，并把消息把固定到交换机上,直接放代码吧<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Send &#123;</span><br><span class="line">    private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接以及mq通道</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明exchange</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);</span><br><span class="line"></span><br><span class="line">        // 消息内容</span><br><span class="line">        String message = &quot;Hello World!&quot;;</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes());</span><br><span class="line">        System.out.println(&quot; [x] Sent &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候再创建两个消息队列，且都绑定在交换机上,如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Recv1 &#123;</span><br><span class="line">    private final static String QUEUE_NAME = &quot;test_queue_work1&quot;; //另一个Recv2写成test_queue_work2</span><br><span class="line">    private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;;</span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接以及mq通道</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        // 声明队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line">        // 绑定队列到交换机</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);</span><br><span class="line">        // 同一时刻服务器只会发一条消息给消费者</span><br><span class="line">        channel.basicQos(1);</span><br><span class="line">        // 定义队列的消费者</span><br><span class="line">        QueueingConsumer consumer = new QueueingConsumer(channel);</span><br><span class="line">        // 监听队列，手动返回完成</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, false, consumer);</span><br><span class="line">        // 获取消息</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = new String(delivery.getBody());</span><br><span class="line">            System.out.println(&quot; [Recv1] Received &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line">            Thread.sleep(10);</span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候启动sender和Recv1、Recv2,就能看见两个消息队列的监听同时打印出 “hello world!”</p>
<h2 id="主题模式（路由模式）"><a href="#主题模式（路由模式）" class="headerlink" title="主题模式（路由模式）"></a>主题模式（路由模式）</h2><p>主题模式与路由模式基本相同，只是再发送消息和接收消息添加了routeKey的规则。在交换机中发送消息到对应的队列中，只有满足路径规则的队列才能接收到数据。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Sender &#123;</span><br><span class="line">    public static final String EXCHANGE_NAME = &quot;test_exchange_topic&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        //获取连接通道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        //声明交换机名称  和  类型</span><br><span class="line">        channel.exchangeDeclare( EXCHANGE_NAME,&quot;topic&quot; );</span><br><span class="line"></span><br><span class="line">        String message = &quot;hello rabbitmq topic theme&quot;;</span><br><span class="line">        channel.basicPublish( EXCHANGE_NAME,&quot;routeKey.1&quot;,null,message.getBytes());</span><br><span class="line">        System.out.println(&quot; topic sender send :[&quot;+message+&quot;]&quot;);</span><br><span class="line">        //关闭通道和连接</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Recv1 &#123;</span><br><span class="line">    private final static String QUEUE_NAME = &quot;test_queue_topic_work_1&quot;;</span><br><span class="line"></span><br><span class="line">    private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        // 获取到连接以及mq通道</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line"></span><br><span class="line">        // 绑定队列到交换机</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;routeKey.*&quot;);</span><br><span class="line"></span><br><span class="line">        // 同一时刻服务器只会发一条消息给消费者</span><br><span class="line">        channel.basicQos(1);</span><br><span class="line"></span><br><span class="line">        // 定义队列的消费者</span><br><span class="line">        QueueingConsumer consumer = new QueueingConsumer(channel);</span><br><span class="line">        // 监听队列，手动返回完成</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, false, consumer);</span><br><span class="line"></span><br><span class="line">        // 获取消息</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = new String(delivery.getBody());</span><br><span class="line">            System.out.println(&quot; [topic Receiver 1] Received &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line">            Thread.sleep(10);</span><br><span class="line"></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Recv2 &#123;</span><br><span class="line">    private final static String QUEUE_NAME = &quot;test_queue_topic_work_2&quot;;</span><br><span class="line"></span><br><span class="line">    private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        // 获取到连接以及mq通道</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line"></span><br><span class="line">        // 绑定队列到交换机</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;*.*&quot;);</span><br><span class="line"></span><br><span class="line">        // 同一时刻服务器只会发一条消息给消费者</span><br><span class="line">        channel.basicQos(1);</span><br><span class="line"></span><br><span class="line">        // 定义队列的消费者</span><br><span class="line">        QueueingConsumer consumer = new QueueingConsumer(channel);</span><br><span class="line">        // 监听队列，手动返回完成</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, false, consumer);</span><br><span class="line"></span><br><span class="line">        // 获取消息</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = new String(delivery.getBody());</span><br><span class="line">            System.out.println(&quot; [topic Receiver 2] Received &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class="line">            Thread.sleep(10);</span><br><span class="line"></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, “routeKey.<em>“);表示得过滤规则，满足 routeKey.</em>得key得队列才会接收到，#表示得是一个或多个字符，而*表示得是一个字符</p>
<h1 id="spring-boot-使用rabbitmq"><a href="#spring-boot-使用rabbitmq" class="headerlink" title="spring boot 使用rabbitmq"></a>spring boot 使用rabbitmq</h1><p>新建一个spring boot项目，引入依赖包和配置端口和上面一样<br>创建redis的配置文件，这里直接贴上代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class TopicRabbitConfig &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 简单模式下的消息队列配置，默认是按劳分配得队列获取</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue helloQueue() &#123;</span><br><span class="line">        return new Queue( &quot;hello&quot; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//---------------------分割线   主题模式--------------------------------//</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 定义两个消息队列</span><br><span class="line">     */</span><br><span class="line">    private final static String message = &quot;q_topic_message&quot;;</span><br><span class="line">    private final static String messages = &quot;q_topic_messages&quot;;</span><br><span class="line">    private final static String exchange = &quot;topic_exchange&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue queueMessage() &#123;</span><br><span class="line">        return new Queue( TopicRabbitConfig.message );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue queueMessages() &#123;</span><br><span class="line">        return new Queue( TopicRabbitConfig.messages );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 声明一个Topic类型的交换机</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    TopicExchange exchange() &#123;</span><br><span class="line">        return new TopicExchange( exchange );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * queueMessage绑定到交换机上，并设置匹配得规则</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeMessage(Queue queueMessage,TopicExchange exchange) &#123;</span><br><span class="line">        return BindingBuilder.bind( queueMessage ).to( exchange ).with( &quot;topic.message&quot; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * queueMessage绑定到交换机上，并设置匹配得规则</span><br><span class="line">     * - 是匹配一个或多个词   *只匹配一个</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeMessages(Queue queueMessages,TopicExchange exchange) &#123;</span><br><span class="line">        return BindingBuilder.bind( queueMessages ).to( exchange ).with( &quot;topic.-&quot; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //------------------------分割线     订阅模式----------------------------------//</span><br><span class="line"></span><br><span class="line">    //订阅模式下得配置与主题模式基本相同，区别是不添加匹配规则</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue aMessage() &#123;</span><br><span class="line">        return new Queue( &quot;q_fanout_A&quot; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue bMessage() &#123;</span><br><span class="line">        return new Queue( &quot;q_fanout_B&quot; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue cMessage() &#123;</span><br><span class="line">        return new Queue( &quot;q_fanout_C&quot; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 定义交换机</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    FanoutExchange fanoutExchange() &#123;</span><br><span class="line">        return new FanoutExchange( &quot;fanout_exchange&quot; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将交换机和队列绑定</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeA(Queue aMessage,FanoutExchange fanoutExchange) &#123;</span><br><span class="line">        return BindingBuilder.bind( aMessage ).to( fanoutExchange );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeB(Queue bMessage,FanoutExchange fanoutExchange) &#123;</span><br><span class="line">        return BindingBuilder.bind( bMessage ).to( fanoutExchange );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeC(Queue cMessage,FanoutExchange fanoutExchange) &#123;</span><br><span class="line">        return BindingBuilder.bind( cMessage ).to( fanoutExchange );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面创建不同的类型的消息发送和消息接收者<br>消费者默认按劳分配，不是平均分配,主要的模式配置其实都在配置类中完成。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Sender &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    public void send() &#123;</span><br><span class="line">        String context = &quot;hello &quot; + new Date();</span><br><span class="line">        System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">        // 设置  routeKey,简单模式下，这个就是队列名</span><br><span class="line">        this.rabbitTemplate.convertAndSend(&quot;hello&quot;, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Component</span><br><span class="line">@RabbitListener(queues = &quot;hello&quot;)</span><br><span class="line">public class Receiver1 &#123;</span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public void process(String hello) &#123;</span><br><span class="line">        System.out.println(&quot;Receiver : &quot; + hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>rabbit</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot redis</title>
    <url>/2019/08/10/spring-boot-redis/</url>
    <content><![CDATA[<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;Springboot整合Redis有两种方式，分别是Jedis和RedisTemplate,Jedis是Redis官方推荐的面向Java的操作Redis的客户端，而RedisTemplate是SpringDataRedis中对JedisApi的高度封装。其实在Springboot的官网上我们也能看到，官方现在推荐的是SpringDataRedis形式，相对于Jedis来说可以方便地更换Redis的Java客户端，其比Jedis多了自动管理连接池的特性，方便与其他Spring框架进行搭配使用如：SpringCache。<br>我的spring boot 版本是1.4.5，所以和spring boot 2.x可能会有些不一样</p>
<h1 id="spring-boot-1-x-引入redis连接"><a href="#spring-boot-1-x-引入redis连接" class="headerlink" title="spring boot 1.x 引入redis连接"></a>spring boot 1.x 引入redis连接</h1><p>首先引入redis的依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//redis</span><br><span class="line">      compile group: &apos;org.springframework.data&apos;, name: &apos;spring-data-redis&apos;, version: &apos;1.7.2.RELEASE&apos;</span><br><span class="line">      // jedis</span><br><span class="line">      compile group: &apos;redis.clients&apos;, name: &apos;jedis&apos;, version: &apos;2.9.0&apos;</span><br></pre></td></tr></table></figure></p>
<p>在application.properties中配置redis的设置和链接地址<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># REDIS (RedisProperties)</span><br><span class="line"># Redis数据库索引（默认为0）</span><br><span class="line">spring.redis.database=0</span><br><span class="line"># Redis服务器地址</span><br><span class="line">spring.redis.host=xx.xxx.xx.xx</span><br><span class="line"># Redis服务器连接端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line">#客户端超时时间单位是毫秒 默认是2000</span><br><span class="line">spring.redis.timeout=10000</span><br><span class="line">#最大空闲数</span><br><span class="line">spring.redis.maxIdle=300</span><br><span class="line">#连接池的最大数据库连接数。设为0表示无限制,如果是jedis 2.4以后用redis.maxTotal</span><br><span class="line">#redis.maxActive=600</span><br><span class="line">#控制一个pool可分配多少个jedis实例,用来替换上面的redis.maxActive,如果是jedis 2.4以后用该属性</span><br><span class="line">spring.redis.maxTotal=1000</span><br><span class="line">#最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。</span><br><span class="line">spring.redis.maxWaitMillis=1000</span><br><span class="line">#连接的最小空闲时间 默认1800000毫秒(30分钟)</span><br><span class="line">spring.redis.minEvictableIdleTimeMillis=300000</span><br><span class="line">#每次释放连接的最大数目,默认3</span><br><span class="line">spring.redis.numTestsPerEvictionRun=1024</span><br><span class="line">#逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1</span><br><span class="line">spring.redis.timeBetweenEvictionRunsMillis=30000</span><br><span class="line">#是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个</span><br><span class="line">spring.redis.testOnBorrow=true</span><br><span class="line">#在空闲时检查有效性, 默认false</span><br></pre></td></tr></table></figure></p>
<p>在spring b00t 1.0中，编写简单的测试用例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">	private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">	@Test</span><br><span class="line">	public void test() throws Exception &#123;</span><br><span class="line">		// 保存字符串</span><br><span class="line">		stringRedisTemplate.opsForValue().set(&quot;aaa&quot;, &quot;111&quot;);</span><br><span class="line">		Assert.assertEquas(&quot;111&quot;, stringRedisTemplate.opsForValue().get(&quot;aaa&quot;));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>用redisDesktopManager打开redis就会看见redis中存入了一个key-value的数据<br><img src="/2019/08/10/spring-boot-redis/aaa.png" alt><br>通过上面这段极为简单的测试案例演示了如何通过自动配置的StringRedisTemplate对象进行Redis的读写操作，该对象从命名中就可注意到支持的是String类型。如果有使用过spring-data-redis的开发者一定熟悉RedisTemplate&lt;K, V&gt;接口，StringRedisTemplate就相当于RedisTemplate&lt;String, String&gt;的实现。</p>
<h2 id="redis存放对象RedisTemplate"><a href="#redis存放对象RedisTemplate" class="headerlink" title="redis存放对象RedisTemplate"></a>redis存放对象RedisTemplate</h2><p>除了String类型，实经常会在Redis中存储对象，这时候我们就会想是否可以使用类似RedisTemplate&lt;String, User&gt;来初始化并进行操作。但是Spring Boot并不支持直接使用，需要我们自己实现RedisSerializer<t>接口来对传入对象进行序列化和反序列化<br>所以序列化和反序列化的方法需要我们重写,首先创建一个需要存储的对象，这里我就直接使用User这个对象<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User extends BaseEntity implements Serializable &#123;</span><br><span class="line">    @Column</span><br><span class="line">    private String username;</span><br><span class="line">    @Column</span><br><span class="line">    private String password;</span><br><span class="line">//get set 省略</span><br></pre></td></tr></table></figure></t></p>
<p>这个配置类非必要，如过出现了jedis connect refused，排除了redis 配置的 #bind 127.0.0.1 等配置问题仍然无效, 这个配置可能有用，这个是指定jedis的链接地址和端口，默认的是连接本地的127.0.0.1：6379<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@PropertySource(value = &quot;classpath:/application.properties&quot;)</span><br><span class="line">public class JedisRedisConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.redis.host&#125;&quot;)</span><br><span class="line">    private  String host;</span><br><span class="line">    @Value(&quot;$&#123;spring.redis.password&#125;&quot;)</span><br><span class="line">    private  String password;</span><br><span class="line">    @Value(&quot;$&#123;spring.redis.port&#125;&quot;)</span><br><span class="line">    private  int port;</span><br><span class="line">    @Value(&quot;$&#123;spring.redis.timeout&#125;&quot;)</span><br><span class="line">    private  int timeout;</span><br><span class="line">    @Bean</span><br><span class="line">    JedisConnectionFactory jedisConnectionFactory() &#123;</span><br><span class="line">        JedisConnectionFactory factory = new JedisConnectionFactory();</span><br><span class="line">        factory.setHostName(host);</span><br><span class="line">        factory.setPort(port);</span><br><span class="line">        factory.setTimeout(timeout); //设置连接超时时间</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自定义redis的对象序列化和反序列化方法RedisObjectSerializer<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RedisObjectSerializer implements RedisSerializer&lt;Object&gt; &#123;</span><br><span class="line">    private Converter&lt;Object, byte[]&gt; serializer = new SerializingConverter();</span><br><span class="line">    private Converter&lt;byte[], Object&gt; deserializer = new DeserializingConverter();</span><br><span class="line"></span><br><span class="line">    static final byte[] EMPTY_ARRAY = new byte[0];</span><br><span class="line"></span><br><span class="line">    public Object deserialize(byte[] bytes) &#123;</span><br><span class="line">        if (isEmpty(bytes)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            return deserializer.convert(bytes);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            throw new SerializationException(&quot;Cannot deserialize&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public byte[] serialize(Object object) &#123;</span><br><span class="line">        if (object == null) &#123;</span><br><span class="line">            return EMPTY_ARRAY;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            return serializer.convert(object);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            return EMPTY_ARRAY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isEmpty(byte[] data) &#123;</span><br><span class="line">        return (data == null || data.length == 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后是RedisTemplate实例方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    JedisConnectionFactory jedisConnectionFactory() &#123;</span><br><span class="line">        return new JedisConnectionFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;();</span><br><span class="line">        template.setConnectionFactory(jedisConnectionFactory());</span><br><span class="line">        template.setKeySerializer(new StringRedisSerializer());</span><br><span class="line">        template.setValueSerializer(new RedisObjectSerializer());</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后运行测试用例实现redis的存储，(这里我遇见了一个问题，默认的序列化后对象在redis中是乱码的,因为我们项目中的对象是以JSON的格式存储到redis中的，等我继续研究哦)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired(required = true)</span><br><span class="line">   private RedisTemplate redisTemplate;</span><br><span class="line">   @Test</span><br><span class="line">   public void testSave()&#123;</span><br><span class="line">// 保存对象</span><br><span class="line">       User user = new User();</span><br><span class="line">       user.setUsername(&quot;1&quot;);</span><br><span class="line">       user.setPassword(&quot;2&quot;);</span><br><span class="line">       redisTemplate.opsForValue().set(user.getUsername(), user);</span><br><span class="line">	//获取对象并发现返回的对象结果正确</span><br><span class="line">       Object object = redisTemplate.opsForValue().get( &quot;1&quot; );</span><br><span class="line">       System.out.println(object.toString());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>emmm,我有了一个猥琐的想法，可以使用fastjson将对象转成JSON,在使用stringRedisTemplate将json存放到redis中，想到就试了试<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">   private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"> @Test</span><br><span class="line">   public void testString()&#123;</span><br><span class="line">       User user = new User();</span><br><span class="line">       user.setUsername(&quot;1&quot;);</span><br><span class="line">       user.setPassword(&quot;2&quot;);</span><br><span class="line">       stringRedisTemplate.opsForValue().set( user.getUsername(),user.toString() );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候的确redis内存放的是JSON字符<br><img src="/2019/08/10/spring-boot-redis/bbb.png" alt><br>but…..,然后发现了在redis的序列化的时候其实是可以指定序列化的方式的,所以如果不需要自定义特殊的序列化方式，就直接使用jackson,对了配置文件也只写着一个就行了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">  public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">      RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;();</span><br><span class="line">      template.setConnectionFactory(jedisConnectionFactory());</span><br><span class="line"></span><br><span class="line">      //jackson的序列方式</span><br><span class="line">      Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">      ObjectMapper om = new ObjectMapper();</span><br><span class="line">      om.setVisibility( PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">      om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">      jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">      //string的序列方式</span><br><span class="line">      StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();</span><br><span class="line">      //key值按String的方式</span><br><span class="line">      template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">      //value 以json的方式</span><br><span class="line">      template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">      template.afterPropertiesSet();</span><br><span class="line">      return template;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="spring-boot-1-x-redis-的注解使用"><a href="#spring-boot-1-x-redis-的注解使用" class="headerlink" title="spring boot 1.x  redis 的注解使用"></a>spring boot 1.x  redis 的注解使用</h1><p>spring boot 使用注解的方式开启缓存，首先是配置缓存的配置文件类<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableCaching</span><br><span class="line">public class CacheConfig extends CachingConfigurerSupport &#123;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;rawtypes&quot;)</span><br><span class="line">    @Bean</span><br><span class="line">    public CacheManager cacheManager(RedisTemplate redisTemplate) &#123;</span><br><span class="line">        RedisCacheManager rcm = new RedisCacheManager( redisTemplate );</span><br><span class="line">        // 多个缓存的名称,目前只定义了一个</span><br><span class="line">        rcm.setCacheNames( Arrays.asList( &quot;thisredis&quot; ) );</span><br><span class="line">        //设置缓存过期时间(秒)</span><br><span class="line">        rcm.setDefaultExpiration( 600 );</span><br><span class="line">        return rcm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">        StringRedisTemplate template = new StringRedisTemplate( factory );</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer( Object.class );</span><br><span class="line">        ObjectMapper om = new ObjectMapper();</span><br><span class="line">        om.setVisibility( PropertyAccessor.ALL,JsonAutoDetect.Visibility.ANY );</span><br><span class="line">        om.enableDefaultTyping( ObjectMapper.DefaultTyping.NON_FINAL );</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper( om );</span><br><span class="line">        template.setValueSerializer( jackson2JsonRedisSerializer );</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//这个是因为默认的JedisConnectionFactory是本地的redis,我链接的是我服务器上的配置，所以要手动配置一下</span><br><span class="line">    @Bean</span><br><span class="line">    JedisConnectionFactory jedisConnectionFactory() &#123;</span><br><span class="line">        JedisConnectionFactory factory = new JedisConnectionFactory();</span><br><span class="line">        factory.setHostName(&quot;xx.xxx.xx.xx&quot;);</span><br><span class="line">        factory.setPort(6379);</span><br><span class="line">        factory.setTimeout(0); //设置连接超时时间</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候启动服务就没有问题，接下来就编写缓存的方法还有测试类,这个方法指定了缓存名称，key是自定义的key值，condition 是配置当id不为3的时候将方法放入缓存中。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Cacheable(value = &quot;thisredis&quot;,key=&quot;&apos;users_&apos;+#id&quot;，condition=&quot;#id!=3&quot;)</span><br><span class="line">   public String getUser(int id) &#123;</span><br><span class="line">       System.out.println( &quot;Method executed..&quot; );</span><br><span class="line">       if (id == 1) &#123;</span><br><span class="line">           return &quot;User 1&quot;;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return &quot;User 2&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">@CacheEvict(value=&quot;thisredis&quot;, key=&quot;&apos;users_&apos;+#id&quot;,condition=&quot;#id!=1&quot;)</span><br><span class="line">   @PostMapping(&quot;/delUser&quot;)</span><br><span class="line">   public void delUser(Integer id) &#123;</span><br><span class="line">       // 删除user</span><br><span class="line">	System.out.pringln(&quot;缓存删除&quot;)；</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th style="text-align:left">描述</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>methodName</td>
<td style="text-align:left">当前方法名</td>
<td style="text-align:center">#root.methodName</td>
</tr>
<tr>
<td>targetClass</td>
<td style="text-align:left">当前被调用的对象的class</td>
<td style="text-align:center">#root.targetClass</td>
</tr>
<tr>
<td>caches</td>
<td style="text-align:left">当前被调用的方法使用的Cache</td>
<td style="text-align:center">#root.caches[0].name</td>
</tr>
</tbody>
</table>
<p>编写测试用例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();</span><br><span class="line">       ctx.register( CacheConfig.class );</span><br><span class="line">       ctx.refresh();</span><br><span class="line">       User user = ctx.getBean(User.class);</span><br><span class="line">       System.out.println(user.getUser( 1 ));</span><br><span class="line">       System.out.println(user.getUser( 1 ));</span><br><span class="line">       System.out.println(user.getUser( 2 ));</span><br><span class="line">       ctx.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>在getUser方面里面添加断点，可以发现在第二次调用user.getUser( 1 )时没有进入断点，而在调用user.getUser( 2 )进入了断点，因为在第二次user.getUser( 1) 的时候数据是从缓存中取出的，而调用delUser的时候会删除缓存区中key相同的数据</p>
<p>​    </p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot zookeeper分布式锁</title>
    <url>/2020/07/15/spring-boot-zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h1 id="一、分布式锁简介"><a href="#一、分布式锁简介" class="headerlink" title="一、分布式锁简介"></a>一、分布式锁简介</h1><p>1、什么是锁<br>在单机环境下，当存在多个线程可以同时改变某个共享变量时，就需要同步来实现该功能，使其线程安全。<br>而同步就是通过锁来实现的。锁保证了同一时刻只有一个线程来修改共享变量。<br><strong>在单机环境下</strong>，Java提供了一些并发安全包可以一定程度上保证线程安全，但是在分布式环境(多机环境)下，这些并发包显得就无能为力了！</p>
<p>2、什么是分布式<br>分布式的CAP理论：<br>任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。</p>
<p>目前很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。基于 CAP理论，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证最终一致性。</p>
<p>3、什么是分布式锁<br>顾名思义，分布式锁肯定是用在分布式环境下。在分布式环境下，使用分布式锁的目的也是保证同一时刻只有一个线程来修改共享变量，修改共享缓存……。</p>
<h1 id="二、Curator实现zk分布式锁"><a href="#二、Curator实现zk分布式锁" class="headerlink" title="二、Curator实现zk分布式锁"></a>二、Curator实现zk分布式锁</h1><p>引入curator的依赖包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile(&quot;org.apache.curator:curator-recipes:4.0.1&quot;) &#123;</span><br><span class="line">     exclude group: &apos;org.slf4j&apos;, module: &apos;slf4j&apos;</span><br><span class="line"> &#125;</span><br><span class="line"> compile group: &apos;org.apache.curator&apos;, name: &apos;curator-framework&apos;, version: &apos;4.0.1&apos;</span><br></pre></td></tr></table></figure>
<p>项目接口如下图</p>
<p><img src="/2020/07/15/spring-boot-zookeeper分布式锁/E:/blog\source\_posts\spring-boot-zookeeper分布式锁\curator-struct.png" alt></p>
<h2 id="连接配置类-zookeeperConf"><a href="#连接配置类-zookeeperConf" class="headerlink" title="连接配置类 zookeeperConf"></a>连接配置类 zookeeperConf</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.apache.curator.RetryPolicy;</span><br><span class="line">import org.apache.curator.framework.CuratorFramework;</span><br><span class="line">import org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line">import org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line">import org.apache.curator.retry.RetryNTimes;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@Slf4j</span><br><span class="line">public class ZooKeeperConf &#123;</span><br><span class="line">    </span><br><span class="line">    @Value(&quot;$&#123;curator.retryCount&#125;&quot;)</span><br><span class="line">    private int retryCount;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;curator.elapsedTimeMs&#125;&quot;)</span><br><span class="line">    private int elapsedTimeMs;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;curator.connectString&#125;&quot;)</span><br><span class="line">    private String connectString;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;curator.sessionTimeoutMs&#125;&quot;)</span><br><span class="line">    private int sessionTimeoutMs;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;curator.connectionTimeoutMs&#125;&quot;)</span><br><span class="line">    private int connectionTimeoutMs;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public CuratorFramework getCuratorFramework() &#123;</span><br><span class="line">        return CuratorFrameworkFactory.newClient(</span><br><span class="line">                connectString,</span><br><span class="line">                sessionTimeoutMs,</span><br><span class="line">                connectionTimeoutMs,</span><br><span class="line">                new RetryNTimes(retryCount, elapsedTimeMs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="业务逻辑获取锁ZooKeeperImpl"><a href="#业务逻辑获取锁ZooKeeperImpl" class="headerlink" title="业务逻辑获取锁ZooKeeperImpl"></a>业务逻辑获取锁ZooKeeperImpl</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.apache.curator.framework.CuratorFramework;</span><br><span class="line">import org.apache.curator.framework.recipes.locks.InterProcessMutex;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class ZooKeeperImpl &#123;</span><br><span class="line">    private static Logger log = LoggerFactory.getLogger(ZooKeeperImpl.class);</span><br><span class="line"></span><br><span class="line">    private static final String lockPath = &quot;/lock/order&quot;;</span><br><span class="line">    @Autowired</span><br><span class="line">    private CuratorFramework zkClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void makeOrder(String product) &#123;</span><br><span class="line">        log.info(&quot;try do job for &quot; + product);</span><br><span class="line">        String path = lockPath + &quot;/&quot; + product;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // InterProcessMutex 构建一个分布式锁</span><br><span class="line">            InterProcessMutex lock = new InterProcessMutex(zkClient, path);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                if (lock.acquire(5, TimeUnit.HOURS)) &#123;</span><br><span class="line">                    // 模拟业务处理耗时5秒</span><br><span class="line">                    Thread.sleep(5 * 1000);</span><br><span class="line">                    log.info(&quot;do job &quot; + product + &quot;done&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 释放该锁</span><br><span class="line">                lock.release();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // zk异常</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="操作接口-ZooKeeperController"><a href="#操作接口-ZooKeeperController" class="headerlink" title="操作接口 ZooKeeperController"></a>操作接口 ZooKeeperController</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">import com.zookeeper.lock.impl.ZooKeeperImpl;</span><br><span class="line">import org.apache.curator.framework.CuratorFramework;</span><br><span class="line">import org.apache.zookeeper.ZooKeeper;</span><br><span class="line">import org.apache.zookeeper.data.Stat;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/zookeeper&quot;)</span><br><span class="line">public class ZooKeeperController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CuratorFramework zkClient;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ZooKeeperImpl zooKeeper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * zookeeper 获取节点下的数据</span><br><span class="line">     *</span><br><span class="line">     * post请求： http://localhost:8082/zookeeper/makeOrder?path=/task</span><br><span class="line">     *</span><br><span class="line">     * @param path</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/getData&quot;)</span><br><span class="line">    public String getData(@RequestParam String path) &#123;</span><br><span class="line">        byte[] bytes = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            bytes = zkClient.getData().forPath(path);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String str = new String(bytes);</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/create&quot;)</span><br><span class="line">    public String create(@RequestParam String path) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            zkClient.create().forPath(path);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/delete&quot;)</span><br><span class="line">    public String delete(@RequestParam String path) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            zkClient.delete().forPath(path);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/setData&quot;)</span><br><span class="line">    public String setData(@RequestParam(value = &quot;path&quot;) String path, @RequestParam(value = &quot;data&quot;) String data) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            zkClient.setData().forPath(path, data.getBytes());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/check&quot;)</span><br><span class="line">    public String check(@RequestParam(value = &quot;path&quot;) String path) &#123;</span><br><span class="line">        Stat stat = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            stat = zkClient.checkExists().forPath(path);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;stat&quot; + stat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/children&quot;)</span><br><span class="line">    public String children(@RequestParam(value = &quot;path&quot;) String path) &#123;</span><br><span class="line">        List&lt;String&gt; children = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            children = zkClient.getChildren().forPath(path);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;children&quot; + children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/watch&quot;)</span><br><span class="line">    public String watch(@RequestParam(value = &quot;path&quot;) String path) &#123;</span><br><span class="line">        Stat stat = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            stat = zkClient.checkExists().watched().forPath(path);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;watch &quot; + stat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * zookeeper分布式锁</span><br><span class="line">     *</span><br><span class="line">     * @param product</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/makeOrder&quot;)</span><br><span class="line">    public String makeOrder(@RequestParam(value = &quot;product&quot;) String product) &#123;</span><br><span class="line">        zooKeeper.makeOrder(product);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件application.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server.port=8081</span><br><span class="line"></span><br><span class="line">#重试次数</span><br><span class="line">curator.retryCount=5</span><br><span class="line">#重试间隔时间</span><br><span class="line">curator.elapsedTimeMs=5000</span><br><span class="line"># zookeeper 地址</span><br><span class="line">curator.connectString=localhost:2181</span><br><span class="line"># session超时时间</span><br><span class="line">curator.sessionTimeoutMs=60000</span><br><span class="line"># 连接超时时间</span><br><span class="line">curator.connectionTimeoutMs=5000</span><br></pre></td></tr></table></figure>
<p>三、原生zookeeper的分布式锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.zookeeper.lock.controller;</span><br><span class="line"></span><br><span class="line">import org.apache.zookeeper.*;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">public class ZooKeeperSession &#123;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(ZooKeeperSession.class);</span><br><span class="line"></span><br><span class="line">    private static CountDownLatch connectedSemaphore = new CountDownLatch(1);</span><br><span class="line"></span><br><span class="line">    private ZooKeeper zookeeper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public ZooKeeperSession() &#123;</span><br><span class="line"></span><br><span class="line">        // 连接zookeeper server，是异步创建会话的，那我们怎么知道zk session建立成功了呢？</span><br><span class="line">        // 通过一个监听器+CountDownLatch，来确认真正建立了zk server的连接</span><br><span class="line">        try &#123;</span><br><span class="line">            this.zookeeper = new ZooKeeper(</span><br><span class="line">                    &quot;localhost:2181&quot;,</span><br><span class="line">                    50000,</span><br><span class="line">                    new ZooKeeperWatcher());</span><br><span class="line"></span><br><span class="line">            //打印即使状态：验证其是不是异步的？</span><br><span class="line">            logger.info(String.valueOf(zookeeper.getState()));</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                // CountDownLatch：简而言之 初始化——非0；非0——等待；0——往下执行</span><br><span class="line">                connectedSemaphore.await();</span><br><span class="line">            &#125; catch(InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            logger.info(&quot;ZooKeeper session established......&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 建立zk session的watcher：</span><br><span class="line">     */</span><br><span class="line">    private class ZooKeeperWatcher implements Watcher &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void process(WatchedEvent event) &#123;</span><br><span class="line">            if(Event.KeeperState.SyncConnected == event.getState()) &#123;</span><br><span class="line">                connectedSemaphore.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重试获取分布式锁：</span><br><span class="line">     *</span><br><span class="line">     * @param adId</span><br><span class="line">     */</span><br><span class="line">    public void acquireDistributedLock(Long adId) throws InterruptedException &#123;</span><br><span class="line">        String path = &quot;/ad-lock-&quot; + adId;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            zookeeper.create(path, &quot;&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">            logger.info(&quot;获取锁成功&quot;+Thread.currentThread().getName()+&quot;ID:&quot;+ adId);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // 如果那个广告对应的锁node，已经存在了，就是已经被别人加锁了，那么就这里就会报错</span><br><span class="line">            // NodeExistsException</span><br><span class="line">            int count = 0;</span><br><span class="line">            while(true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    zookeeper.create(path, &quot;&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">                &#125; catch (Exception e2) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    if(count&lt;10) &#123;</span><br><span class="line">                        logger.info(&quot;the &quot; + count + &quot; times try to acquire lock for adId = &quot; + adId);</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        logger.error(&quot;请求次数过多，不再请求获取锁，获取失败&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                logger.info(&quot;success to acquire lock for adId = &quot; + adId + &quot; after &quot; + count + &quot; times try......&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 释放掉分布式锁：</span><br><span class="line">     *</span><br><span class="line">     * @param adId</span><br><span class="line">     */</span><br><span class="line">    public void releaseDistributedLock(Long adId) &#123;</span><br><span class="line">        String path = &quot;/ad-lock-&quot; + adId;</span><br><span class="line">        try &#123;</span><br><span class="line">            zookeeper.delete(path, -1);</span><br><span class="line">            logger.info(&quot;release the lock for adId = &quot; + adId);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Long adId = 1L;</span><br><span class="line"></span><br><span class="line">        ZooKeeperSession zkSession1 = new ZooKeeperSession();</span><br><span class="line"></span><br><span class="line">        ZooKeeperSession zkSession2 = new ZooKeeperSession();</span><br><span class="line"></span><br><span class="line">        //1、获取锁：</span><br><span class="line">        zkSession1.acquireDistributedLock(adId);</span><br><span class="line">        zkSession2.acquireDistributedLock(adId);</span><br><span class="line"></span><br><span class="line">        //2、执行一些修改共享资源的操作</span><br><span class="line">        logger.info(&quot;I am updating common resource！&quot;);</span><br><span class="line"></span><br><span class="line">        //3、释放锁</span><br><span class="line">        zkSession1.releaseDistributedLock(adId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot 创建定时任务</title>
    <url>/2019/08/19/spring-boot-%E5%88%9B%E5%BB%BA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="使用注解-Scheduled创建定时任务"><a href="#使用注解-Scheduled创建定时任务" class="headerlink" title="使用注解@Scheduled创建定时任务"></a>使用注解@Scheduled创建定时任务</h1><p>@Scheduled默认创建的线程是单线程，任务的执行会受到上一个任务的影响，创建定时任务也比较简单<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Configuration      //1.主要用于标记配置类，兼备Component的效果。</span><br><span class="line">@EnableScheduling   // 2.开启定时任务</span><br><span class="line">public class ScheduledTask &#123;</span><br><span class="line">    //3.添加定时任务</span><br><span class="line">    @Scheduled(cron = &quot;0/5 * * * * ?&quot;)</span><br><span class="line">    //或直接指定时间间隔，例如：5秒</span><br><span class="line">    //@Scheduled(fixedRate=5000)</span><br><span class="line">    private void configureTasks() &#123;</span><br><span class="line">        System.err.println(&quot;执行静态定时任务时间: &quot; + LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Cron的表达式为 秒（0-59） 分（0~59）时（0~23）日（0~31）的某天，需计算月（0~11）周几（ 可填1-7 或 SUN/MON/TUE/WED/THU/FRI/SAT）<br>“0/5 <em> </em> <em> </em> ?”可以解析成 每5秒执行一次，其他不指定，此时开启application,控制台没隔5秒打印一次</p>
<h1 id="基于接口的定时任务"><a href="#基于接口的定时任务" class="headerlink" title="基于接口的定时任务"></a>基于接口的定时任务</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Configuration      //1.主要用于标记配置类，兼备Component的效果。</span><br><span class="line">@EnableScheduling   // 2.开启定时任务</span><br><span class="line">public class DynamicScheduleTask implements SchedulingConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123;</span><br><span class="line">        taskRegistrar.addTriggerTask(</span><br><span class="line">                //1.添加任务内容(Runnable),匿名</span><br><span class="line">                () -&gt; System.out.println(&quot;执行动态定时任务: &quot; + LocalDateTime.now().toLocalTime()),</span><br><span class="line">                //2.设置执行周期(Trigger)</span><br><span class="line">                triggerContext -&gt; &#123;</span><br><span class="line">                    return new CronTrigger(&quot;0/5 * * * * ?&quot;).nextExecutionTime(triggerContext);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多线程的定时任务"><a href="#多线程的定时任务" class="headerlink" title="多线程的定时任务"></a>多线程的定时任务</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@EnableScheduling   // 1.开启定时任务</span><br><span class="line">@EnableAsync        // 2.开启多线程</span><br><span class="line">public class MultiThreadScheduleTask &#123;</span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    @Scheduled(fixedDelay = 1000)  //间隔1秒</span><br><span class="line">    public void first() throws InterruptedException &#123;</span><br><span class="line">        System.out.println(&quot;第一个定时任务开始 : &quot; + LocalDateTime.now().toLocalTime() + &quot;\r\n线程 : &quot; + Thread.currentThread().getName());</span><br><span class="line">        System.out.println();</span><br><span class="line">        Thread.sleep(1000 * 10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    @Scheduled(fixedDelay = 2000)</span><br><span class="line">    public void second() &#123;</span><br><span class="line">        System.out.println(&quot;第二个定时任务开始 : &quot; + LocalDateTime.now().toLocalTime() + &quot;\r\n线程 : &quot; + Thread.currentThread().getName());</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个定时任务随着时间的增加不断的增加线程，这肯定会消耗大量的资源，因此在配置多线程的定时任务时，常常需要设置一个线程池来避免资源消耗过多<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableAsync</span><br><span class="line">@Configuration</span><br><span class="line">public class TaskPoolConfig &#123;</span><br><span class="line">    @Bean(&quot;taskExecutor&quot;)</span><br><span class="line">    public Executor taskExecutor() &#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(10);</span><br><span class="line">        executor.setMaxPoolSize(20);</span><br><span class="line">        executor.setQueueCapacity(200);</span><br><span class="line">        executor.setKeepAliveSeconds(60);</span><br><span class="line">        executor.setThreadNamePrefix(&quot;taskExecutor-&quot;);</span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(true);//设置线程在任务执行完之后才x释放</span><br><span class="line">        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        return executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用Future来获取Runable的执行结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class Task &#123;</span><br><span class="line">    public static Random random = new Random();</span><br><span class="line">    @Async(&quot;taskExecutor&quot;)</span><br><span class="line">    public Future&lt;String&gt; run() throws Exception &#123;</span><br><span class="line">        long sleep = random.nextInt(10000);</span><br><span class="line">        log.info(&quot;开始任务，需耗时：&quot; + sleep + &quot;毫秒&quot;);</span><br><span class="line">        Thread.sleep(sleep);</span><br><span class="line">        log.info(&quot;完成任务&quot;);</span><br><span class="line">        return new AsyncResult&lt;&gt;(&quot;test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义超时时间并释放线程<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class ApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Task task;</span><br><span class="line">    @Test</span><br><span class="line">    public void test() throws Exception &#123;</span><br><span class="line">        Future&lt;String&gt; futureResult = task.run();</span><br><span class="line">        String result = futureResult.get(5, TimeUnit.SECONDS);</span><br><span class="line">        log.info(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>schedule</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot web模板引擎和统一异常处理</title>
    <url>/2019/04/20/spring-boot%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="spring-boot-模板引擎"><a href="#spring-boot-模板引擎" class="headerlink" title="spring boot 模板引擎"></a>spring boot 模板引擎</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;在我们开发Web应用的时候，需要引用大量的js、css、图片等静态资源。在动态HTML实现上Spring Boot依然可以完美胜任，并且提供了多种模板引擎的默认配置支持，所以在推荐的模板引擎下，我们可以很快的上手开发动态网站。<br>Spring Boot提供了默认配置的模板引擎主要有以下几种：<br>&nbsp;&nbsp;&nbsp;&nbsp;ymeleaf<br>&nbsp;&nbsp;&nbsp;&nbsp;FreeMarker<br>&nbsp;&nbsp;&nbsp;&nbsp;Velocity<br>&nbsp;&nbsp;&nbsp;&nbsp;Groovy<br>&nbsp;&nbsp;&nbsp;&nbsp;Mustache<br>当你使用上述模板引擎中的任何一个，它们默认的模板配置路径为：src/main/resources/templates。当然也可以修改这个路径，具体如何修改，可在后续各模板引擎的配置属性中查询并修改。</p>
<h2 id="使用Thymeleaf的示例"><a href="#使用Thymeleaf的示例" class="headerlink" title="使用Thymeleaf的示例"></a>使用Thymeleaf的示例</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Thymeleaf是一个XML/XHTML/HTML5模板引擎，可用于Web与非Web环境中的应用开发。它是一个开源的Java库，基于Apache License 2.0许可，由Daniel Fernández创建，该作者还是Java加密库Jasypt的作者。<br>&nbsp;&nbsp;&nbsp;&nbsp;Thymeleaf提供了一个用于整合Spring MVC的可选模块，在应用开发中，你可以使用Thymeleaf来完全代替JSP或其他模板引擎，如Velocity、FreeMarker等。Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的XML与HTML模板。相对于编写逻辑或代码，开发者只需将标签属性添加到模板中即可。接下来，这些标签属性就会在DOM（文档对象模型）上执行预先制定好的逻辑。<br>&nbsp;&nbsp;&nbsp;&nbsp;在Spring Boot中使用Thymeleaf，只需要引入下面依赖，并在默认的模板路径src/main/resources/templates下编写模板文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile group: &apos;org.springframework.boot&apos;, name: &apos;spring-boot-starter-thymeleaf&apos;, version: &apos;2.0.6.RELEASE&apos;</span><br></pre></td></tr></table></figure></p>
<p>在完成配置之后，举一个简单的例子，在快速入门工程的基础上，举一个简单的示例来通过Thymeleaf渲染一个页面。使用的是@Controller而不是@RestController 因为@RestController是@ReponseBody和@Controller，发布会的结果默认是JSON格式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @RequestMapping(&quot;/&quot;)</span><br><span class="line">    public String index(ModelMap map) &#123;</span><br><span class="line">        // 加入一个属性，用来在模板中读取</span><br><span class="line">        map.addAttribute(&quot;host&quot;, &quot;  应该替换成的文字&quot;);</span><br><span class="line">        // return模板文件的名称，对应src/main/resources/templates/index.html</span><br><span class="line">        return &quot;index&quot;;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在templates下创建一个 index.html文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang=&quot;en&quot;&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1 th:text=&quot;$&#123;host&#125;&quot;&gt;为被替换的文字&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>springboot的默认配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#thymeleaf的默认配置</span><br><span class="line"># Enable template caching.</span><br><span class="line">spring.thymeleaf.cache=true</span><br><span class="line"># Check that the templates location exists.</span><br><span class="line">spring.thymeleaf.check-template-location=true</span><br><span class="line"># Content-Type value.</span><br><span class="line">spring.thymeleaf.content-type=text/html</span><br><span class="line"># Enable MVC Thymeleaf view resolution.</span><br><span class="line">spring.thymeleaf.enabled=true</span><br><span class="line"># Template encoding.</span><br><span class="line">spring.thymeleaf.encoding=UTF-8 </span><br><span class="line"># Comma-separated list of view names that should be excluded from resolution.</span><br><span class="line">spring.thymeleaf.excluded-view-names=</span><br><span class="line"># Template mode to be applied to templates. See also StandardTemplateModeHandlers.</span><br><span class="line">spring.thymeleaf.mode=HTML5</span><br><span class="line"># Prefix that gets prepended to view names when building a URL.</span><br><span class="line">spring.thymeleaf.prefix=classpath:/templates/</span><br><span class="line"># Suffix that gets appended to view names when building a URL.</span><br><span class="line">spring.thymeleaf.suffix=.html</span><br><span class="line">#spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain. spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved.</span><br></pre></td></tr></table></figure></p>
<p>这个时候运行成功后访问localhost:port  就可以看见页面上的内容</p>
<h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>自定义异常<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyException extends Exception &#123;</span><br><span class="line">    public MyException(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建全局异常处理类：通过使用@ControllerAdvice定义统一的异常处理类，而不是在每个Controller中逐个定义。@ExceptionHandler用来定义函数针对的异常类型，最后将Exception对象和请求URL映射到error.html中<br>船舰异常的处理类，@ExceptionHandler是标识这个方法是处理什么类型的异常<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ControllerAdvice</span><br><span class="line">class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    public static final String DEFAULT_ERROR_VIEW = &quot;error&quot;;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(value = NullPointerException.class)</span><br><span class="line">    public ModelAndView defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception &#123;</span><br><span class="line">        ModelAndView mav = new ModelAndView();</span><br><span class="line">        mav.addObject(&quot;exception&quot;, e);</span><br><span class="line">        mav.addObject(&quot;url&quot;, req.getRequestURL());</span><br><span class="line">        mav.setViewName(DEFAULT_ERROR_VIEW);</span><br><span class="line">        return mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现error.html页面展示：在templates目录下创建error.html，将请求的URL和Exception对象的message输出。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:th=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span><br><span class="line">&lt;head lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;统一异常处理&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Error Handler&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;url: $&#123;url&#125;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt;message:$&#123;exception&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>创建一个抛出异常的请求<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/json&quot;)</span><br><span class="line">   public String  json() throws MyException &#123;</span><br><span class="line">       throw new MyException(&quot;发生错误2&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候请求/json方法，就会返回error界面，并显示出错误的请求路径和错误信息<br>如果需要返回的是JSON类型的格式，只需要返回的加上@ReponseBody注解<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">异常信息类</span><br><span class="line">public class ErrorInfo&lt;T&gt; &#123;</span><br><span class="line">    public static final Integer OK = 0;</span><br><span class="line">    public static final Integer ERROR = 100;</span><br><span class="line">    private Integer code;</span><br><span class="line">    private String message;</span><br><span class="line">    private String url;</span><br><span class="line">    private T data;</span><br><span class="line">    // 省略getter和setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在异常处理方法中改写为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ExceptionHandler(value = MyException.class)</span><br><span class="line">@ResponseBody  //这个注解是返回JSON格式</span><br><span class="line">public ErrorInfo&lt;String&gt; defaultErrorHandler(HttpServletRequest req,MyException e) throws Exception &#123;</span><br><span class="line">    ErrorInfo&lt;String&gt; r = new ErrorInfo&lt;&gt;();</span><br><span class="line">    r.setMessage(e.getMessage());</span><br><span class="line">    r.setCode(ErrorInfo.ERROR);</span><br><span class="line">    r.setData(&quot;Some Data&quot;);</span><br><span class="line">    r.setUrl(req.getRequestURL().toString());</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot xml格式消息转换</title>
    <url>/2019/08/05/spring-boot%E5%9B%9B/</url>
    <content><![CDATA[<h1 id="消息转换器（Message-Converter）"><a href="#消息转换器（Message-Converter）" class="headerlink" title="消息转换器（Message Converter）"></a>消息转换器（Message Converter）</h1><p>在spring boot中出路HTTP请求的实现使用的是spring MVC 。而在Spring MVC中有一个消息转换器这个概念，它主要负责处理各种不同格式的请求数据进行处理，并包转换成对象，以提供更好的编程体验。<br>在Spring MVC中定义了HttpMessageConverter接口，抽象了消息转换器对类型的判断、对读写的判断与操作，具体可见如下定义：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface HttpMessageConverter&lt;T&gt; &#123;</span><br><span class="line">    boolean canRead(Class&lt;?&gt; clazz, @Nullable MediaType mediaType);</span><br><span class="line">    boolean canWrite(Class&lt;?&gt; clazz, @Nullable MediaType mediaType);</span><br><span class="line">    List&lt;MediaType&gt; getSupportedMediaTypes();</span><br><span class="line">    T read(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException;</span><br><span class="line">    void write(T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>HTTP请求的Content-Type有各种不同格式定义，如果要支持Xml格式的消息转换，就必须要使用对应的转换器。Spring MVC中默认已经有一套采用Jackson实现的转换器MappingJackson2XmlHttpMessageConverter。<br>常用的HTTP请求中header传输MediaType 类型，常用的是application/json，application/xml.前后端传输数据常用格式是json,但也有接口之间采用的是XML的方式传输数据<br>传统的Spring应用中，我们可以通过如下配置加入对Xml格式数据的消息转换实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MessageConverterConfig1 extends WebMvcConfigurerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;</span><br><span class="line">        Jackson2ObjectMapperBuilder builder = Jackson2ObjectMapperBuilder.xml();</span><br><span class="line">        builder.indentOutput(true);</span><br><span class="line">        converters.add(new MappingJackson2XmlHttpMessageConverter(builder.build()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而在springboot应用中，只需要加入jackson-dataformat-xml依赖，Spring Boot就会自动引入MappingJackson2XmlHttpMessageConverter的实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile group: &apos;com.fasterxml.jackson.dataformat&apos;, name: &apos;jackson-dataformat-xml&apos;, version: &apos;2.9.8&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="建立实体和XML的转换关系"><a href="#建立实体和XML的转换关系" class="headerlink" title="建立实体和XML的转换关系"></a>建立实体和XML的转换关系</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@JacksonXmlRootElement(localName = &quot;XmlPojo&quot;)</span><br><span class="line">public class XmlPojo &#123;</span><br><span class="line">    @JacksonXmlProperty(localName = &quot;message1&quot;)</span><br><span class="line">    private String message1;</span><br><span class="line">    @JacksonXmlProperty(localName = &quot;message2&quot;)</span><br><span class="line">    private Integer message2;</span><br><span class="line">	//get、set方式省略</span><br></pre></td></tr></table></figure>
<p>这个实体转成XML的对应关系为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;XmlPojo&gt;</span><br><span class="line">    &lt;message1&gt;*&lt;/message1&gt;</span><br><span class="line">    &lt;message2&gt;*&lt;/message2&gt;</span><br><span class="line">&lt;/XmlPojo&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="请求于接收XML格式的数据"><a href="#请求于接收XML格式的数据" class="headerlink" title="请求于接收XML格式的数据"></a>请求于接收XML格式的数据</h2><p>XML格式的消息发送,我使用的是postman工具发起的请求，在header中指定数据类型 Content-Type: application/xml，发送的数据为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;XmlPojo&gt;</span><br><span class="line">    &lt;message1&gt;message1&lt;/message1&gt;</span><br><span class="line">    &lt;message2&gt;2&lt;/message2&gt;</span><br><span class="line">&lt;/XmlPojo&gt;</span><br></pre></td></tr></table></figure></p>
<p>接收参数并返回XML。consumes = MediaType.APPLICATION_XML_VALUE,produces = MediaType.APPLICATION_XML_VALUE<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@PostMapping(value = &quot;/xmlTest2&quot;,consumes = MediaType.APPLICATION_XML_VALUE,</span><br><span class="line">        produces = MediaType.APPLICATION_XML_VALUE)</span><br><span class="line">public XmlPojo xmlTest2(@RequestBody XmlPojo xml)&#123;</span><br><span class="line">    return xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot localDate等时间序列化异常</title>
    <url>/2019/04/20/spring-boot%E4%B8%89/</url>
    <content><![CDATA[<h1 id="普通时间的序列化"><a href="#普通时间的序列化" class="headerlink" title="普通时间的序列化"></a>普通时间的序列化</h1><p>@nbsp;@nbsp;@nbsp;@nbsp;LocalDate、LocalTime、LocalDateTime是Java 8开始提供的时间日期API，然而我们在使用Spring Boot或使用Spring Cloud Feign的时候会出现各种问题<br>以前使用的Date只需要添加注解下面的注解，就能够在前后端以JSON格式传输<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)</span><br><span class="line">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span><br><span class="line">private Date date ;</span><br></pre></td></tr></table></figure></p>
<p>如果使用了LocalDate等类型，在传输数据就会报错JSON parse error: Can not construct instance of java.time.LocalDate<br>因为默认情况下Spring MVC对于LocalDate序列化成了一个数组类型，而Feign在调用的时候，还是按照ArrayList来处理，所以自然无法反序列化为LocalDate对象了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;date&quot;:[2019,1,1]</span><br></pre></td></tr></table></figure></p>
<p>解决办法：<br>先引入jackson-datatype-jsr310依赖，再在启动类中加入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//      依赖中加入localDate时间转化依赖</span><br><span class="line">compile group: &apos;com.fasterxml.jackson.datatype&apos;, name: &apos;jackson-datatype-jsr310&apos;, version: &apos;2.9.8&apos;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">//		在启动类中添加</span><br><span class="line">@Bean</span><br><span class="line">public ObjectMapper serializingObjectMapper() &#123;</span><br><span class="line">    ObjectMapper objectMapper = new ObjectMapper();</span><br><span class="line">    objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span><br><span class="line">    objectMapper.registerModule(new JavaTimeModule());</span><br><span class="line">    return objectMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot连接mongodb</title>
    <url>/2019/08/18/spring-boot%E8%BF%9E%E6%8E%A5mongodb/</url>
    <content><![CDATA[<h1 id="linux-centos7-安装mongodb"><a href="#linux-centos7-安装mongodb" class="headerlink" title="linux(centos7)安装mongodb"></a>linux(centos7)安装mongodb</h1><p>我是在linux获取安装包，可以去官网下载对应的安装包。官网地址:<a href="https://www.mongodb.com/download-center?jmp=nav#community" target="_blank" rel="noopener">https://www.mongodb.com/download-center?jmp=nav#community</a><br>我是安装在目录路径为 /usr/local/momgodb 下。<br>首先切换路径<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/local/momgodb</span><br><span class="line">//下载安装包</span><br><span class="line">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.0.tgz</span><br><span class="line">//下载完成之后解压缩</span><br><span class="line">tar zxvf mongodb-linux-x86_64-4.0.0.tgz</span><br><span class="line">//解压后的文件名重命名为（mongodb），这个看你自己的喜好，可以不改</span><br><span class="line">mv mongodb-linux-x86_64-4.0.0 mongodb</span><br><span class="line">//修改环境的配置变量</span><br><span class="line">vim /etc/profile</span><br><span class="line">//先按i进入文本编辑的insert模式，编辑完成后先 esc退出编辑，再:wq保存编辑,编辑类容如下</span><br><span class="line">#Mongodb</span><br><span class="line">export PATH=/usr/local/mongodb/mongodb/bin:$PATH</span><br><span class="line">export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL</span><br><span class="line">//保存完毕后，使配置文件生效</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">//创建数据库目录</span><br><span class="line"> cd /usr/mongodb/mongodb</span><br><span class="line">$ touch mongodb.conf</span><br><span class="line">$ mkdir db</span><br><span class="line">$ mkdir log</span><br><span class="line">$ cd log</span><br><span class="line">$ touch mongodb.log</span><br><span class="line"></span><br><span class="line">//修改mongodb的启动配置</span><br><span class="line">vim /usr/local/mongodb/mongodb/mongodb.conf</span><br><span class="line">//再配置文件中添加一下内容</span><br><span class="line">port=27017 #端口</span><br><span class="line">dbpath= /usr/local/mongodb/mongodb/db #数据库存文件存放目录</span><br><span class="line">logpath= /usr/local/mongodb/mongodb/log/mongodb.log #日志文件存放路径</span><br><span class="line">logappend=true #使用追加的方式写日志</span><br><span class="line">fork=true #以守护进程的方式运行，创建服务器进程</span><br><span class="line">maxConns=100 #最大同时连接数</span><br><span class="line">noauth=true #不启用验证</span><br><span class="line">journal=true #每次写入会记录一条操作日志（通过journal可以重新构造出写入的数据）。</span><br><span class="line">#即使宕机，启动时wiredtiger会先将数据恢复到最近一次的checkpoint点，然后重放后续的journal日志来恢复。</span><br><span class="line">storageEngine=wiredTiger  #存储引擎有mmapv1、wiretiger、mongorocks</span><br><span class="line">bind_ip = 0.0.0.0  #这样就可外部访问了，例如从win10中去连虚拟机中的MongoDB</span><br><span class="line">//上述文件配置完成以后，就可以以这个配置文件来启动mongodb</span><br><span class="line"> mongod --config /usr/local/mongodb/mongodb/mongodb.conf</span><br></pre></td></tr></table></figure></p>
<h2 id="设置mongondb的开启自启动"><a href="#设置mongondb的开启自启动" class="headerlink" title="设置mongondb的开启自启动"></a>设置mongondb的开启自启动</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//切换目录，创建服务的方式开机自启动 </span><br><span class="line">cd /lib/systemd/system</span><br><span class="line">//编辑文件（这个时候会创建这个文件）</span><br><span class="line">vi mongodb.service</span><br><span class="line">//添加一下文件，注意安装的路径不要写错了</span><br><span class="line">	[Unit]  </span><br><span class="line">    Description=mongodb  </span><br><span class="line">    After=network.target remote-fs.target nss-lookup.target  </span><br><span class="line">  </span><br><span class="line">    [Service]  </span><br><span class="line">    Type=forking  </span><br><span class="line">    RuntimeDirectory=mongodb</span><br><span class="line">    RuntimeDirectoryMode=0751</span><br><span class="line">    PIDFile=/var/run/mongodb/mongod.pid</span><br><span class="line">    ExecStart=/usr/local/momgodb/mongodb/bin/mongod --config /usr/local/mongodb/momgodb/mongodb.conf  </span><br><span class="line">    ExecStop=/usr/local/momgodb/mongodb/bin/mongod --shutdown /usr/local/mongodb/momgodb/mongodb.conf  </span><br><span class="line">    PrivateTmp=false  </span><br><span class="line">  </span><br><span class="line">    [Install]  </span><br><span class="line">    WantedBy=multi-user.target</span><br><span class="line">	</span><br><span class="line">/// 设置mongodb.service权限</span><br><span class="line">chmod 754 mongodb.service</span><br><span class="line">#启动服务</span><br><span class="line">systemctl start mongodb.service</span><br><span class="line">#关闭服务</span><br><span class="line">systemctl stop mongodb.service</span><br><span class="line">#开机启动</span><br><span class="line">systemctl enable mongodb.service</span><br><span class="line"></span><br><span class="line">//mongodb.service启动测试,你重启下服务器试试呀~，通过工具连接判断是否生效</span><br></pre></td></tr></table></figure>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//查看mongodb进程</span><br><span class="line">ps aux |grep mongodb</span><br><span class="line">//关闭mongodb服务</span><br><span class="line">sudo kill pid(你查出来的进程pid)</span><br></pre></td></tr></table></figure>
<p>使用mongodb的时候经常需要设置密码和用户，只需要注释调启动配置的noauth = true，再重启之前需要先添加用户信息来进行验证<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//使用admin数据库</span><br><span class="line">use admin</span><br><span class="line">//给admin数据库添加管理员用户名和密码，用户名和密码请自行设置</span><br><span class="line">db.createUser(&#123;user:&quot;admin&quot;,pwd:&quot;123456&quot;,roles:[&quot;root&quot;]&#125;)</span><br><span class="line">//验证是否成功，返回1则代表成功</span><br><span class="line">db.auth(&quot;admin&quot;, &quot;123456&quot;)</span><br><span class="line">//切换到要设置的数据库,以test为例</span><br><span class="line">use test</span><br><span class="line">//为test创建用户,用户名和密码请自行设置。</span><br><span class="line">db.createUser(&#123;user: &quot;test&quot;, pwd: &quot;123456&quot;, roles: [&#123; role: &quot;dbOwner&quot;, db: &quot;test&quot; &#125;]&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这里可以使用可视化连接工具,我使用的是robo 3t，安装方法比较简单，就不赘述喽</p>
<h1 id="spring-boot-连接mongodb是先上传、下载、删除的功能"><a href="#spring-boot-连接mongodb是先上传、下载、删除的功能" class="headerlink" title="spring boot 连接mongodb是先上传、下载、删除的功能"></a>spring boot 连接mongodb是先上传、下载、删除的功能</h1><p>首先引入连接mongodb的依赖  compile group: ‘org.springframework.boot’, name: ‘spring-boot-starter-data-mongodb’, version: ‘2.1.4.RELEASE’,<br>此时mongodb在注入了 MongoTemplate 和GridFsTemplate 。编写测试用例..<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/mongodb&quot;)</span><br><span class="line">public class MongodbController &#123;</span><br><span class="line"></span><br><span class="line">    //简单的Collection存储对象</span><br><span class="line">    @Autowired</span><br><span class="line">    MongoTemplate mongotemplate;</span><br><span class="line"></span><br><span class="line">    // 获得SpringBoot提供的mongodb的GridFS对象</span><br><span class="line">    @Autowired</span><br><span class="line">    private GridFsTemplate gridFsTemplate;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/test&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public OperateResult home() &#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setUsername(&quot;test&quot;);</span><br><span class="line">        user.setPassword(&quot;test&quot;);</span><br><span class="line">        user.setEmail(&quot;test&quot;);</span><br><span class="line">        user.setPhone(&quot;test&quot;);</span><br><span class="line">        user.setQuestion(&quot;test&quot;);</span><br><span class="line">        user.setAnswer(&quot;test&quot;);</span><br><span class="line">        user.setRole(0);</span><br><span class="line">        user.setId(&quot;test&quot;);</span><br><span class="line">        user.setCreateTime(new Date());</span><br><span class="line">        user.setCreateBy(0L);</span><br><span class="line">        user.setLastModifiedTime(new Date());</span><br><span class="line">        user.setLastModifiedBy(&quot;test&quot;);</span><br><span class="line">        mongotemplate.save( user );</span><br><span class="line">        return OperateResult.operationSuccess( &quot;save1&quot; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/fileSave&quot;)</span><br><span class="line">    public OperateResult saveFile(@RequestParam(&quot;file&quot;)MultipartFile file)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String fileName = file.getOriginalFilename();</span><br><span class="line">            // 获得文件输入流</span><br><span class="line">            InputStream ins = file.getInputStream();</span><br><span class="line">            // 获得文件类型</span><br><span class="line">            String contentType = file.getContentType();</span><br><span class="line">            GridFSFile gridFSFile = gridFsTemplate.store(ins, fileName, contentType);</span><br><span class="line">            FileInfo fileInfo = new FileInfo();</span><br><span class="line">            fileInfo.setFileName(&quot;&quot;);</span><br><span class="line">            fileInfo.setFileType(&quot;&quot;);</span><br><span class="line">            fileInfo.setFileId(&quot;&quot;);</span><br><span class="line">            fileInfo.setCreator(&quot;&quot;);</span><br><span class="line">            return OperateResult.operationSuccess( &quot;存文件成功&quot; );</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return OperateResult.operationFailure( e.getMessage() );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/downFile&quot;)</span><br><span class="line">    public void downloadFile(@RequestParam(name = &quot;file_id&quot;) String fileId,HttpServletRequest request,HttpServletResponse response) throws Exception &#123;</span><br><span class="line">        Query query = Query.query( Criteria.where(&quot;_id&quot;).is(fileId));</span><br><span class="line">        GridFSDBFile gfsfile = gridFsTemplate.findOne(query);</span><br><span class="line">        if (gfsfile == null) &#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String fileName = gfsfile.getFilename().replace(&quot;,&quot;, &quot;&quot;);</span><br><span class="line">        //处理中文文件名乱码</span><br><span class="line">        if (request.getHeader(&quot;User-Agent&quot;).toUpperCase().contains(&quot;MSIE&quot;) ||</span><br><span class="line">                request.getHeader(&quot;User-Agent&quot;).toUpperCase().contains(&quot;TRIDENT&quot;)</span><br><span class="line">                || request.getHeader(&quot;User-Agent&quot;).toUpperCase().contains(&quot;EDGE&quot;)) &#123;</span><br><span class="line">            fileName = java.net.URLEncoder.encode(fileName, &quot;UTF-8&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //非IE浏览器的处理：</span><br><span class="line">            fileName = new String(fileName.getBytes(&quot;UTF-8&quot;), &quot;ISO-8859-1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 通知浏览器进行文件下载</span><br><span class="line">        response.setContentType(gfsfile.getContentType());</span><br><span class="line">        response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=\&quot;&quot; + fileName + &quot;\&quot;&quot;);</span><br><span class="line">        gfsfile.writeTo(response.getOutputStream());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/deleteFile&quot;)</span><br><span class="line">    public OperateResult deleteFile(String fileId)&#123;</span><br><span class="line">        Query query = Query.query(Criteria.where(&quot;_id&quot;).is(fileId));</span><br><span class="line">        // 查询单个文件</span><br><span class="line">        GridFSDBFile gfsfile = gridFsTemplate.findOne(query);</span><br><span class="line">        if (gfsfile == null) &#123;</span><br><span class="line">            return OperateResult.operationFailure( &quot;没有找到文件&quot; );</span><br><span class="line">        &#125;</span><br><span class="line">        gridFsTemplate.delete(query);</span><br><span class="line">        return OperateResult.operationSuccess( &quot;删除成功&quot; );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot创建webService</title>
    <url>/2019/11/20/spring-boot%E5%88%9B%E5%BB%BAwebService/</url>
    <content><![CDATA[<h1 id="Spring-boot-创建webService接口"><a href="#Spring-boot-创建webService接口" class="headerlink" title="Spring boot 创建webService接口"></a>Spring boot 创建webService接口</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li><strong>JDK 1.80_121</strong> </li>
<li><strong>spring boot :2.2.1.RELEASE</strong></li>
<li><strong>cxf-spring-boot-starter-jaxws：3.2.5</strong> </li>
</ul>
<h2 id="创建springboot-项目"><a href="#创建springboot-项目" class="headerlink" title="创建springboot 项目"></a>创建springboot 项目</h2><p>添加gradle依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// https://mvnrepository.com/artifact/org.apache.cxf/cxf-spring-boot-starter-jaxws</span></span><br><span class="line">	compile <span class="string">group:</span> <span class="string">'org.apache.cxf'</span>, <span class="string">name:</span> <span class="string">'cxf-spring-boot-starter-jaxws'</span>, <span class="string">version:</span> <span class="string">'3.2.5'</span></span><br><span class="line"><span class="comment">// https://mvnrepository.com/artifact/org.apache.commons/commons-lang3</span></span><br><span class="line">	compile <span class="string">group:</span> <span class="string">'org.apache.commons'</span>, <span class="string">name:</span> <span class="string">'commons-lang3'</span>, <span class="string">version:</span> <span class="string">'3.4'</span></span><br></pre></td></tr></table></figure>
<p>webService注解图示</p>
<p><img src="/2019/11/20/spring-boot创建webService/webservice.png" alt></p>
<h2 id="创建webService接口"><a href="#创建webService接口" class="headerlink" title="创建webService接口"></a>创建webService接口</h2><h3 id="创建接口"><a href="#创建接口" class="headerlink" title="创建接口"></a>创建接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebService</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WSDemoService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@WebMethod</span></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(@WebParam(name = <span class="string">"friend"</span>)</span> String friend)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建实现类"><a href="#创建实现类" class="headerlink" title="创建实现类"></a>创建实现类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@WebService</span>(name = <span class="string">"demoservice"</span>, targetNamespace = <span class="string">"http://WSDemoService.controller.webdemo1.example.com/"</span> ,endpointInterface = <span class="string">"com.example.webdemo1.controller.WSDemoService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WSDemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">WSDemoService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String friend)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(friend)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Who are you ?"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + friend + <span class="string">"!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注册及发布服务"><a href="#注册及发布服务" class="headerlink" title="注册及发布服务"></a>注册及发布服务</h3><p>这个地方的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.cxf.Bus;</span><br><span class="line"><span class="keyword">import</span> org.apache.cxf.bus.spring.SpringBus;</span><br><span class="line"><span class="keyword">import</span> org.apache.cxf.jaxws.EndpointImpl;</span><br><span class="line"><span class="keyword">import</span> org.apache.cxf.transport.servlet.CXFServlet;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.ws.Endpoint;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> WXY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> WebServiceConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> T0D0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/11/20 1:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebServiceConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"cxfServlet"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">dispatcherServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> CXFServlet(), <span class="string">"/service/*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = Bus.DEFAULT_BUS_ID)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpringBus <span class="title">springBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringBus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WSDemoService demoService; <span class="comment">//由于在实现类中加了@Service因此此处无需初始化实例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注册服务示例*/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Endpoint <span class="title">endpoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EndpointImpl endpoint = <span class="keyword">new</span> EndpointImpl(springBus(), demoService);</span><br><span class="line">        endpoint.publish(<span class="string">"/test"</span>);</span><br><span class="line">        <span class="keyword">return</span> endpoint;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问接口"><a href="#访问接口" class="headerlink" title="访问接口"></a>访问接口</h3><p>启动服务，并本地访问 <em> <a href="http://localhost:8080/service" target="_blank" rel="noopener">http://localhost:8080/service</a> </em>可以查看所有发布的webService接口</p>
<p><img src="/2019/11/20/spring-boot创建webService/serviceShow.png" alt></p>
<h1 id="xml格式数据的webService接口"><a href="#xml格式数据的webService接口" class="headerlink" title="xml格式数据的webService接口"></a>xml格式数据的webService接口</h1><p>​        虽然现在大部分结构数据格式是json,但是和一些老系统对接还是会用到webService这种跨语言的的接口，传输的数据格式也是XML。</p>
<h2 id="在项目中添加依赖"><a href="#在项目中添加依赖" class="headerlink" title="在项目中添加依赖"></a>在项目中添加依赖</h2><p>xml转换使用的工具是XmlMapper工具，</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	xml</span></span><br><span class="line">	compile <span class="string">group:</span> <span class="string">'com.fasterxml.jackson.core'</span>, <span class="string">name:</span> <span class="string">'jackson-core'</span>, <span class="string">version:</span> <span class="string">'2.10.0'</span></span><br><span class="line">	compile <span class="string">group:</span> <span class="string">'com.fasterxml.jackson.core'</span>, <span class="string">name:</span> <span class="string">'jackson-databind'</span>, <span class="string">version:</span> <span class="string">'2.10.0'</span></span><br><span class="line">	compile <span class="string">group:</span> <span class="string">'com.fasterxml.jackson.dataformat'</span>, <span class="string">name:</span> <span class="string">'jackson-dataformat-xml'</span>, <span class="string">version:</span> <span class="string">'2.10.0'</span></span><br></pre></td></tr></table></figure>
<h2 id="XML注解"><a href="#XML注解" class="headerlink" title="XML注解"></a>XML注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JacksonXmlRootElement</span>用于类名，是xml最外层的根节点。注解中有localName属性，该属性如果不设置，那么生成的XML最外面就是Clazz.</span><br><span class="line"><span class="meta">@JacksonXmlCData</span>注解是为了生成&lt;![CDATA[text]]&gt;</span><br><span class="line"><span class="meta">@JacksonXmlProperty</span>注解通常可以不需要，若不用，生成xml标签名称就是实体类属性名称。但是如果你想要你的xml节点名字，首字母大写。比如例子中的Content，那么必须加这个注解，并且注解的localName填上你想要的节点名字。最重要的是！实体类原来的属性content必须首字母小写！否则会被识别成两个不同的属性。注解的isAttribute，确认是否为节点的属性，如上面“gradeId”。</span><br><span class="line"><span class="meta">@JacksonXmlElementWrapper</span>一般用于list，list外层的标签。若不用的话，useWrapping =<span class="keyword">false</span></span><br><span class="line"><span class="meta">@JacksonXmlText</span>，用实体类属性上，说明该属性是否为简单内容，如果是，那么生成xml时，不会生成对应标签名称</span><br><span class="line"><span class="meta">@JsonIgnore</span>，忽略该实体类的属性，该注解是用于实体类转json的，但用于转xml一样有效，具体原因个人推测是XmlMapper是ObjectMapper的子类。</span><br></pre></td></tr></table></figure>
<h2 id="创建XML数据实体"><a href="#创建XML数据实体" class="headerlink" title="创建XML数据实体"></a>创建XML数据实体</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GradeDomain</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JacksonXmlProperty</span>(localName = <span class="string">"gradeId"</span>,isAttribute = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gradeId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JacksonXmlText</span></span><br><span class="line">    <span class="keyword">private</span> String gradeName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getGradeId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gradeId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGradeId</span><span class="params">(<span class="keyword">int</span> gradeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gradeId = gradeId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGradeName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gradeName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGradeName</span><span class="params">(String gradeName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gradeName = gradeName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScoreDomain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JacksonXmlProperty</span>(localName = <span class="string">"scoreName"</span>)</span><br><span class="line">    <span class="meta">@JacksonXmlCData</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JacksonXmlProperty</span>(localName = <span class="string">"scoreNumber"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JacksonXmlRootElement</span>(localName = <span class="string">"student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDomain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String studentName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JacksonXmlProperty</span>(localName = <span class="string">"age"</span>)</span><br><span class="line">    <span class="meta">@JacksonXmlCData</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JacksonXmlProperty</span>(localName = <span class="string">"grade"</span>)</span><br><span class="line">    <span class="keyword">private</span> GradeDomain grade;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JacksonXmlElementWrapper</span>(localName = <span class="string">"scoreList"</span>)</span><br><span class="line">    <span class="meta">@JacksonXmlProperty</span>(localName = <span class="string">"score"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;ScoreDomain&gt; scores;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建服务接口"><a href="#创建服务接口" class="headerlink" title="创建服务接口"></a>创建服务接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebMethod</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> OperateResult <span class="title">dataCheck</span><span class="params">(@WebParam(name = <span class="string">"student"</span>)</span>StudentDomain studentDomain)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="XmlMapper配置属性"><a href="#XmlMapper配置属性" class="headerlink" title="XmlMapper配置属性"></a>XmlMapper配置属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMapper xmlMapper = <span class="keyword">new</span> XmlMapper();</span><br><span class="line"><span class="comment">//反序列化时，若实体类没有对应的属性，是否抛出JsonMappingException异常，false忽略掉</span></span><br><span class="line">xmlMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//序列化是否绕根元素，true，则以类名为根元素</span></span><br><span class="line">xmlMapper.configure(SerializationFeature.WRAP_ROOT_VALUE, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//忽略空属性</span></span><br><span class="line">xmlMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line"><span class="comment">//XML标签名:使用骆驼命名的属性名，</span></span><br><span class="line">xmlMapper.setPropertyNamingStrategy(PropertyNamingStrategy.UPPER_CAMEL_CASE);</span><br><span class="line"><span class="comment">//设置转换模式</span></span><br><span class="line">xmlMapper.enable(MapperFeature.USE_STD_BEAN_NAMING);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public OperateResult dataCheck(StudentDomain studentDomain) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line"></span><br><span class="line">           ObjectMapper xmlMapper = new XmlMapper();</span><br><span class="line">           xmlMapper.configure( DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false );</span><br><span class="line">           xmlMapper.configure( SerializationFeature.WRAP_ROOT_VALUE,false );</span><br><span class="line">           xmlMapper.setSerializationInclusion( JsonInclude.Include.NON_NULL );</span><br><span class="line">           xmlMapper.setPropertyNamingStrategy( PropertyNamingStrategy.UPPER_CAMEL_CASE );</span><br><span class="line">           xmlMapper.enable( MapperFeature.USE_STD_BEAN_NAMING );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           StudentDomain domain = new StudentDomain();</span><br><span class="line">           domain.setStudentName( &quot;张三&quot; );</span><br><span class="line">           domain.setAge( 18 );</span><br><span class="line">           GradeDomain grade = new GradeDomain();</span><br><span class="line">           grade.setGradeId( 1 );</span><br><span class="line">           grade.setGradeName( &quot;高三&quot; );</span><br><span class="line">           domain.setGrade( grade );</span><br><span class="line">           ScoreDomain score1 = new ScoreDomain();</span><br><span class="line">           score1.setName( &quot;语文&quot; );</span><br><span class="line">           score1.setScore( 90 );</span><br><span class="line">           ScoreDomain score2 = new ScoreDomain();</span><br><span class="line">           score2.setName( &quot;数学&quot; );</span><br><span class="line">           score2.setScore( 98 );</span><br><span class="line">           ScoreDomain score3 = new ScoreDomain();</span><br><span class="line">           score3.setName( &quot;英语&quot; );</span><br><span class="line">           score3.setScore( 91 );</span><br><span class="line">           List&lt;ScoreDomain&gt; scores = Arrays.asList( score1,score2,score3 );</span><br><span class="line">           domain.setScores( scores );</span><br><span class="line">           String xml = xmlMapper.writeValueAsString( domain );</span><br><span class="line">           System.out.println( xml );</span><br><span class="line">           StudentDomain studentDomain1 = xmlMapper.readValue( xml,StudentDomain.class );</span><br><span class="line">           System.out.println( studentDomain1 );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           return new OperateResult( &quot;S&quot;,&quot;嘿嘿嘿&quot; );</span><br><span class="line">       &#125;catch (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           return new OperateResult(&quot;F&quot;,&quot;哈哈哈&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>再启动服务调用 <a href="http://localhost:8080/service/test?wsdl" target="_blank" rel="noopener">http://localhost:8080/service/test?wsdl</a> ，可以使用soapui测试接口</p>
<h1 id="生成客户端"><a href="#生成客户端" class="headerlink" title="生成客户端"></a>生成客户端</h1><p> 右键生成的目标包 -&gt; 菜单拉倒最后一个 “WebServices”,输入WSDL生成客户端，<img src="/2019/11/20/spring-boot创建webService/client.png" alt></p>
<p>创建测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       WSDemoServiceImplService service = <span class="keyword">new</span> WSDemoServiceImplService(</span><br><span class="line">               WSDemoServiceImplService.WSDEMOSERVICEIMPLSERVICE_WSDL_LOCATION,</span><br><span class="line">               WSDemoServiceImplService.WSDEMOSERVICEIMPLSERVICE_QNAME);</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">"下面是hello打印的数据"</span>);</span><br><span class="line">       System.out.println(service.getDemoservicePort().hello(<span class="string">"haha"</span>));</span><br><span class="line">       System.out.println(<span class="string">"下面是dataCheck打印的数据"</span>);</span><br><span class="line">       OperateResult operateResult = service.getDemoservicePort().dataCheck( <span class="keyword">null</span> );</span><br><span class="line">       System.out.println(service.getDemoservicePort().dataCheck( <span class="keyword">null</span> ));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>关于webService整理就到这了.. </p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>webService</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot集成zookeeper</title>
    <url>/2020/07/14/spring-boot%E9%9B%86%E6%88%90zookeeper/</url>
    <content><![CDATA[<p>搭建Zookeeper的步骤就不多赘述了，可以看另一篇文章</p>
<p>服务分为三个模块 </p>
<p><img src="/2020/07/14/spring-boot集成zookeeper/struct.png" alt="struct"></p>
<p>zookeeper-api是公共接口模块，实际项目中一般是在服务模块中将公共API部分打包，消费者引包来使用，这里简化就直接新建的一个gradle项目。</p>
<h1 id="zookeeper-demo"><a href="#zookeeper-demo" class="headerlink" title="zookeeper-demo"></a>zookeeper-demo</h1><p><img src="/2020/07/14/spring-boot集成zookeeper/newProject.png" alt></p>
<p>这里贴出项目的依赖部分</p>
<p>父层的 build.gradle,主要配置了子项目的公共依赖部分和通用配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subprojects &#123;</span><br><span class="line"></span><br><span class="line">    apply plugin: &apos;java&apos;</span><br><span class="line">    apply plugin: &apos;idea&apos;</span><br><span class="line">    apply plugin: &apos;maven&apos;</span><br><span class="line">    apply plugin: &apos;eclipse&apos;</span><br><span class="line"></span><br><span class="line">    // JVM 版本号要求</span><br><span class="line">    sourceCompatibility = 1.8</span><br><span class="line">    targetCompatibility = 1.8</span><br><span class="line"></span><br><span class="line">    // java编译的时候缺省状态下会因为中文字符而失败</span><br><span class="line">    [compileJava, compileTestJava, javadoc]*.options*.encoding = &apos;UTF-8&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    buildscript &#123;</span><br><span class="line">        repositories &#123;</span><br><span class="line">            maven &#123; url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos; &#125;</span><br><span class="line">            maven &#123; url &apos;http://maven.aliyun.com/nexus/content/repositories/jcenter&apos; &#125;</span><br><span class="line">            maven &#123; url &apos;http://maven.aliyun.com/repository/google&apos; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dependencies &#123;</span><br><span class="line">            classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:2.0.5.RELEASE&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos; &#125;</span><br><span class="line">        maven &#123; url &apos;http://maven.aliyun.com/nexus/content/repositories/jcenter&apos; &#125;</span><br><span class="line">        maven &#123; url &apos;http://maven.aliyun.com/repository/google&apos; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line"></span><br><span class="line">        compile group: &apos;org.projectlombok&apos;, name: &apos;lombok&apos;, version: &apos;1.18.12&apos;</span><br><span class="line">		//这个版本最好和你的zookeeper版本对应</span><br><span class="line">        compile group: &apos;org.apache.zookeeper&apos;, name: &apos;zookeeper&apos;, version: &apos;3.4.12&apos;</span><br><span class="line">        compile  &apos;com.alibaba.boot:dubbo-spring-boot-starter:0.2.0&apos;</span><br><span class="line"></span><br><span class="line">        compile &apos;org.springframework.boot:spring-boot-starter-web:2.0.5.RELEASE&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="zookeeper-api"><a href="#zookeeper-api" class="headerlink" title="zookeeper-api"></a>zookeeper-api</h1><p>创建公共API部分</p>
<p><img src="/2020/07/14/spring-boot集成zookeeper/api-module.png" alt></p>
<p><img src="/2020/07/14/spring-boot集成zookeeper/api-info.png" alt></p>
<p>项目结构如下</p>
<p><img src="/2020/07/14/spring-boot集成zookeeper/api-struct.png" alt="api-struct"></p>
<p>在项目下创建package 并创建一个HelloDubboApi接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface HelloDubboApi &#123;</span><br><span class="line">    String hello(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="zookeeper-provider"><a href="#zookeeper-provider" class="headerlink" title="zookeeper-provider"></a>zookeeper-provider</h1><p>同理，重复上述步骤创建服务提供者模块</p>
<p><img src="/2020/07/14/spring-boot集成zookeeper/provider-struct.png" alt></p>
<p>zookeeper-provider的build.gradle文件如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id &apos;org.springframework.boot&apos; version &apos;2.0.5.RELEASE&apos;</span><br><span class="line">    id &apos;io.spring.dependency-management&apos; version &apos;1.0.9.RELEASE&apos;</span><br><span class="line">    id &apos;java&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sourceCompatibility = &apos;1.8&apos;</span><br><span class="line">group &apos;org.zookeeper&apos;</span><br><span class="line">version &apos;0.0.1&apos;</span><br><span class="line"></span><br><span class="line">sourceCompatibility = 1.8</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">//    testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;</span><br><span class="line">    compile project(&apos;:zookeeper-api&apos;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HelloDubboImpl实现类</p>
<p>需要注意的是@Service是alibaba.dubbo下的一个注解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.zookeeper.provider.impl;</span><br><span class="line"></span><br><span class="line">import com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line">import com.zookeeper.api.HelloDubboApi;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Component</span><br><span class="line">public class HelloDubboImpl implements HelloDubboApi &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String hello(String name) &#123;</span><br><span class="line">        return &quot;dubbo测试&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改启动类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@EnableDubbo</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ProviderApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改配置文件application.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server.port=9000</span><br><span class="line"></span><br><span class="line">#注册名字</span><br><span class="line">dubbo.application.name=provider-demo</span><br><span class="line"></span><br><span class="line">#zk注册中心地址</span><br><span class="line">dubbo.registry.address=zookeeper://你的zookeeper地址:端口</span><br><span class="line">#通讯规则 端口 协议</span><br><span class="line">dubbo.protocol.port=20881</span><br><span class="line">dubbo.protocol.name=dubbo</span><br></pre></td></tr></table></figure>
<h1 id="zookeeper-consumer"><a href="#zookeeper-consumer" class="headerlink" title="zookeeper-consumer"></a>zookeeper-consumer</h1><p>项目的结构如下</p>
<p><img src="/2020/07/14/spring-boot集成zookeeper/consumer-struct.png" alt="consumer-struct"></p>
<p>build.gradle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id &apos;org.springframework.boot&apos; version &apos;2.0.5.RELEASE&apos;</span><br><span class="line">    id &apos;io.spring.dependency-management&apos; version &apos;1.0.9.RELEASE&apos;</span><br><span class="line">    id &apos;java&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sourceCompatibility = &apos;1.8&apos;</span><br><span class="line">group &apos;org.zookeeper&apos;</span><br><span class="line">version &apos;0.0.1&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile project(&apos;:zookeeper-api&apos;)</span><br><span class="line">    testImplementation(&apos;org.springframework.boot:spring-boot-starter-test&apos;) &#123;</span><br><span class="line">        exclude group: &apos;org.junit.vintage&apos;, module: &apos;junit-vintage-engine&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    compile ( &apos;org.apache.zookeeper:zookeeper:3.4.12&apos;)&#123;</span><br><span class="line">        exclude  group:&apos;org.slf4j&apos;,module:&apos;slf4j-log4j12&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HelloController</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @Reference</span><br><span class="line">    private HelloDubboApi helloDubboApi;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;hello&quot;)</span><br><span class="line">    public String getHello(String name)&#123;</span><br><span class="line">        return helloDubboApi.hello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConsumerApplication</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableDubbo</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ConsumerApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>application.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dubbo.application.name=consumer</span><br><span class="line">dubbo.registry.address=zookeeper://你的zookeeper地址:端口</span><br><span class="line">server.port=9001</span><br></pre></td></tr></table></figure>
<p> 项目构建完成之后，启动zookeeper-provider 和 zookeeper-consumer</p>
<p>在zookeeperInspector 工具查看</p>
<p><img src="/2020/07/14/spring-boot集成zookeeper/route.png" alt="route"></p>
<p>一个简单的demo就这样完成了。</p>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud-aliba 服务注册</title>
    <url>/2019/12/03/spring-cloud-aliba-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<h1 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h1><p> Nacos致力于帮助您发现、配置和管理微服务。Nacos提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。Nacos帮助您更敏捷和容易地构建、交付和管理微服务平台。Nacos是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施 </p>
<p><a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">nacos下载地址</a></p>
<p>我下载的版本是1.1.4</p>
<p> 下载完成之后，解压。根据不同平台，执行不同命令，启动单机版Nacos服务： </p>
<ul>
<li>Linux/Unix/Mac：<code>sh startup.sh -m standalone</code></li>
<li><p>Windows：<code>cmd startup.cmd -m standalone</code></p>
<p><code>startup.sh</code>脚本位于Nacos解压后的bin目录下。这里主要介绍Spring Cloud与Nacos的集成使用，对于Nacos的高级配置，后续再补充。 启动完成之后，访问：<code>http://127.0.0.1:8848/nacos/</code>，可以进入Nacos的服务管理页面， 出现登录页面，默认用户名密码为：nacos </p>
</li>
</ul>
<h2 id="构建应用接入Nacos注册中心"><a href="#构建应用接入Nacos注册中心" class="headerlink" title="构建应用接入Nacos注册中心"></a>构建应用接入Nacos注册中心</h2><p> 在完成了Nacos服务的安装和启动之后，下面我们就可以编写两个应用（服务提供者与服务消费者）来验证服务的注册与发现了。 </p>
<h3 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h3><p> <strong>第一步</strong>：创建一个Spring Boot应用，可以命名为：<code>alibaba-nacos-discovery-server</code> </p>
<p>引入依赖,这两个依赖还没有在spring cloud 官方版本，所以需要手动引入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ali depence</span><br><span class="line">compile group: &apos;com.alibaba.cloud&apos;, name: &apos;spring-cloud-starter-alibaba-nacos-discovery&apos;, version: &apos;2.1.0.RELEASE&apos;</span><br><span class="line"></span><br><span class="line">// https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-alibaba-nacos-discovery</span><br><span class="line">compile group: &apos;org.springframework.cloud&apos;, name: &apos;spring-cloud-starter-alibaba-nacos-discovery&apos;, version: &apos;0.9.0.RELEASE&apos;</span><br></pre></td></tr></table></figure>
<p>在启动类上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlibabaNacosDiscoveryServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(AlibabaNacosDiscoveryServerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个服务提供方法类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在配置文件application.properties中配置服务名称和Nacos地址 </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">alibaba-nacos-discovery-server</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8001</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">localhost:8848</span></span><br><span class="line"><span class="meta">spring.main.allow-bean-definition-overriding</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<p>启动服务，这个时候可以在 <a href="http://127.0.0.1:8848/nacos/" target="_blank" rel="noopener">http://127.0.0.1:8848/nacos/</a> 服务列表上看见</p>
<p><img src="/2019/12/03/spring-cloud-aliba-服务注册/server.png" alt></p>
<h3 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h3><p>创建一个Spring Boot应用，命名为：<code>alibaba-nacos-discovery-client-common</code>。引入依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'org.springframework.boot:spring-boot-starter-web'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ali depence</span></span><br><span class="line">compile <span class="string">group:</span> <span class="string">'com.alibaba.cloud'</span>, <span class="string">name:</span> <span class="string">'spring-cloud-starter-alibaba-nacos-discovery'</span>, <span class="string">version:</span> <span class="string">'2.1.0.RELEASE'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-alibaba-nacos-discovery</span></span><br><span class="line">compile <span class="string">group:</span> <span class="string">'org.springframework.cloud'</span>, <span class="string">name:</span> <span class="string">'spring-cloud-starter-alibaba-nacos-discovery'</span>, <span class="string">version:</span> <span class="string">'0.9.0.RELEASE'</span></span><br></pre></td></tr></table></figure>
<p>在启动类上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlibabaNacosDiscoveryClientCommonApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(AlibabaNacosDiscoveryClientCommonApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@RestController</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//负载均衡</span></span><br><span class="line">		<span class="meta">@Autowired</span></span><br><span class="line">		LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@LoadBalanced</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@LoadBalanced</span></span><br><span class="line">		<span class="keyword">public</span> WebClient.<span class="function">Builder <span class="title">loadBalancedWebClientBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> WebClient.builder();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建服务消费方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TestInterface testInterface;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebClient.Builder webClientBuilder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过spring cloud common中的负载均衡接口选取服务提供节点实现接口调用</span></span><br><span class="line">        ServiceInstance serviceInstance = loadBalancerClient.choose(<span class="string">"alibaba-nacos-discovery-server"</span>);</span><br><span class="line">        String url = serviceInstance.getUri() + <span class="string">"/hello?name="</span> + <span class="string">"panghu"</span>;</span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        String result = restTemplate.getForObject(url, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Invoke : "</span> + url + <span class="string">", return : "</span> + result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = restTemplate.getForObject(<span class="string">"http://alibaba-nacos-discovery-server/hello?name=panghu"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Return : "</span> + result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test3"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Mono&lt;String&gt; result = webClientBuilder.build()</span><br><span class="line">                .get()</span><br><span class="line">                .uri(<span class="string">"http://alibaba-nacos-discovery-server/hello?name=panghu"</span>)</span><br><span class="line">                .retrieve()</span><br><span class="line">                .bodyToMono(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test4"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = testInterface.hello(<span class="string">"panghu"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Return : "</span> + result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建fegin的调用接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"alibaba-nacos-discovery-server"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(@RequestParam(name = <span class="string">"name"</span>)</span> String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候启动消费者、提供者，在本地输入 <a href="http://localhost:8003/test1" target="_blank" rel="noopener">http://localhost:8003/test1</a>, <a href="http://localhost:8003/test2" target="_blank" rel="noopener">http://localhost:8003/test2</a> , <a href="http://localhost:8003/test3" target="_blank" rel="noopener">http://localhost:8003/test3</a> , <a href="http://localhost:8003/test4" target="_blank" rel="noopener">http://localhost:8003/test4</a> .使用不同的方法调用服务。</p>
<h1 id="使用nacos构建配置中心"><a href="#使用nacos构建配置中心" class="headerlink" title="使用nacos构建配置中心"></a>使用nacos构建配置中心</h1><p>Nacos除了实现了服务的注册发现之外，还将配置中心功能整合在了一起。通过Nacos的配置管理功能，我们可以将整个架构体系内的所有配置都集中在Nacos中存储。这样做的好处，在以往的教程中介绍Spring Cloud Config时也有提到，主要有以下几点：</p>
<ul>
<li>分离的多环境配置，可以更灵活的管理权限，安全性更高</li>
<li>应用程序的打包更为纯粹，以实现一次打包，多处运行的特点</li>
</ul>
<h2 id="创建配置"><a href="#创建配置" class="headerlink" title="创建配置"></a>创建配置</h2><p> 第一步：进入Nacos的控制页面，在配置列表功能页面中，点击右上角的“+”按钮，进入“新建配置”页面，如下图填写内容： </p>
<p><img src="/2019/12/03/spring-cloud-aliba-服务注册/config.png" alt></p>
<p>其中：</p>
<ul>
<li><code>Data ID</code>：填入<code>alibaba-nacos-config-client.properties</code></li>
<li><code>Group</code>：不修改，使用默认值<code>DEFAULT_GROUP</code></li>
<li><code>配置格式</code>：选择<code>Properties</code></li>
<li><code>配置内容</code>：应用要加载的配置内容，这里仅作为示例，做简单配置，比如：<code>panghu.title.title=spring-cloud-alibaba-learning</code></li>
</ul>
<h2 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h2><p>引入依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://mvnrepository.com/artifact/com.alibaba.cloud/spring-cloud-starter-alibaba-nacos-config</span></span><br><span class="line">compile <span class="string">group:</span> <span class="string">'com.alibaba.cloud'</span>, <span class="string">name:</span> <span class="string">'spring-cloud-starter-alibaba-nacos-config'</span>, <span class="string">version:</span> <span class="string">'2.1.0.RELEASE'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ali depence</span></span><br><span class="line">compile <span class="string">group:</span> <span class="string">'com.alibaba.cloud'</span>, <span class="string">name:</span> <span class="string">'spring-cloud-starter-alibaba-nacos-discovery'</span>, <span class="string">version:</span> <span class="string">'2.1.0.RELEASE'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-alibaba-nacos-discovery</span></span><br><span class="line">compile <span class="string">group:</span> <span class="string">'org.springframework.cloud'</span>, <span class="string">name:</span> <span class="string">'spring-cloud-starter-alibaba-nacos-discovery'</span>, <span class="string">version:</span> <span class="string">'0.9.0.RELEASE'</span></span><br></pre></td></tr></table></figure>
<p> 在启动类应中实现一个HTTP接口验证配置文件加载是否成功</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlibabaNacosConfigClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(AlibabaNacosConfigClientApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RestController</span></span><br><span class="line">	<span class="meta">@RefreshScope</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Value</span>(<span class="string">"$&#123;panghu.title:&#125;"</span>)</span><br><span class="line">		<span class="keyword">private</span> String title;</span><br><span class="line">		<span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> title;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>内容非常简单，`@SpringBootApplication`定义是个Spring Boot应用；还定义了一个Controller，其中通过`@Value`注解，注入了key为panghu.title`的配置（默认为空字符串），这个配置会通过`/test`接口返回，后续我们会通过这个接口来验证Nacos中配置的加载。另外，这里还有一个比较重要的注解`@RefreshScope`，主要用来让这个类下的配置内容支持动态刷新，也就是当我们的应用启动之后，修改了Nacos中的配置内容之后，这里也会马上生效。 
</code></pre><p>​        创建配置文件<code>bootstrap.properties</code>，并配置服务名称和Nacos地址 ，SpringCloudConfig和 NacosConfig这种统一配置服务在springboot项目中初始化时，都是加载bootstrap.properties配置文件去初始化上下文。这是由spring boot的加载属性文件的优先级决定的，想要在加载属性之前去config server上取配置文件，NacosConfig或SpringCloudConfig相关配置就是需要最先加载的，而bootstrap.properties的加载是先application.properties的，所以config client要配置config的相关配置就只能写到bootstrap.properties里了</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">alibaba-nacos-config-client</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8001</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="meta">spring.main.allow-bean-definition-overriding</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br></pre></td></tr></table></figure>
<p>启动服务后访问 <a href="http://localhost:8001/test" target="_blank" rel="noopener">http://localhost:8001/test</a> ，显示页面如下所示</p>
<p><img src="/2019/12/03/spring-cloud-aliba-服务注册/config-server.png" alt></p>
<h1 id="Nacos配置的加载规则详解"><a href="#Nacos配置的加载规则详解" class="headerlink" title="Nacos配置的加载规则详解"></a>Nacos配置的加载规则详解</h1><p>，Nacos中创建的配置内容是这样的：</p>
<ul>
<li><code>Data ID</code>：alibaba-nacos-config-client.properties</li>
<li><code>Group</code>：DEFAULT_GROUP</li>
</ul>
<p>拆解一下，主要有三个元素，它们与具体应用的配置内容对应关系如下：</p>
<ul>
<li>Data ID中的<code>alibaba-nacos-config-client</code>：对应客户端的配置<code>spring.cloud.nacos.config.prefix</code>，默认值为<code>${spring.application.name}</code>，即：服务名</li>
<li>Data ID中的<code>properties</code>：对应客户端的配置<code>spring.cloud.nacos.config.file-extension</code>，默认值为<code>properties</code></li>
<li>Group的值<code>DEFAULT_GROUP</code>：对应客户端的配置<code>spring.cloud.nacos.config.group</code>，默认值为<code>DEFAULT_GROUP</code></li>
</ul>
<p>在采用默认值的应用要加载的配置规则就是：<code>Data ID=${spring.application.name}.properties</code>，<code>Group=DEFAULT_GROUP</code>。</p>
<p>下面，我们做一些假设例子，方便大家理解这些配置之间的关系：</p>
<p><strong>例子一</strong>：如果我们不想通过服务名来加载，那么可以增加如下配置，就会加载到<code>Data ID=example.properties</code>，<code>Group=DEFAULT_GROUP</code>的配置内容了：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.prefix</span>=<span class="string">example</span></span><br></pre></td></tr></table></figure>
<p><strong>例子二</strong>：如果我们想要加载yaml格式的内容，而不是Properties格式的内容，那么可以通过如下配置，实现加载<code>Data ID=example.yaml</code>，<code>Group=DEFAULT_GROUP</code>的配置内容了：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.prefix</span>=<span class="string">example</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.file-extension</span>=<span class="string">yaml</span></span><br></pre></td></tr></table></figure>
<p><strong>例子三</strong>：如果我们对配置做了分组管理，那么可以通过如下配置，实现加载<code>Data ID=example.yaml</code>，<code>Group=DEV_GROUP</code>的配置内容了：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.prefix</span>=<span class="string">example</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.file-extension</span>=<span class="string">yaml</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.group</span>=<span class="string">DEV_GROUP</span></span><br></pre></td></tr></table></figure>
<h2 id="多环境管理"><a href="#多环境管理" class="headerlink" title="多环境管理"></a>多环境管理</h2><p> 在Nacos中，本身有多个不同管理级别的概念，包括：<code>Data ID</code>、<code>Group</code>、<code>Namespace</code>。只要利用好这些层级概念的关系，就可以根据自己的需要来实现多环境的管理。 </p>
<p><code>Data ID</code>在Nacos中，我们可以理解为就是一个Spring Cloud应用的配置文件名,我们知道默认情况下<code>Data ID</code>的名称格式是这样的：<code>${spring.application.name}.properties</code>，即：以Spring Cloud应用命名的properties文件。</p>
<p>实际上，<code>Data ID</code>的规则中，还包含了环境逻辑，这一点与Spring Cloud Config的设计类似。我们在应用启动时，可以通过<code>spring.profiles.active</code>来指定具体的环境名称，此时客户端就会把要获取配置的<code>Data ID</code>组织为：<code>${spring.application.name}-${spring.profiles.active}.properties</code>。</p>
<p> 实际上，更原始且最通用的匹配规则，是这样的：<code>${spring.cloud.nacos.config.prefix}</code>-<code>${spring.profile.active}</code>.<code>${spring.cloud.nacos.config.file-extension}</code>。而上面的结果是因为<code>${spring.cloud.nacos.config.prefix}</code>和<code>${spring.cloud.nacos.config.file-extension}</code>都使用了默认值。 </p>
<h3 id="使用后缀实现"><a href="#使用后缀实现" class="headerlink" title="使用后缀实现"></a>使用后缀实现</h3><p>测试在nacos中创建一个新的配置文件 alibaba-nacos-config-client-dev.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">panghu.title</span>=<span class="string">7654321</span></span><br></pre></td></tr></table></figure>
<p>在配置文件中添加spring.profiles.active=dev，</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">alibaba-nacos-config-client</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8001</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="meta">spring.main.allow-bean-definition-overriding</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#spring.cloud.nacos.config.prefix=example</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure>
<p>重新启动服务，访问 <a href="http://localhost:8001/test" target="_blank" rel="noopener">http://localhost:8001/test</a> 可以发现打印出的结果是7654321</p>
<h3 id="使用Group实现"><a href="#使用Group实现" class="headerlink" title="使用Group实现"></a>使用<code>Group</code>实现</h3><p>测试在nacos中创建一个新的配置文件 alibaba-nacos-config-client.properties</p>
<p><img src="/2019/12/03/spring-cloud-aliba-服务注册/config-group.png" alt></p>
<p>在配置文件中添加</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">alibaba-nacos-config-client</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8001</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="meta">spring.main.allow-bean-definition-overriding</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#spring.cloud.nacos.config.prefix=example</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.group</span>=<span class="string">DEV_GROUP</span></span><br></pre></td></tr></table></figure>
<p>再次重新启动服务，访问 <a href="http://localhost:8001/test" target="_blank" rel="noopener">http://localhost:8001/test</a> 可以发现打印出的结果是1234567</p>
<h3 id="使用Namespace实现"><a href="#使用Namespace实现" class="headerlink" title="使用Namespace实现"></a>使用<code>Namespace</code>实现</h3><p> <strong>第一步</strong>：先在Nacos中，根据环境名称来创建多个<code>Namespace</code>。比如： </p>
<p><img src="/2019/12/03/spring-cloud-aliba-服务注册/namespace.png" alt></p>
<p>在dev分支下创建配置文件</p>
<p><img src="/2019/12/03/spring-cloud-aliba-服务注册/namespace-dev.png" alt></p>
<p>在启动的配置文件中添加</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.namespace</span>=<span class="string">d8b4a958-e2e8-4ed7-be64-69646aeb42c0</span></span><br></pre></td></tr></table></figure>
<p> 分别利用Nacos配置管理功能中的几个不同纬度来实现多环境的配置管理。</p>
<h2 id="加载多个配置文件"><a href="#加载多个配置文件" class="headerlink" title="加载多个配置文件"></a>加载多个配置文件</h2><p>在配置中心添加两个配置文件</p>
<p>a.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">a.name</span>=<span class="string">a</span></span><br></pre></td></tr></table></figure>
<p>b.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">b.name</span>=<span class="string">b</span></span><br></pre></td></tr></table></figure>
<p>在springBoot的配置文件中添加</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[0].dataId</span>=<span class="string">a.properties</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[0].group</span>=<span class="string">DEFAULT_GROUP</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[0].refresh</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[1].data-id</span>=<span class="string">b.properties</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[1].group</span>=<span class="string">DEFAULT_GROUP</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[1].refresh</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<p>修改测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"$&#123;panghu.title:&#125;"</span>)</span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Value</span>( <span class="string">"$&#123;a.name:&#125;"</span> )</span><br><span class="line">	<span class="keyword">private</span> String aname;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Value</span>( <span class="string">"$&#123;b.name:&#125;"</span> )</span><br><span class="line">	<span class="keyword">private</span> String bname;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> title+<span class="string">"_____a:"</span>+aname+<span class="string">"_____b:"</span>+bname;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启服务访问<a href="http://localhost:8001/test" target="_blank" rel="noopener">http://localhost:8001/test</a> 可以发现打印出的结果是 spring-cloud-alibaba-learning_____a:a_____b:b </p>
<h2 id="共享配置"><a href="#共享配置" class="headerlink" title="共享配置"></a>共享配置</h2><p>通过上面加载多个配置的实现，实际上我们已经可以实现不同应用共享配置了。但是Nacos中还提供了另外一个便捷的配置方式，比如下面的设置与上面使用的配置内容是等价的：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.shared-dataids</span>=<span class="string">actuator.properties,log.properties</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.refreshable-dataids</span>=<span class="string">actuator.properties,log.properties</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>spring.cloud.nacos.config.shared-dataids</code>参数用来配置多个共享配置的<code>Data Id</code>，多个的时候用用逗号分隔</li>
<li><code>spring.cloud.nacos.config.refreshable-dataids</code>参数用来定义哪些共享配置的<code>Data Id</code>在配置变化时，应用中可以动态刷新，多个<code>Data Id</code>之间用逗号隔开。如果没有明确配置，默认情况下所有共享配置都不支持动态刷新</li>
</ul>
<h2 id="配置加载的优先级"><a href="#配置加载的优先级" class="headerlink" title="配置加载的优先级"></a>配置加载的优先级</h2><p>当我们加载多个配置的时候，如果存在相同的key时，我们需要深入了解配置加载的优先级关系。</p>
<p>在使用Nacos配置的时候，主要有以下三类配置：</p>
<ul>
<li>A: 通过<code>spring.cloud.nacos.config.shared-dataids</code>定义的共享配置</li>
<li>B: 通过<code>spring.cloud.nacos.config.ext-config[n]</code>定义的加载配置</li>
<li>C: 通过内部规则（<code>spring.cloud.nacos.config.prefix</code>、<code>spring.cloud.nacos.config.file-extension</code>、<code>spring.cloud.nacos.config.group</code>这几个参数）拼接出来的配置</li>
</ul>
<p>要弄清楚这几个配置加载的顺序，我们从日志中也可以很清晰的看到，我们可以做一个简单的实验：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[0].data-id</span>=<span class="string">a.properties</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[0].group</span>=<span class="string">DEFAULT_GROUP</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[0].refresh</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.shared-dataids</span>=<span class="string">b.properties</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.refreshable-dataids</span>=<span class="string">b.properties</span></span><br></pre></td></tr></table></figure>
<p>这个配置文件的加载顺寻是 A &lt; B &lt; C </p>
<h1 id="Nacos的数据持久化"><a href="#Nacos的数据持久化" class="headerlink" title="Nacos的数据持久化"></a>Nacos的数据持久化</h1><p>在搭建Nacos集群之前，我们需要先修改Nacos的数据持久化配置为MySQL存储。默认情况下，Nacos使用嵌入式数据库实现数据的存储。所以，如果启动多个默认配置下的Nacos节点，数据存储是存在一致性问题的。为了解决这个问题，Nacos采用了集中式存储的方式来支持集群化部署，目前只要支持MySQL的存储。</p>
<p>配置Nacos的MySQL存储只需要下面三步：</p>
<p><strong>第一步</strong>：安装数据库，版本要求：5.6.5+</p>
<p><strong>第二步</strong>：初始化MySQL数据库，数据库初始化文件：<code>nacos-mysql.sql</code>，该文件可以在Nacos程序包下的<code>conf</code>目录下获得。</p>
<p> <strong>第三步</strong>：修改<code>conf/application.properties</code>文件，增加支持MySQL数据源配置，添加（目前只支持mysql）数据源的url、用户名和密码。配置样例如下： </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="meta">db.num</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">db.url.0</span>=<span class="string">jdbc:mysql://localhost:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span></span><br><span class="line"><span class="meta">db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">db.password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>
<h4 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h4><p>在Nacos的<code>conf</code>目录下有一个<code>cluster.conf.example</code>，可以直接把<code>example</code>扩展名去掉来使用，也可以单独创建一个<code>cluster.conf</code>文件，然后打开将后续要部署的Nacos实例地址配置在这里。</p>
<p>本文以在本地不同端点启动3个Nacos服务端为例，可以如下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:8841</span><br><span class="line">127.0.0.1:8842</span><br><span class="line">127.0.0.1:8843</span><br></pre></td></tr></table></figure>
<p> 在完成了上面的配置之后，我们就可以开始在各个节点上启动Nacos实例，以组建Nacos集群来使用了。 </p>
<p>本文中，在集群配置的时候，我们设定了3个Nacos的实例都在本地，只是以不同的端口区分，所以我们在启动Nacos的时候，需要修改不同的端口号。</p>
<p>下面介绍一种方法来方便地启动Nacos的三个本地实例，我们可以将bin目录下的<code>startup.sh</code>脚本复制三份，分别用来启动三个不同端口的Nacos实例，为了可以方便区分不同实例的启动脚本，我们可以把端口号加入到脚本的命名中，比如：</p>
<ul>
<li>startup-8841.sh</li>
<li>startup-8842.sh</li>
<li><p>startup-8843.sh</p>
<p>然后，分别修改这三个脚本中的参数，具体如下图的红色部分（端口号根据上面脚本命名分配）： </p>
</li>
</ul>
<p><img src="/2019/12/03/spring-cloud-aliba-服务注册/C:/Program Files\blog\source\_posts\spring-cloud-aliba-服务注册\sh.png" alt></p>
<h4 id="Proxy配置"><a href="#Proxy配置" class="headerlink" title="Proxy配置"></a>Proxy配置</h4><p>在Nacos的集群启动完毕之后，根据架构图所示，我们还需要提供一个统一的入口给我们用来维护以及给Spring Cloud应用访问。简单地说，就是我们需要为上面启动的的三个Nacos实例做一个可以为它们实现负载均衡的访问点。这个实现的方式非常多，这里就举个用Nginx来实现的简单例子吧。</p>
<p>在Nginx配置文件的http段中，我们可以加入下面的配置内容：</p>
<p><img src="/2019/12/03/spring-cloud-aliba-服务注册/C:/Program Files\blog\source\_posts\spring-cloud-aliba-服务注册\nginx.png" alt></p>
]]></content>
      <categories>
        <category>spring cloud alibaba</category>
      </categories>
      <tags>
        <tag>nacos</tag>
        <tag>spring cloud alibaba</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud-ali sentinel接口限流</title>
    <url>/2019/12/08/spring-cloud-ali-sentinel%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<h1 id="Sentinel是什么"><a href="#Sentinel是什么" class="headerlink" title="Sentinel是什么"></a>Sentinel是什么</h1><p>​        Sentinel的官方标题是：分布式系统的流量防卫兵。从名字上来看，很容易就能猜到它是用来作服务稳定性保障的。对于服务稳定性保障组件，如果熟悉Spring Cloud的用户，第一反应应该就是Hystrix。但是比较可惜的是Netflix已经宣布对Hystrix停止更新。那么，在未来我们还有什么更好的选择呢？除了Spring Cloud官方推荐的resilience4j之外，目前Spring Cloud Alibaba下整合的Sentinel也是用户可以重点考察和选型的目标。 </p>
<h1 id="使用Sentinel实现接口限流"><a href="#使用Sentinel实现接口限流" class="headerlink" title="使用Sentinel实现接口限流"></a>使用Sentinel实现接口限流</h1><p> Sentinel的使用分为两部分： </p>
<ul>
<li>sentinel-dashboard：与hystrix-dashboard类似，但是它更为强大一些。除了与hystrix-dashboard一样提供实时监控之外，还提供了流控规则、熔断规则的在线维护等功能。</li>
<li>客户端整合：每个微服务客户端都需要整合sentinel的客户端封装与配置，才能将监控信息上报给dashboard展示以及实时的更改限流或熔断规则等。</li>
</ul>
<h3 id="部署Sentinel-Dashboard"><a href="#部署Sentinel-Dashboard" class="headerlink" title="部署Sentinel Dashboard"></a>部署Sentinel Dashboard</h3><p><a href="https://github.com/alibaba/Sentinel/releases" target="_blank" rel="noopener">下载地址</a> </p>
<p>下载到本地以后可以直接启动</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">java -jar sentinel-dashboard<span class="number">-1.6</span><span class="number">.0</span>.jar</span><br></pre></td></tr></table></figure>
<p>sentinel-dashboard不像Nacos的服务端那样提供了外置的配置文件，比较容易修改参数。不过不要紧，由于sentinel-dashboard是一个标准的spring boot应用，所以如果要自定义端口号等内容的话，可以通过在启动命令中增加参数来调整，比如：<code>-Dserver.port=8888</code>。</p>
<p>默认情况下，sentinel-dashboard以8080端口启动，所以可以通过访问：<code>localhost:8080</code>来验证是否已经启动成功. 默认用户名和密码都是<code>sentinel</code> </p>
<p>对于用户登录的相关配置可以在启动命令中增加下面的参数来进行配置：</p>
<ul>
<li><code>-Dsentinel.dashboard.auth.username=sentinel</code>: 用于指定控制台的登录用户名为 sentinel；</li>
<li><code>-Dsentinel.dashboard.auth.password=123456</code>: 用于指定控制台的登录密码为 123456；如果省略这两个参数，默认用户和密码均为 sentinel</li>
<li><code>-Dserver.servlet.session.timeout=7200</code>: 用于指定 Spring Boot 服务端 session 的过期时间，如 7200 表示 7200 秒；60m 表示 60 分钟，默认为 30 分钟；</li>
</ul>
<p>我是在阿里云上运行的，运行的命令是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后台启动的命令 </span></span><br><span class="line">nohup java -jar sentinel-dashboard<span class="number">-1.6</span><span class="number">.0</span>.jar &gt;consoleMsg.<span class="built_in">log</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br><span class="line"><span class="comment">//查看jar进程的命令</span></span><br><span class="line">ps aux|grep sentinel-dashboard<span class="number">-1.6</span><span class="number">.0</span>.jar</span><br><span class="line"><span class="comment">//杀死进程</span></span><br><span class="line">kill <span class="number">-9</span> <span class="number">30768</span></span><br><span class="line"><span class="comment">//查看日志</span></span><br><span class="line">cat xxx.<span class="built_in">log</span>  日志中有报错信息</span><br><span class="line"><span class="comment">//清空日志</span></span><br><span class="line">echo <span class="string">" "</span> &gt;xxx.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p> nohup命令的作用就是让程序在后台运行，不用担心关闭连接进程断掉的问题了， 并且将标准输出的日志重定向至文件consoleMsg.log ,consoleMsg.log文件前提要创建好的,这个log文件最好跟jar包放一起 。 </p>
<h1 id="整合Sentinel"><a href="#整合Sentinel" class="headerlink" title="整合Sentinel"></a>整合Sentinel</h1><p>创建一个新的springboot服务，命名为alibaba-sentinel-test1，添加依赖项</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sentinel</span></span><br><span class="line">compile <span class="string">group:</span> <span class="string">'com.alibaba.cloud'</span>, <span class="string">name:</span> <span class="string">'spring-cloud-starter-alibaba-sentinel'</span>, <span class="string">version:</span> <span class="string">'2.1.0.RELEASE'</span></span><br><span class="line"><span class="comment">//lombok</span></span><br><span class="line">compile <span class="string">group:</span> <span class="string">'org.projectlombok'</span>, <span class="string">name:</span> <span class="string">'lombok'</span>, <span class="string">version:</span> <span class="string">'1.18.2'</span></span><br></pre></td></tr></table></figure>
<p>修改配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">alibaba-sentinel-test1</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8002</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel dashboard的访问地</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.transport.dashboard</span>=<span class="string">localhost:8080</span></span><br><span class="line"><span class="comment">#延迟加载</span></span><br><span class="line"><span class="comment">#spring.cloud.sentinel.eager=true</span></span><br></pre></td></tr></table></figure>
<p>添加请求方方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Sentinel"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动服务后，登录本地的sentinel页面（ <a href="http://localhost:8080/），并没有出现数据，这个时候发起请求" target="_blank" rel="noopener">http://localhost:8080/），并没有出现数据，这个时候发起请求</a></p>
<p>localhost:8002,页面上就显示如下图：</p>
<p><img src="/2019/12/08/spring-cloud-ali-sentinel接口限流/first-view.png" alt></p>
<p>点击 列表中的 簇点链路 ，点击/hello中的流控按钮，编辑限流单机阈值为2.</p>
<p><img src="/2019/12/08/spring-cloud-ali-sentinel接口限流/C:/Program Files\blog\source\_posts\spring-cloud-ali-sentinel接口限流\second-view.png" alt></p>
<p>点击新增之后，所有的规则都可以去流控规则列表中查看到.</p>
<h2 id="验证限流规则"><a href="#验证限流规则" class="headerlink" title="验证限流规则"></a>验证限流规则</h2><p>使用postman发起请求或者是curl发起请求测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl localhost:8002/hello</span><br><span class="line">Hello Sentinel</span><br><span class="line">$ curl localhost:8002/hello</span><br><span class="line">Hello Sentinel</span><br><span class="line">$ curl localhost:8002/hello</span><br><span class="line">Blocked by Sentinel (flow limiting)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring cloud alibaba</category>
      </categories>
      <tags>
        <tag>nacos</tag>
        <tag>spring cloud alibaba</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud RPC通信技术</title>
    <url>/2020/07/05/spring-cloud-RPC%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="RPC概念"><a href="#RPC概念" class="headerlink" title="RPC概念"></a>RPC概念</h1><p>RPC（Remote Promote Call） 一种进程间通信方式。允许像调用本地服务一样调用远程服务。</p>
<p>​        RPC框架的主要目标就是让远程服务调用更简单、透明。RPC框架负责屏蔽底层的传输方式（TCP或者UDP）、序列化方式（XML/JSON/二进制）和通信细节。开发人员在使用的时候只需要了解谁在什么位置提供了什么样的远程服务接口即可，并不需要关心底层通信细节和调用过程。</p>
<p>​        HTTP协议是应用层的超文本传送协议，它是Web的基础。HTTP协议位于TCP/IP协议栈的应用层。基于HTTP协议的客户/服务器模式的信息交换过程，分四个过程：建立连接、发送请求信息、发送响应信息、关闭连接。</p>
<p>可以看到 HTTP 和 RPC 并不是一个并行概念。</p>
<p>RPC是一种概念，http也是rpc实现的一种方式。论复杂度，dubbo/hessian用起来是超级简单的。最近用dubbo和hessian比较多，http的几乎都被废弃了</p>
<h1 id="RPC的优势"><a href="#RPC的优势" class="headerlink" title="RPC的优势"></a>RPC的优势</h1><p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。</p>
<p> 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的 分布式服务框架(RPC)，提供统一的服务是关键。</p>
<h1 id="RPC的实现原理"><a href="#RPC的实现原理" class="headerlink" title="RPC的实现原理"></a>RPC的实现原理</h1><p>代理对象的生成主要有以下几步</p>
<ol>
<li>生成代理类Class的二进制字节码；</li>
<li>通过Class.forName加载二进制字节码，生成Class对象；</li>
<li>通过反射机制获取实例构造，并初始化代理类对象。</li>
</ol>
<p><img src="/2020/07/05/spring-cloud-RPC通信技术/E:/blog\source\_posts\spring-cloud-RPC通信技术\rpc.png" alt="rpc"></p>
<p>也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</p>
<p>比如说，A服务器想调用B服务器上的一个方法：</p>
<p>Employee getEmployeeByName(String fullName)</p>
<p>整个调用过程，主要经历如下几个步骤：</p>
<h2 id="1、建立通信"><a href="#1、建立通信" class="headerlink" title="1、建立通信"></a>1、建立通信</h2><p>首先要解决通讯的问题：即A机器想要调用B机器，首先得建立起通信连接。</p>
<p>主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。</p>
<h2 id="2、服务寻址"><a href="#2、服务寻址" class="headerlink" title="2、服务寻址"></a>2、服务寻址</h2><p>要解决寻址的问题，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么。</p>
<p>通常情况下我们需要提供B机器（主机名或IP地址）以及特定的端口，然后指定调用的方法或者函数的名称以及入参出参等信息，这样才能完成服务的一个调用。</p>
<p>可靠的寻址方式（主要是提供服务的发现）是RPC的实现基石，比如可以采用redis或者zookeeper来注册服务等等。</p>
<ol>
<li>从服务提供者的角度看：当提供者服务启动时，需要自动向注册中心注册服务；</li>
<li>当提供者服务停止时，需要向注册中心注销服务；</li>
<li>提供者需要定时向注册中心发送心跳，一段时间未收到来自提供者的心跳后，认为提供者已经停止服务，从注册中心上摘取掉对应的服务。</li>
<li>从调用者的角度看：调用者启动时订阅注册中心的消息并从注册中心获取提供者的地址；</li>
<li>当有提供者上线或者下线时，注册中心会告知到调用者；</li>
<li>调用者下线时，取消订阅。</li>
</ol>
<h2 id="3、网络传输"><a href="#3、网络传输" class="headerlink" title="3、网络传输"></a>3、网络传输</h2><h3 id="3-1、序列化"><a href="#3-1、序列化" class="headerlink" title="3.1、序列化"></a>3.1、序列化</h3><p>当A机器上的应用发起一个RPC调用时，调用方法和其入参等信息需要通过底层的网络协议如TCP传输到B机器，由于网络协议是基于二进制的，所有我们传输的参数数据都需要先进行序列化（Serialize）或者编组（marshal）成二进制的形式才能在网络中进行传输。然后通过寻址操作和网络传输将序列化或者编组之后的二进制数据发送给B机器。</p>
<h3 id="3-2、反序列化"><a href="#3-2、反序列化" class="headerlink" title="3.2、反序列化"></a>3.2、反序列化</h3><p>当B机器接收到A机器的应用发来的请求之后，又需要对接收到的参数等信息进行反序列化操作（序列化的逆操作），即将二进制信息恢复为内存中的表达方式，然后再找到对应的方法（寻址的一部分）进行本地调用（一般是通过生成代理Proxy去调用,<br>通常会有JDK动态代理、CGLIB动态代理、Javassist生成字节码技术等），之后得到调用的返回值。</p>
<h2 id="4、服务调用"><a href="#4、服务调用" class="headerlink" title="4、服务调用"></a>4、服务调用</h2><p>B机器进行本地调用（通过代理Proxy）之后得到了返回值，此时还需要再把返回值发送回A机器，同样也需要经过序列化操作，然后再经过网络传输将二进制数据发送回A机器，而当A机器接收到这些返回值之后，则再次进行反序列化操作，恢复为内存中的表达方式，最后再交给A机器上的应用进行相关处理（一般是业务逻辑处理操作）。</p>
<p>通常，经过以上四个步骤之后，一次完整的RPC调用算是完成了。</p>
<h2 id="RPC调用过程"><a href="#RPC调用过程" class="headerlink" title="RPC调用过程"></a>RPC调用过程</h2><p><img src="/2020/07/05/spring-cloud-RPC通信技术/E:/blog\source\_posts\spring-cloud-RPC通信技术\process.png" alt="process"></p>
<p>1、服务消费者（client客户端）通过本地调用的方式调用服务</p>
<p>2、客户端存根（client stub）接收到调用请求后负责将方法、入参等信息序列化（组装）成能够进行网络传输的消息体</p>
<p>3、客户端存根（client stub）找到远程的服务地址，并且将消息通过网络发送给服务端</p>
<p>4、服务端存根（server stub）收到消息后进行解码（反序列化操作）</p>
<p>5、服务端存根（server stub）根据解码结果调用本地的服务进行相关处理</p>
<p>6、本地服务执行具体业务逻辑并将处理结果返回给服务端存根（server stub）</p>
<p>7、服务端存根（server stub）将返回结果重新打包成消息（序列化）并通过网络发送至消费方</p>
<p>8、客户端存根（client stub）接收到消息，并进行解码（反序列化）</p>
<p>9、服务消费方得到最终结果</p>
<h2 id="主流的RPC框架"><a href="#主流的RPC框架" class="headerlink" title="主流的RPC框架"></a>主流的RPC框架</h2><p>1.RMI</p>
<p>利用java.rmi包实现，基于Java远程方法协议(Java Remote Method Protocol) 和java的原生序列化。</p>
<p>2.Hessian</p>
<p>是一个轻量级的remoting onhttp工具，使用简单的方法提供了RMI的功能。 基于HTTP协议，采用二进制编解码。</p>
<p>3.protobuf-rpc-pro</p>
<p>是一个Java类库，提供了基于 Google 的 Protocol Buffers 协议的远程方法调用的框架。基于 Netty 底层的 NIO 技术。支持 TCP 重用/ keep-alive、SSL加密、RPC 调用取消操作、嵌入式日志等功能。</p>
<p>4.Thrift</p>
<p>是一种可伸缩的跨语言服务的软件框架。它拥有功能强大的代码生成引擎，无缝地支持C + +，C#，Java，Python和PHP和Ruby。thrift允许你定义一个描述文件，描述数据类型和服务接口。依据该文件，编译器方便地生成RPC客户端和服务器通信代码。</p>
<p>最初由facebook开发用做系统内个语言之间的RPC通信，2007年由facebook贡献到apache基金 ，现在是apache下的opensource之一 。支持多种语言之间的RPC方式的通信：php语言client可以构造一个对象，调用相应的服务方法来调用java语言的服务，跨越语言的C/S RPC调用。底层通讯基于SOCKET。</p>
<p>5.Avro</p>
<p>出自Hadoop之父Doug Cutting, 在Thrift已经相当流行的情况下推出Avro的目标不仅是提供一套类似Thrift的通讯中间件,更是要建立一个新的，标准性的云计算的数据交换和存储的Protocol。支持HTTP，TCP两种协议。</p>
<p>6.Dubbo</p>
<p>Dubbo是 阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。</p>
<h1 id="广义的远程通讯技术"><a href="#广义的远程通讯技术" class="headerlink" title="广义的远程通讯技术"></a>广义的远程通讯技术</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CORBA:面向对象的编程体系规范,分布式系统,跨语言,对标RMI(竞争关系)。</span><br><span class="line">SOAP:简单对象访问协议,微软联合厂商对xml-rpc标准化,soap协议就是联合标准化的结果,而且微软抢先完善了soap协议,推出了webservice。对象访问协议指的是使用XML描述web service的信息(URI/类/参数/返回值),理论上SOAP就是一段xml</span><br><span class="line">WebService:属于广义rpc的一种(常见的广义rpc实现还有xml-rpc和json-rpc),支持异构系统间的交互, 支持不同语言的通信,使用http通信,通过serlvet提供XML格式的数据,是SOAP协议的封装,WSDL是它的描述方式。</span><br><span class="line">WSDL:webservice描述语言,描述SOAP协议的,也是段XML</span><br><span class="line">RMI:远程调用对象,其实是java实现了RPC的一组接口</span><br><span class="line">JMS:MQ</span><br><span class="line">EJB:大型分布式,rmi-iiop协议</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/05/spring-cloud-RPC通信技术/E:/blog\source\_posts\spring-cloud-RPC通信技术\history.png" alt="history"></p>
<h1 id="RPC框架实现的几个核心技术点："><a href="#RPC框架实现的几个核心技术点：" class="headerlink" title="RPC框架实现的几个核心技术点："></a><strong>RPC框架实现的几个核心技术点</strong>：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">远程提供者需要以某种形式提供服务调用相关的信息，包括但不限于服务接口定义、数据结构、或者中间态的服务定义文件。例如Facebook的 Thrift的IDL文件，Web service的WSDL文件；服务的调用者需要通过一定的图景获取远程服务调用相关的信息。</span><br><span class="line">远程代理对象：服务调用者用的服务实际是远程服务的本地代理。说白了就是通过动态代理来实现。</span><br><span class="line">通信：RPC框架与具体的协议无关。</span><br><span class="line">序列化：毕竟是远程通信，需要将对象转化成二进制流进行传输。不同的RPC框架应用的场景不同，在序列化上也会采取不同的技术</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>rpc</tag>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud rabbitMq</title>
    <url>/2020/06/16/spring-cloud-rabbitMq/</url>
    <content><![CDATA[<h1 id="通道根据消息内容分发不同的消费逻辑"><a href="#通道根据消息内容分发不同的消费逻辑" class="headerlink" title="通道根据消息内容分发不同的消费逻辑"></a>通道根据消息内容分发不同的消费逻辑</h1><p>同一通道中的消息处理，会通过判断头信息或者消息内容来做一些差异化处理，比如：可能在消息头信息中带入消息版本号或其他信息</p>
<p><code>@StreamListener</code>注解中提供了一个不错的属性<code>condition</code>，可以用来优化这样的处理结构。</p>
<p>生产者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/sendMessage&quot;)</span><br><span class="line">public String messageWithMQ(@RequestParam String message,@RequestParam String version) &#123;</span><br><span class="line">    log.info(&quot;Send: &quot; + message);</span><br><span class="line">    testTopic.output().send(MessageBuilder.withPayload(message+new Date()).setHeader(&quot;x-delay&quot;, 5000).setHeader(&quot;version&quot;,version).build());</span><br><span class="line">    return &quot;ok&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@StreamListener(TestTopic.INPUT)</span><br><span class="line">public void receive(String payload) &#123;</span><br><span class="line">    log.info(&quot;Received: &quot; + payload+&quot;，接收时间为：&quot;+new Date());</span><br><span class="line">    System.out.println(&quot;Received: &quot; + payload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@StreamListener(value = TestTopic.INPUT, condition = &quot;headers[&apos;version&apos;]==&apos;1.0&apos;&quot;)</span><br><span class="line">public void receiveV1(String payload, @Header(&quot;version&quot;) String version) &#123;</span><br><span class="line">    log.info(&quot;Received v1 : &quot; + payload + &quot;, &quot; + version);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@StreamListener(value = TestTopic.INPUT, condition = &quot;headers[&apos;version&apos;]==&apos;2.0&apos;&quot;)</span><br><span class="line">public void receiveV2(String payload, @Header(&quot;version&quot;) String version) &#123;</span><br><span class="line">    log.info(&quot;Received v2 : &quot; + payload + &quot;, &quot; + version);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用postman 发送不同的版本号，会有不同的消费者接收消息，receive方法因为没有限制，一直都能消费信息。</p>
<h1 id="消息发送失败重新入队"><a href="#消息发送失败重新入队" class="headerlink" title="消息发送失败重新入队"></a>消息发送失败重新入队</h1><p>在消费者逻辑时添加抛出的异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int count = 1;</span><br><span class="line"></span><br><span class="line">@StreamListener(TestTopic.INPUT)</span><br><span class="line">public void receive(String payload) &#123;</span><br><span class="line">    log.info(&quot;Received: &quot; + payload+&quot;，接收时间为：&quot;+new Date());</span><br><span class="line">    System.out.println(&quot;Received: &quot; + payload+&quot;cout:&quot;+(count++));</span><br><span class="line">    throw new AmqpRejectAndDontRequeueException(&quot;time out&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在配置文件中修改重新入队的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#消息消费者配置</span><br><span class="line">#spring.cloud.stream.bindings.example-topic-input.binder=local_rabbit</span><br><span class="line">spring.cloud.stream.bindings.example-topic-input.destination=top</span><br><span class="line">spring.cloud.stream.bindings.example-topic-input.group=logMessageConsumers</span><br><span class="line">#spring.cloud.stream.rabbit.bindings.example-topic-input.consumer.delayed-exchange=true</span><br><span class="line">#最大重试次数</span><br><span class="line">spring.cloud.stream.bindings.example-topic-input.consumer.max-attempts=3</span><br><span class="line"></span><br><span class="line">#消费失败重新入队</span><br><span class="line">spring.cloud.stream.rabbit.bindings.example-topic-input.consumer.requeue-rejected=true</span><br><span class="line">#消息队列中的最大存活时间，超过该时间放入死信队列</span><br><span class="line">spring.cloud.stream.rabbit.bindings.packetUplinkInput.consumer.ttl=200000</span><br><span class="line">##开启消费者的死信队列</span><br><span class="line">spring.cloud.stream.rabbit.bindings.example-topic-input.consumer.autoBindDlq=true</span><br><span class="line"></span><br><span class="line">#生产者配置</span><br><span class="line">#spring.cloud.stream.bindings.example-topic-output.binder=local_rabbit</span><br><span class="line">spring.cloud.stream.bindings.example-topic-output.destination=top</span><br></pre></td></tr></table></figure>
<p>主要添加了三个配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#最大重试次数。默认值为3，为1时是为不开启重入队列</span><br><span class="line">spring.cloud.stream.bindings.example-topic-input.consumer.max-attempts=3</span><br><span class="line">##配置消费者的失败自动重新入队功能，并自动将死信队列绑定到dlx</span><br><span class="line">spring.cloud.stream.rabbit.bindings.example-topic-input.consumer.autoBindDlq=true</span><br><span class="line">spring.cloud.stream.rabbit.bindings.example-topic-input.consumer.requeue-rejected=true</span><br></pre></td></tr></table></figure>
<p>现在发起请求，可以在控制台上打印出请求的记录，只在最后一次的重新请求完成后才会抛出异常，发送失败的消息被存储在dlq死心队列中，异常的信息可以在绑定的dlq中获取到。下面的图片就是结果图</p>
<p><img src="/2020/06/16/spring-cloud-rabbitMq/delay.png" alt>]</p>
<p>在死信队列的数据可以再重新发送到其他的队列里面</p>
<p><img src="/2020/06/16/spring-cloud-rabbitMq/replay.png" alt>]</p>
<p>大部分的消息在业务上存在时效性，进入死信队列之后，过一段时间再处理已经没有意义，可以通过设置死信队列的存在时间，超过配置的时间之后，该消息就会自动从DLQ中删除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  spring.cloud.stream.rabbit.bindings.example-topic-input.consumer.dlq-ttl=10000</span><br><span class="line">#在dql的消息头中添加错误信息，默认为true</span><br><span class="line">spring.cloud.stream.rabbit.bindings.example-topic-input.consumer.republish-to-dlq=true</span><br></pre></td></tr></table></figure>
<h1 id="消息失败时自定义错误逻辑"><a href="#消息失败时自定义错误逻辑" class="headerlink" title="消息失败时自定义错误逻辑"></a>消息失败时自定义错误逻辑</h1><p>修改逻辑代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@StreamListener(TestTopic.INPUT)</span><br><span class="line">public void receive(String payload) &#123;</span><br><span class="line">    log.info(&quot;Received: &quot; + payload+&quot;，接收时间为：&quot;+new Date());</span><br><span class="line">    System.out.println(&quot;Received: &quot; + payload+&quot;cout:&quot;+(count++));</span><br><span class="line">    throw new AmqpRejectAndDontRequeueException(&quot;time out&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 消息消费失败的降级处理逻辑</span><br><span class="line"> *</span><br><span class="line"> * @param message</span><br><span class="line"> */</span><br><span class="line">@ServiceActivator(inputChannel = &quot;top.delayConsumer.errors&quot;)</span><br><span class="line">public void error(Message&lt;?&gt; message) &#123;</span><br><span class="line">    log.info(&quot;Message consumer failed, call fallback!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@ServiceActivator的注解</p>
<p>取值为 top取的是消息通道对应的目标（destination，即：<code>spring.cloud.stream.bindings.example-topic-input.destination</code>的配置）</p>
<p>delay取值为消息通道对应的消费组（group，即：<code>spring.cloud.stream.bindings.example-topic-input.group</code>的配置）</p>
<p>测试的时候延迟消息类型的数据并不能处理这种异常…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.cloud.stream.bindings.example-topic-input.destination=top</span><br><span class="line">spring.cloud.stream.bindings.example-topic-output.destination=top</span><br></pre></td></tr></table></figure>
<h1 id="处理重复的消息"><a href="#处理重复的消息" class="headerlink" title="处理重复的消息"></a>处理重复的消息</h1><p>定义一个生产端，两个消费端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//生产</span><br><span class="line">public interface AnotherOutput &#123;</span><br><span class="line"></span><br><span class="line">    String NAME = &quot;another-topic-input&quot;;</span><br><span class="line"></span><br><span class="line">    @Output(NAME)</span><br><span class="line">    SubscribableChannel output();</span><br><span class="line">&#125;</span><br><span class="line">//消费者</span><br><span class="line">public interface AnotherInput &#123;</span><br><span class="line">    String NAME = &quot;another-topic-input&quot;;</span><br><span class="line"></span><br><span class="line">    @Input(NAME)</span><br><span class="line">    SubscribableChannel input();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生产者代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private AnotherOutput anotherOutput;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;/anotherSendMessage&quot;)</span><br><span class="line">public String anotherSendMessage(@RequestParam String message, @RequestParam String version) &#123;</span><br><span class="line">    log.info(&quot;Send: &quot; + message);</span><br><span class="line">    anotherOutput.output().send(MessageBuilder.withPayload(message + new Date()).build());</span><br><span class="line">    return &quot;ok&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义监听的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableBinding(&#123;AnotherInput.class&#125;)</span><br><span class="line">public class AnotherReceive &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(AnotherReceive.class);</span><br><span class="line"></span><br><span class="line">    @StreamListener(AnotherInput.NAME)</span><br><span class="line">    public void receive1(String payload) &#123;</span><br><span class="line">        logger.info(&quot;AnotherReceive Received: &quot; + payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加通道的配置,这里只定义到destination</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.cloud.stream.bindings.another-topic-input.destination=top</span><br><span class="line">spring.cloud.stream.bindings.another-topic-output.destination=top</span><br></pre></td></tr></table></figure>
<p>启动两个实例，并用生产者发送一次消息以后,可以看到两个控制台都打印出消费的信息</p>
<p>在定义了输入和输出通道以后，一个生产端发送的消息会被多个消费组重复消费，为了避免消息的重复发送，可以定义消费组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.cloud.stream.bindings.another-topic-output.group=consumerTest</span><br><span class="line">spring.cloud.stream.bindings.another-topic-input.group=consumerTest</span><br></pre></td></tr></table></figure>
<p>这是因为当我们指定了某个绑定所指向的消费组之后，往当前主题发送的消息在每个订阅消费组中，只会有一个订阅者接收和消费，从而实现了对消息的负载均衡。只所以之前会出现重复消费的问题，是由于默认情况下，任何订阅都会产生一个匿名消费组，所以每个订阅实例都会有自己的消费组，从而当有消息发送的时候，就形成了广播的模式。</p>
<h1 id="消息分区"><a href="#消息分区" class="headerlink" title="消息分区"></a>消息分区</h1><p>修改配置信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#topic  消息</span><br><span class="line"></span><br><span class="line">#该参数指定了当前消费者的总实例数量；</span><br><span class="line">spring.cloud.stream.instanceCount=2</span><br><span class="line">#该参数设置当前实例的索引号，从0开始，最大值为spring.cloud.stream.instanceCount参数 - 1。我们试验的时#候需要启动多个实例，可以通过运行参数来为不同实例设置不同的索引值</span><br><span class="line">spring.cloud.stream.instanceIndex=1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spring.cloud.stream.bindings.another-topic-input.destination=top</span><br><span class="line">spring.cloud.stream.bindings.another-topic-input.group=consumerTest</span><br><span class="line">#通过该参数开启消费者分区功能；</span><br><span class="line">spring.cloud.stream.bindings.another-topic-input.consumer.partitioned=true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spring.cloud.stream.bindings.another-topic-output.destination=top</span><br><span class="line">spring.cloud.stream.bindings.another-topic-output.group=consumerTest</span><br><span class="line"></span><br><span class="line">#通过该参数指定了分区键的表达式规则，我们可以根据实际的输出消息规则来配置SpEL来生成合适的分区键；</span><br><span class="line">spring.cloud.stream.bindings.another-topic-output.producer.partitionKeyExpression=payload</span><br><span class="line">#该参数指定了消息分区的数量。</span><br><span class="line">spring.cloud.stream.bindings.another-topic-output.producer.partitionCount=2</span><br></pre></td></tr></table></figure>
<p>  partition-key-expression通过该参数指定了分区键的表达式规则,分区key的值是基于partitionKeyExpression计算得出的,用于每个消息被发送至对应分区的输出channel。</p>
<pre><code>该表达式作用于传递给MessageChannel的send方法的参数，该参数是实现 org.springframework.messaging.Message接口的类,GenericMessage类是Spring为我们提供的一个实现Message接口的类，我们封装的信息将会放在payload属性上。
</code></pre><p>例如在发送消息时设置header信息，并设置分区的表达式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	Message&lt;String&gt; message = MessageBuilder.withPayload(&quot;From timerMessageSource&quot;).setHeader(&quot;partitionKey&quot;, 1).build();</span><br><span class="line">	</span><br><span class="line">//配置中修改</span><br><span class="line">partition-key-expression: headers[&apos;partitionKey&apos;]</span><br></pre></td></tr></table></figure>
<p>这样就能指定分区的某个实例消费信息。</p>
<p>还可以按照实体的某个属性来指定分区实例的消费者。如下</p>
<p>创建通用的消息实体和发送的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@ToString</span><br><span class="line">public class GeneralOutputMessage &#123;</span><br><span class="line">    private String operationType;</span><br><span class="line">    private List&lt;String&gt; affectedFields;</span><br><span class="line">    private Object data;</span><br><span class="line">    private String eventId;</span><br><span class="line">    private String eventName;</span><br><span class="line">    private String partitionKey;//用来分区的主键</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@EqualsAndHashCode(callSuper=true)</span><br><span class="line">@ToString(callSuper=true)</span><br><span class="line">public class TransactionResponse extends GeneralOutputMessage&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在发送消息时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/anotherSendMessage&quot;)</span><br><span class="line">public String anotherSendMessage(GeneralOutputMessage generalOutputMessage) &#123;</span><br><span class="line">    TransactionResponse transactionResponse = new TransactionResponse();</span><br><span class="line">    BeanUtils.copyProperties(generalOutputMessage,transactionResponse);</span><br><span class="line">    anotherOutput.output().send(MessageBuilder.withPayload(transactionResponse.getPartitionKey()).build());</span><br><span class="line">    return &quot;ok&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改分区键的表达式规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.cloud.stream.bindings.another-topic-output.producer.partitionKeyExpression=payload.partitionKey</span><br></pre></td></tr></table></figure>
<h1 id="rabbitMQ-延迟消息插件"><a href="#rabbitMQ-延迟消息插件" class="headerlink" title="rabbitMQ 延迟消息插件"></a>rabbitMQ 延迟消息插件</h1><p>在<a href="http://www.rabbitmq.com/community-plugins.html" target="_blank" rel="noopener">http://www.rabbitmq.com/community-plugins.html</a> 中找到<code>rabbitmq_delayed_message_exchange</code>插件</p>
<p>在下载好之后，解压得到<code>.ez</code>结尾的插件包，将其复制到RabbitMQ安装目录下的<code>plugins</code>文件夹。</p>
<p>然后通过命令行启用该插件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure>
<p>创建延迟队列交换机</p>
<p><img src="/2020/06/16/spring-cloud-rabbitMq/delay.png" alt></p>
<h1 id="spring-cloud-stream-使用延迟消息实现定时任务"><a href="#spring-cloud-stream-使用延迟消息实现定时任务" class="headerlink" title="spring cloud stream 使用延迟消息实现定时任务"></a>spring cloud stream 使用延迟消息实现定时任务</h1><p>引入依赖stream-rabbit依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile group: &apos;org.springframework.cloud&apos;, name: &apos;spring-cloud-starter-stream-rabbit&apos;, version: &apos;3.0.5.RELEASE&apos;</span><br><span class="line">compile group: &apos;org.springframework.cloud&apos;, name: &apos;spring-cloud-starter-bus-amqp&apos;, version: &apos;2.2.2.RELEASE&apos;</span><br></pre></td></tr></table></figure>
<p>自定义消息管道</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface TestTopic &#123;</span><br><span class="line"></span><br><span class="line">    String OUTPUT = &quot;example-topic-output&quot;;</span><br><span class="line">    String INPUT = &quot;example-topic-input&quot;;</span><br><span class="line"></span><br><span class="line">    @Output(OUTPUT)</span><br><span class="line">    MessageChannel output();</span><br><span class="line"></span><br><span class="line">    @Input(INPUT)</span><br><span class="line">    SubscribableChannel input();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建消息接收类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class TestListener &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger log = LoggerFactory.getLogger(TestListener.class);</span><br><span class="line"></span><br><span class="line">    @StreamListener(TestTopic.INPUT)</span><br><span class="line">    public void receive(String payload) &#123;</span><br><span class="line">        log.info(&quot;Received: &quot; + payload);</span><br><span class="line">        System.out.println(&quot;Received: &quot; + payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建消息发送类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableBinding(TestTopic.class)</span><br><span class="line">@RestController</span><br><span class="line">public class StreamHello &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger log = LoggerFactory.getLogger(StreamHello.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TestTopic testTopic;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/sendMessage&quot;)</span><br><span class="line">    public String messageWithMQ(@RequestParam String message) &#123;</span><br><span class="line">        log.info(&quot;Send: &quot; + message);</span><br><span class="line">        testTopic.output().send(MessageBuilder.withPayload(message).setHeader(&quot;x-delay&quot;, 5000).build());</span><br><span class="line">        return &quot;ok&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件添加rabbit的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#rabbit 配置</span><br><span class="line">spring.rabbitmq.host=localhost</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=admin</span><br><span class="line">spring.rabbitmq.password=admin</span><br><span class="line">spring.rabbitmq.virtual-host=delay-host</span><br><span class="line"></span><br><span class="line">#通道配置</span><br><span class="line">spring.cloud.stream.bindings.example-topic-input.destination=delay</span><br><span class="line">#spring.cloud.stream.bindings.example-topic-input.binder=local_rabbit</span><br><span class="line">spring.cloud.stream.bindings.example-topic-input.group=logMessageConsumers</span><br><span class="line">#延迟消息队列配置</span><br><span class="line">spring.cloud.stream.rabbit.bindings.example-topic-input.consumer.delayed-exchange=true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spring.cloud.stream.bindings.example-topic-output.destination=delay</span><br><span class="line">#spring.cloud.stream.bindings.example-topic-output.binder=local_rabbit</span><br><span class="line">#延迟消息队列配置</span><br><span class="line">spring.cloud.stream.rabbit.bindings.example-topic-output.producer.delayed-exchange=true</span><br><span class="line"></span><br><span class="line">##rabbitmq路径配置</span><br><span class="line">#spring.cloud.stream.binders.local_rabbit.type=rabbit</span><br><span class="line">#spring.cloud.stream.binders.local_rabbit.environment.spring.rabbitmq.host=localhost</span><br><span class="line">#spring.cloud.stream.binders.local_rabbit.environment.spring.rabbitmq.port=5672</span><br><span class="line">#spring.cloud.stream.binders.local_rabbit.environment.spring.rabbitmq.username=admin</span><br><span class="line">#spring.cloud.stream.binders.local_rabbit.environment.spring.rabbitmq.password=admin</span><br><span class="line">#spring.cloud.stream.binders.local_rabbit.environment.spring.rabbitmq.virtual-host=delay-host</span><br></pre></td></tr></table></figure>
<p>启动服务，并请求send接口，控制台就能打印出相应的message</p>
<h1 id="RabbitMQ延迟消息的极限"><a href="#RabbitMQ延迟消息的极限" class="headerlink" title="RabbitMQ延迟消息的极限"></a>RabbitMQ延迟消息的极限</h1><p>因为不是所有的消息都出现了没有延迟消息效果的因素，通过有问题的消息特征，大致猜测可能是延迟时间过长导致了消息延迟失败。为了验证这个原因，先拿之前<a href="http://blog.didispace.com/spring-cloud-starter-finchley-7-7/" target="_blank" rel="noopener">文章</a>中的例子，来测试一下延迟时间是否与问题直接相关。</p>
<p>对之前的延迟消息使用样，增加了一个请求参数<code>delay</code>来控制延迟时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/sendMessage"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">messageWithMQ</span><span class="params">(@RequestParam String message, @RequestParam Long delay)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Send: "</span> + message);</span><br><span class="line">    testTopic.output().send(MessageBuilder.withPayload(message).setHeader(<span class="string">"x-delay"</span>, delay).build());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>请求1</strong>：延迟5000毫秒。消息发送到MQ之后确实延迟了5秒之后才得到了消费，没有任何问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl localhost:8080/sendMessage?message=hello&amp;delay=5000</span><br></pre></td></tr></table></figure>
<p><strong>请求2</strong>：延迟1年（31536000000毫秒）。消息发送到MQ之后马上就被消费者消费了，完全没有延迟效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl localhost:8080/sendMessage?message=hello&amp;delay=31536000000</span><br></pre></td></tr></table></figure>
<p>在明确了问题原因之后，需要对该功能的时候做一些明确的限定（延迟时间的极限），以避免再次出现类似的问题。深入探索下去，这里的失败主要与消息的过期时间（TTL）有直接的关系。在RabbitMQ中，消息的过期时间必须是非负 32 位整数，即：0 &lt;= n &lt;= 2^32-1，以毫秒为单位。 其中，<strong>2^32-1 = 4294967295</strong>。</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>spring cloud</tag>
        <tag>rabbitMq</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud mysql配置中心</title>
    <url>/2020/06/28/spring-cloud-mysql%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<p>以前写过使用git版本的配置中心，但是这种配置中心是粗颗粒控制的，应用应用多起来之后而且管理起来比较麻烦。</p>
<p>从官方文档中我们可以看出，spring cloud server 支持 native、git、svn、vault、credhub、jdbc和composits 这几中方式来管理配置文件</p>
<h1 id="配置使用mysql"><a href="#配置使用mysql" class="headerlink" title="配置使用mysql"></a>配置使用mysql</h1><p>  Spring Cloud Config 主要分为两个部分 </p>
<p>​       1.spring cloud config server    config 的服务端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile group: &apos;org.springframework.boot&apos;, name: &apos;spring-boot-starter-jdbc&apos;, version: &apos;2.3.0.RELEASE&apos;</span><br><span class="line"></span><br><span class="line">implementation &apos;org.springframework.cloud:spring-cloud-config-server&apos;</span><br></pre></td></tr></table></figure>
<p>​       2.spring cloud config client     config 的客户端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation &apos;org.springframework.cloud:spring-cloud-starter-config&apos;</span><br></pre></td></tr></table></figure>
<h3 id="Spring-Cloud-Config-Server-的选择"><a href="#Spring-Cloud-Config-Server-的选择" class="headerlink" title="Spring Cloud Config Server 的选择"></a>Spring Cloud Config Server 的选择</h3><p><img src="/2020/06/28/spring-cloud-mysql配置中心/server.png" alt></p>
<p>这几种配置的方法可以通过配置来选择，默认的是git的实现方式，我们这里选择的是jdbc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 根据自己的需要配置 native、git、svn、vault、credhub、jdbc或composits</span><br><span class="line">spring.profiles.active=jdbc</span><br></pre></td></tr></table></figure>
<p>创建数据库表存储数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `properties`  (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `p` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</span><br><span class="line">  `v` varchar(500) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</span><br><span class="line">  `application` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</span><br><span class="line">  `profile` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</span><br><span class="line">  `label` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;</span><br></pre></td></tr></table></figure>
<p>Server端修改配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#指定应用程序名称</span><br><span class="line">spring.application.name=config-server</span><br><span class="line">#指定端口</span><br><span class="line">server.port=8888</span><br><span class="line">#指定配置方式</span><br><span class="line">#spring.profiles.active=native</span><br><span class="line">spring.profiles.active=jdbc</span><br><span class="line">#配置文件的目录</span><br><span class="line">#spring.cloud.config.server.native.search-locations=D:/spring-config/config-file</span><br><span class="line">#查询语句需要保持三个参数（暂时没找到添加参数的方法，但是可以设置默认值）,   这个我修改了一下，不然默认的sql会在mysql里面报错的</span><br><span class="line">spring.cloud.config.server.jdbc.sql=SELECT p, v from properties where APPLICATION=? and PROFILE=? and LABEL=?</span><br><span class="line">#spring.cloud.config.server.git.default-label=default</span><br><span class="line">#####################################################################################################</span><br><span class="line"># mysql 属性配置</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/config</span><br><span class="line">spring.datasource.username=</span><br><span class="line">spring.datasource.password=</span><br><span class="line">spring.jpa.show-sql=true</span><br></pre></td></tr></table></figure>
<p>在启动类上添加注解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableConfigServer</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ConfigServerDbApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ConfigServerDbApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动服务，测试<a href="http://localhost:8888/config-client/dev/master" target="_blank" rel="noopener">http://localhost:8888/config-client/dev/master</a></p>
<p>客户端配置添加配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#配置中心配置</span><br><span class="line">spring.cloud.config.discovery.service-id=config-server</span><br><span class="line">#配置的文件名，默认的是服务名</span><br><span class="line">spring.cloud.config.name=config-client</span><br><span class="line">#profie  后缀</span><br><span class="line">spring.cloud.config.profile=dev</span><br><span class="line">#分支</span><br><span class="line">spring.cloud.config.label=master</span><br></pre></td></tr></table></figure>
<p>在添加一个测试方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Value(&quot;$&#123;com.panghu.message&#125;&quot;)</span><br><span class="line">private String v;</span><br><span class="line"></span><br><span class="line">@PostMapping(&quot;/test&quot;)</span><br><span class="line">public String test()&#123;</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>spring cloud</tag>
        <tag>config</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud 分布式配置中心</title>
    <url>/2019/11/12/spring-cloud-%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<h1 id="分布式配置中心（Dalston版本）"><a href="#分布式配置中心（Dalston版本）" class="headerlink" title="分布式配置中心（Dalston版本）"></a>分布式配置中心（Dalston版本）</h1><h2 id="传统作法"><a href="#传统作法" class="headerlink" title="传统作法"></a>传统作法</h2><p>​    通常在生产环境，Config Server与服务注册中心一样，我们也需要将其扩展为高可用的集群。在之前实现的config-server基础上来实现高可用非常简单，不需要我们为这些服务端做任何额外的配置，只需要遵守一个配置规则：将所有的Config Server都指向同一个Git仓库，这样所有的配置内容就通过统一的共享文件系统来维护，而客户端在指定Config Server位置时，只要配置Config Server外的均衡负载即可，就像如下图所示的结构：</p>
<p><img src="/2019/11/12/spring-cloud-分布式配置中心/config.png" alt></p>
<h2 id="服务端-config-server"><a href="#服务端-config-server" class="headerlink" title="服务端 config-server"></a>服务端 config-server</h2><p>首先需要准备一个<a href="https://github.com/pignum1/config.git" target="_blank" rel="noopener">git仓库</a>，作为分布式配置的管理</p>
<p>创建idea的配置服务端,引入服务端的配置依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'org.springframework.cloud:spring-cloud-config-server'</span></span><br><span class="line">implementation <span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span></span><br></pre></td></tr></table></figure>
<p>在application.properties种添加配置文件和Git的地址，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#服务端口</span><br><span class="line">server.port=9876</span><br><span class="line">#服务名称</span><br><span class="line">spring.application.name=myConfigServer</span><br><span class="line">#服务注册中心</span><br><span class="line"></span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:5678/eureka/</span><br><span class="line">#服务的git仓库地址</span><br><span class="line">spring.cloud.config.server.git.uri=https://github.com/pignum1/config.git</span><br><span class="line">#配置文件所在的目录</span><br><span class="line">spring.cloud.config.server.git.search-paths=/order</span><br><span class="line">#配置文件所在的分支</span><br><span class="line">spring.cloud.config.label=master</span><br><span class="line"></span><br><span class="line">#spring cloud2.x刷新配置需要开启</span><br><span class="line">management.endpoints.web.exposure.include=refresh,health,info</span><br></pre></td></tr></table></figure>
<p>在启动类商添加注解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableConfigServer</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@ResponseBody</span><br><span class="line">public class ConfigServerApplication &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ConfigServerApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 启动服务后，按照配置文件的访问路径规则去请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]</span><br><span class="line">/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line">/&#123;application&#125;-&#123;profile&#125;.properties</span><br><span class="line">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties</span><br></pre></td></tr></table></figure>
<p>​        启动服务后访问 <a href="http://localhost:9876/order/a/master" target="_blank" rel="noopener">http://localhost:9876/order/a/master</a> ，访问order文件下的order-a.properties文件，可以得到返回的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;order&quot;,</span><br><span class="line">  &quot;profiles&quot;: [</span><br><span class="line">    &quot;a&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;label&quot;: &quot;master&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;ab1b5e0ba15605570591d632977d8debcf7f77a9&quot;,</span><br><span class="line">  &quot;state&quot;: null,</span><br><span class="line">  &quot;propertySources&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;https://github.com/pignum1/config.git/order/order-a.properties&quot;,</span><br><span class="line">      &quot;source&quot;: &#123;</span><br><span class="line">        &quot;from&quot;: &quot;123&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的道德JSON字符串是因为我移除了spring cloud 默认的xml格式转换消息器 ,</p>
<p>在配置类中移除依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 删除xml格式转换消息器</span><br><span class="line"> */</span><br><span class="line">configurations &#123;</span><br><span class="line">	all*.exclude group: &apos;com.fasterxml.jackson.dataformat&apos;, module: &apos;jackson-dataformat-xml&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="客户端-config-client"><a href="#客户端-config-client" class="headerlink" title="客户端 config-client"></a>客户端 config-client</h2><p>同样创建一个spring cloud 项目，在依赖管理添加客户端的依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//客户端依赖</span><br><span class="line">implementation &apos;org.springframework.cloud:spring-cloud-starter-config&apos;</span><br><span class="line">//mvc</span><br><span class="line">implementation &apos;org.springframework.boot:spring-boot-starter-web&apos;</span><br><span class="line">#刷新配置</span><br><span class="line">implementation &apos;org.springframework.boot:spring-boot-starter-actuator&apos;</span><br><span class="line">#注册中心依赖</span><br><span class="line">implementation &apos;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&apos;</span><br></pre></td></tr></table></figure>
<p>在resources下新建 bootstrap . yml文件，因为spring cloud的配置先读取的是bootstrap 文件。读取的顺序是bootstrap &gt;连接config获取的配置文件&gt; application 文件。否则启动时服务端拉数据的默认端口是8888</p>
<p>bootstrap . yml配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://localhost:5678/eureka/</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: order</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      uri: http://localhost:9876</span><br><span class="line">      profile: a</span><br><span class="line">      label: master</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8030</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: refresh</span><br></pre></td></tr></table></figure>
<p>此时启动客户端，控制台会打印下面的信息</p>
<p><img src="/2019/11/12/spring-cloud-分布式配置中心/console.png" alt></p>
<p>创建测试controller，这个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RefreshScope</span><br><span class="line">@RestController</span><br><span class="line">public class TestController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;from&#125;&quot;)</span><br><span class="line">    private String from;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/service&quot;)</span><br><span class="line">    public String from() &#123;</span><br><span class="line"></span><br><span class="line">        return this.from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFrom(String from) &#123;</span><br><span class="line">        this.from = from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getFrom() &#123;</span><br><span class="line">        return from;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求 <a href="http://localhost:8030/service" target="_blank" rel="noopener">http://localhost:8030/service</a> ，页面上显示值为 123</p>
<p>如果这个时候修改order-a.properties 文件里面的from值为321，再次发起请求时页面仍未123，这时只要使用post方法请求  <a href="http://localhost:8030/actuator/refresh" target="_blank" rel="noopener">http://localhost:8030/actuator/refresh</a>  刷新配置，再次请求<a href="http://localhost:8030/service" target="_blank" rel="noopener">http://localhost:8030/service</a> ，页面上显示的值就成了321 。</p>
<h2 id="添加重试机制"><a href="#添加重试机制" class="headerlink" title="添加重试机制"></a>添加重试机制</h2><p>当该方法有很多服务，需要一个一个去刷新，一般使用 MQ+spring-could-bus 消息总线模式来批量更新配置信息。  还有一个附加的，就是在服务端在从配置中心获取配置信息时，如果出现了网络波动，导致项目启动时无法获取信息的话，可以使用如下配置来规避。<br>还是在config-client项目上进行扩展 依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#重试机制的依赖</span><br><span class="line">implementation &apos;org.springframework.retry:spring-retry&apos;</span><br><span class="line">implementation &apos;org.springframework.boot:spring-boot-starter-aop&apos;</span><br></pre></td></tr></table></figure>
<p>在config的客户端  application.properties 添加配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#retry</span><br><span class="line">#和重试机制相关的配置有如下四个：</span><br><span class="line"># 配置重试次数，默认为6</span><br><span class="line">spring.cloud.config.retry.max-attempts=6</span><br><span class="line"># 间隔乘数，默认1.1</span><br><span class="line">spring.cloud.config.retry.multiplier=1.1</span><br><span class="line"># 初始重试间隔时间，默认1000ms</span><br><span class="line">spring.cloud.config.retry.initial-interval=1000</span><br><span class="line"># 最大间隔时间，默认2000ms</span><br><span class="line">spring.cloud.config.retry.max-interval=2000</span><br></pre></td></tr></table></figure>
<p>在bootstrap .yml添加配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#启动失败时能够快速响应</span><br><span class="line">#spring:</span><br><span class="line">		cloud:</span><br><span class="line">			config:</span><br><span class="line">				fail-fast=true</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>spring cloud</tag>
        <tag>config</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud steam</title>
    <url>/2019/11/26/spring-cloud-steam/</url>
    <content><![CDATA[<p> 我们通过简单的配置和注解就能实现向RabbitMQ中生产和消费消息。实际上我们使用的对RabbitMQ的starter就是通过Spring Cloud Stream中对RabbitMQ的支持来实现的。下面我们就通过本文来了解一下Spring Cloud Stream。 </p>
<p> Spring Cloud Stream是一个用来为微服务应用构建消息驱动能力的框架。它可以基于Spring Boot来创建独立的、可用于生产的Spring应用程序。它通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动的微服务应用。Spring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，并且引入了发布-订阅、消费组以及消息分区这三个核心概念。简单的说，Spring Cloud Stream本质上就是整合了Spring Boot和Spring Integration，实现了一套轻量级的消息驱动的微服务框架。通过使用Spring Cloud Stream，可以有效地简化开发人员对消息中间件的使用复杂度，让系统开发人员可以有更多的精力关注于核心业务逻辑的处理。由于Spring Cloud Stream基于Spring Boot实现，所以它秉承了Spring Boot的优点，实现了自动化配置的功能帮忙我们可以快速的上手使用，但是目前为止Spring Cloud Stream只支持下面两个著名的消息中间件的自动化配置： </p>
<ul>
<li><code>RabbitMQ</code></li>
<li><code>Kafka</code></li>
</ul>
<h1 id="构建一个Spring-Cloud-Stream消费者"><a href="#构建一个Spring-Cloud-Stream消费者" class="headerlink" title="构建一个Spring Cloud Stream消费者"></a>构建一个Spring Cloud Stream消费者</h1><p>创建一个消费者 stream-hello </p>
<p>添加 Spring Cloud Stream对RabbitMQ的支持，</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rabbit -steam依赖</span></span><br><span class="line">	compile <span class="string">group:</span> <span class="string">'org.springframework.cloud'</span>, <span class="string">name:</span> <span class="string">'spring-cloud-starter-stream-rabbit'</span>, <span class="string">version:</span> <span class="string">'2.1.3.RELEASE'</span></span><br></pre></td></tr></table></figure>
<p> 创建用于接收来自RabbitMQ消息的消费者<code>SinkReceiver</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(Sink<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SinkReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SinkReceiver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener</span>(Sink.INPUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Object payload)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Received: "</span> + payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>@EnableBinding</strong> :实现了对消息通道（channel）的绑定 </p>
<p> <strong>@EnableBinding (Sink.class)</strong> ：绑定了Sink接口，该接口是Spring cloud Stream中默认实现的对输入消息通道绑定的定义 </p>
<p> 从代码中可以看到通过注解的方式绑定了一个名字为input的通道  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sink</span> </span>&#123;</span><br><span class="line">    String INPUT = <span class="string">"input"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Input</span>(<span class="string">"input"</span>)</span><br><span class="line">    <span class="function">SubscribableChannel <span class="title">input</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然有输入就会有输出 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    String OUTPUT = <span class="string">"output"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Output</span>(<span class="string">"output"</span>)</span><br><span class="line">    <span class="function">MessageChannel <span class="title">output</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 当需要绑定多个接口的时候，只需要用逗号隔开，添加类即可 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(&#123;Sink<span class="class">.<span class="keyword">class</span>,<span class="title">Source</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SinkReceiver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger=LoggerFactory.getLogger(StreamHelloApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@StreamListener</span>(Sink.INPUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Object payload)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Receive---------------------------------------:"</span>+payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@StreamListener</strong>将方法作为消息的监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@StreamListener</span>(Sink.INPUT)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Object payload)</span> </span>&#123;</span><br><span class="line">     logger.info(<span class="string">"Received: "</span> + payload);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>启动类与正常相同，启动服务并开启rabbitMQ的本地服务，默认的配置就是请求本地的rabbitMQ，不需要额外配置，服务启动后，控制台上打印出</p>
<p><img src="/2019/11/26/spring-cloud-steam/rabbitMQ-start.png" alt></p>
<p>这个时候点开rabbitMQ的控制台，在页面上输入 <a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a></p>
<p><img src="/2019/11/26/spring-cloud-steam/rabbitMQ-connect.png" alt></p>
<p>点击连接信息并查看消息，输入“send message” 并点击publish</p>
<p><img src="/2019/11/26/spring-cloud-steam/rabbitMQ-send.png" alt></p>
<p>此时这个控制台打印出</p>
<p><img src="/2019/11/26/spring-cloud-steam/rabbitMQ-receive.png" alt></p>
<p>完成上示简单的示例后， 引入<code>spring-cloud-starter-stream-rabbit</code>依赖，该依赖包是Spring Cloud Stream对RabbitMQ支持的封装，其中包含了对RabbitMQ的自动化配置等内容。从下面它定义的依赖关系中，我们还可以知道它等价于<code>spring-cloud-stream-binder-rabbit</code>依赖。 </p>
<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="绑定器"><a href="#绑定器" class="headerlink" title="绑定器"></a>绑定器</h2><p> 这里的Binder是指Stream的Binde,如果没有Binder,那么spring boot 在使用消息中间件的时候，由于每个消息中间件都不太相同，一旦切换将会使代码重构。而使用了Binder之后，最终暴露给用户的只有Channel </p>
<h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h2><p> Stream的消息通讯方式遵循了发布-订阅模式，当一条消息发送到消息中间件后，它会通过共享的Topic主题进行广播，消息消费者在订阅的主题中收到它并触发相关事务。对于Topic只是一个抽象概念，在MQ中是Exchange,在Kafaka中则是Topic </p>
<p>相对于点对点队列实现的消息通信来说，Spring Cloud Stream 采用的发布-订阅模式可以有效降低消息生产者与消费者之间的耦合。当需要对同一类消息增加一种处理方式时，只需要增加一个应用程序并将输入通道绑定到既有的Topic中就可以实现功能的扩展，而不需要改变原来已经实现的任何内容</p>
<h2 id="消费组"><a href="#消费组" class="headerlink" title="消费组"></a>消费组</h2><p>由于我们的每一个微服务应用都会有多个实例，但是我们只希望消息只被其中一个实例消费一次，所以有了消费组的概念。当多个实例在同一组的时候，也就是设置spring.cloud.stream.bindings.input.group属性的时候，那么消息只会被其中一个实例消费一次。默认情况下，Stream默认分配了一个独立的匿名消费组。所以，如果不是必须像刷新配置一样，最好是指定消费组。</p>
<h2 id="消息分区"><a href="#消息分区" class="headerlink" title="消息分区"></a>消息分区</h2><p>指定某一个实例消费信息。Stream为分区提供了抽象实现，所以它不在乎消息中间件是否有分区功能。</p>
<h1 id="使用详解"><a href="#使用详解" class="headerlink" title="使用详解"></a>使用详解</h1><h2 id="开启绑定功能-EnableBinding"><a href="#开启绑定功能-EnableBinding" class="headerlink" title="开启绑定功能@EnableBinding"></a>开启绑定功能@EnableBinding</h2><p>它只有唯一一个属性：value。上面已经介绍过，由于该注解已经被@Import了BindingBeansRegistrar实现，所以在加载了基本配置内容之后，它会回调来读取value中的类，以创建消息通道的绑定。另外，由于value是一个Class类型的数组，所以我们可以通过value属性一次性指定多个关于消息通道的配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;BindingServiceConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">BindingBeansRegistrar</span>.<span class="title">class</span>, <span class="title">BinderFactoryConfiguration</span>.<span class="title">class</span>, <span class="title">SpelExpressionConverterConfiguration</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">EnableIntegration</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableBinding</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="绑定消息通道"><a href="#绑定消息通道" class="headerlink" title="绑定消息通道"></a>绑定消息通道</h2><p> value里面填的接口对象，里面有消息通道的定义，通过接口对象进行通道绑定 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(&#123;Sink<span class="class">.<span class="keyword">class</span>,<span class="title">Source</span>.<span class="title">class</span>&#125;)</span></span><br></pre></td></tr></table></figure>
<p>其中Sink、Source分别是默认的输入、输出管道</p>
<p> 也可以通过继承直接定义输入和输出通道  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span> <span class="keyword">extends</span> <span class="title">Source</span>, <span class="title">Sink</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置相同的主题Topic </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.stream.bindings.input.destination</span>=<span class="string">sink-channel</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.output.destination</span>=<span class="string">sink-channel</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.input-1.destination</span>=<span class="string">sink-channel</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.output-1.destination</span>=<span class="string">sink-channel</span></span><br></pre></td></tr></table></figure>
<p>创建消息生产者</p>
<p>通过结合 @EnableBinding结合@InboundChannelAdapter注解实现消息的发送 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@EnableBinding</span>(value = &#123;Source<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SinkSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Source source;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(SinkSender<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicInteger NUM = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InboundChannelAdapter</span>(value = Source.OUTPUT,poller = <span class="meta">@Poller</span>(fixedRate = <span class="string">"3000"</span>))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">timerMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">        log.info(NUM.getAndIncrement() + <span class="string">" Send message : "</span> + format);</span><br><span class="line">        <span class="keyword">return</span> format;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        source.output().send(org.springframework.integration.support.MessageBuilder.withPayload(message).build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动服务，控制台打印出</p>
<p><img src="/2019/11/26/spring-cloud-steam/rabbitMQ-customer.png" alt></p>
<h2 id="消息的生产与消费"><a href="#消息的生产与消费" class="headerlink" title="消息的生产与消费"></a>消息的生产与消费</h2><p> 由于Stream 是由 Spring Integration 构建起来的， 支持Integration原生实现 所以可以使用Integration提供相同服务 </p>
<p> @ServiceActivator类比于@StreanListener,实现了对Sink.INPUT通道的监听处理，而该通道绑定了名为input的主题，这个主题就是我们在配置文件上配置的，必须确保input和output为同一个主题Topic. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">@StreamListener(SinkSender.INPUT)</span><br><span class="line">public void receives(Object payload)&#123;</span><br><span class="line">    logger.info(&quot;Receive---------------------------------------:&quot;+payload.toString());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@ServiceActivator(inputChannel = SinkSender.INPUT)</span><br><span class="line">public void receivess(Object payload)&#123;</span><br><span class="line">    logger.info(&quot;Receive---------------------------------------:&quot;+payload.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息发送和消息接收要在同一个 同一个主题Topic </p>
<p> 共用一个主题Topic，构成了一组生产者与消费者 。 @InboundChannelAdapter是对通道的输出绑定，同时使用Poller轮询的方式执行 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">    @InboundChannelAdapter(value=Source.OUTPUT,poller = @Poller(fixedDelay = &quot;2000&quot;))</span><br><span class="line">    public MessageSource&lt;Date&gt; timerMessageSource()&#123;</span><br><span class="line">        return ()-&gt;new GenericMessage&lt;&gt;(new Date());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 消息转换  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transformer</span>(inputChannel = SinkSender.INPUT,outputChannel = SinkSender.OUTPUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Date message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="StreamListener详解"><a href="#StreamListener详解" class="headerlink" title="@StreamListener详解"></a>@StreamListener详解</h2><p> @StreamListener虽然同@ServiceActivator功能相似，但是功能更加强大 </p>
<p>上文中的注解可以替换为@ServiceActivator(inputChannel =Sink.INPUT)</p>
<p>消息转换 </p>
<p>例如将json字符串转换成java对象 </p>
<p> 使用@Transformer注解实现，通过上面的例子，我们可以通过代码的方式去实现消息的转化。 </p>
<p> 使用@StreamListener注解实现,只需要指定传输过来的数据格式即可，因为Stream已经有了内置的消息转换机制，我们无需重复编写。所以说对于此注解来说，只是多写了一个配置信息而已。 </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.stream.bindings.input-1.content-type</span>=<span class="string">application/json</span></span><br></pre></td></tr></table></figure>
<h3 id="消息反馈"><a href="#消息反馈" class="headerlink" title="消息反馈"></a>消息反馈</h3><p> 处理完消息之后，需要反馈一个消息给对方，这时候可以通过@SendTo注解来指定返回内容的输出通道 ， 使用sendto注解即可搞定.对于配置信息，要确保绑定的topic也就是destination是同一个在可以实现订阅，因为通道名字会默认为交换机exchange也就是topic的名字，所以在测试的时候例如在一个应用里面要记得配置相同的交换机。 </p>
<p>修改receive方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@StreamListener</span>(Sink.INPUT)</span><br><span class="line">  <span class="meta">@SendTo</span>(Source.OUTPUT)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">receives</span><span class="params">(Object payload)</span></span>&#123;</span><br><span class="line">      logger.info(<span class="string">"Receive---------------------------------------:"</span>+payload.toString());</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"From llg Channe Return"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>除了 @SendTo(Source.OUTPUT)，也可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@ServiceActivator(inputChannel = Sink.INPUT,outputChannel = Source.OUTPUT)</span><br><span class="line">    public Object receivess(Object payload)&#123;</span><br><span class="line">        logger.info(&quot;Receive---------------------------------------:&quot;+payload.toString());</span><br><span class="line">        return &quot;返回&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费组-1"><a href="#消费组-1" class="headerlink" title="消费组"></a>消费组</h3><p>消费组的概念上文说过，其实就是如果出现需要让服务中多个实例的其中一个消费消息的话，就需要设置消费组进行隔离标记。</p>
<p>不难理解，最主要还是因为是订阅模式，所以会统一发送消息，并且默认组名是匿名组，所以也就自然而然的对服务的所有实例发送了，下面我们来设置消费组。</p>
<p>可以看到配置一个组名Service ,那么开启多个实例的时候自然而然的所有实例的组名都是Service.所以消费组的意思就是把一个服务按一个组划分，每次只传递一个消息到这个组来，再随机给其中的一个实例消费。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.input.group</span>=<span class="string">Service</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.input.destination</span>=<span class="string">input</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.output.destination</span>=<span class="string">input</span></span><br></pre></td></tr></table></figure>
<h3 id="消息分区-1"><a href="#消息分区-1" class="headerlink" title="消息分区"></a>消息分区</h3><p> 为了将某些特定的消息给特定的实例消费，所以需要设置消息分区 </p>
<p>首先需要在消费者应用配置信息</p>
<p>spring.cloud.stream.bindings.input.consumer.partitioned=true :开启消费者分区功能<br>spring.cloud.stream.instance-count=2 ：指定了消费者的实例总数<br>spring.cloud.stream.instance-index=0 ：索引号，从0开始。必须每个实例按索引为0开始递增</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.input.group</span>=<span class="string">Service</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.input.destination</span>=<span class="string">input</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.output.destination</span>=<span class="string">input</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.input.consumer.partitioned</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.cloud.stream.instance-count</span>=<span class="string">2</span></span><br><span class="line"><span class="meta">spring.cloud.stream.instance-index</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure>
<p> 接着配置生产者 </p>
<p>spring.cloud.stream.bindings.output.producer.partition-key-expression=payload   指定了分区键的表达式规则</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.stream.bindings.output.producer.partition-count</span>=<span class="string">2  指定了消息分区的数量</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.output.producer.partition-key-expression</span>=<span class="string">payload</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.output.producer.partition-count</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure>
<h3 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h3><p>类似于springmvc的消息转换器等等，Stream允许使用sprinc.cloud.stream.bindings.<channelname>.content-type 属性以声明式的配置方式为绑定的输入和输出通道设置消息内容的类型。</channelname></p>
<p>json——pojo</p>
<p>json——org.springframework.tuple.Tuple</p>
<p>object——-byte[]  传输序列化数据</p>
<p>string——–byte[]</p>
<p>object—–纯文本</p>
<h1 id="绑定器详解"><a href="#绑定器详解" class="headerlink" title="绑定器详解"></a>绑定器详解</h1><p> 最为关键的接口是Binder接口，它是用来将输入和输出连接到外部中间件的抽象。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Binder</span>&lt;<span class="title">T</span>, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">ConsumerProperties</span>, <span class="title">P</span> <span class="keyword">extends</span> <span class="title">ProducerProperties</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Binding&lt;T&gt; <span class="title">bindConsumer</span><span class="params">(String var1, String var2, T var3, C var4)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Binding&lt;T&gt; <span class="title">bindProducer</span><span class="params">(String var1, T var2, P var3)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用程序对输入和输出通道进行绑定的时候，实际上就是通过该接口的实现来完成的。</p>
<p>向消息通道发送数据的生产者调用bindProducer方法来绑定输出通道时，第一个参数代表了发往消息中间件的目标名称，第二个参数代表了发送消息的本地通道实例，第三个参数是用来创建通道时使用的属性配置（比如分区键的表达式等）。<br>从消息通道接受数据的消费者调用bindConsumer方法来绑定输入通道时，第一个参数代表了接受消息中间件的目标名称，第二个参数代表了消费组的名称（如果多个消费者实例使用相同的组名，则消息将对这些消费者实例实现负载均衡，每个生产者发出的消息只会被组内一个消费者实例接受接受和处理），第三个参数代表了接受消息的本地通道实例，第四个参数是用来创建通道时使用的属性配置。<br>一个典型的Binder绑定器实现一般包含以下内容。</p>
<p>一个实现Binder接口的类<br>一个Spring配置加载类，用来创建连接消息中间件的基础结构使用的实例。<br>一个或多个能够在classpath下的META-INF/spring.binders路径找到的绑定器定义文件。比如我们可以再spring-cloud-starter-stream-rabbit中找到该文件，该文件中存储了当前绑定器要使用的自动化配置类的路径：</p>
<h1 id="自动化配置"><a href="#自动化配置" class="headerlink" title="自动化配置"></a>自动化配置</h1><p>Spring Cloud Stream 通过绑定器SPI的实现应用程序逻辑上的输入输出通道连接到物理上的消息中间件。为了适应多个消息中间件的差异，所以需要实现各自的绑定器</p>
<p>下面的依赖包括了rabbitmq的binder依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>多绑定器配置<br>就是说可以同时用多种消息中间件</p>
<p>首先如果我们需要默认为某种绑定器的时候，比如默认为rabbit的绑定器</p>
<p>spring.cloud.stream.default-binder=rabbit<br>对于一些少数的消息通道需要单独设置绑定器,通过上面的配置我们可以发现我们是直接写rabbit和kafka，但是这不是代表名字，而是某个配置文件的别名。</p>
<p>spring.cloud.stream.bindings.input.binder=kafka<br>对需要使用多个消息中间件，例如消息输入通道和消息输出通道使用不同的消息中间件.显示指定配置别名后会自动禁用默认的绑定器配置，所以我们需要使用spring.cloud.stream.binders.<configurationname>属性来进行设置</configurationname></p>
<p>spring.cloud.stream.bindings.input.binder=rabbit1<br>spring.cloud.stream.bindings.output.binder=rabbit2</p>
<p>spring.cloud.stream.binders.rabbit1.type=rabbit<br>spring.cloud.stream.binders.rabbit1.environment.spring.rabbitmq.host=localhost<br>spring.cloud.stream.binders.rabbit1.environment.spring.rabbitmq.port=5672<br>spring.cloud.stream.binders.rabbit1.environment.spring.rabbitmq.username=guest<br>spring.cloud.stream.binders.rabbit1.environment.spring.rabbitmq.password=guest</p>
<p>spring.cloud.stream.binders.rabbit2.type=rabbit<br>spring.cloud.stream.binders.rabbit2.environment.spring.rabbitmq.host=192.168.88.8<br>spring.cloud.stream.binders.rabbit2.environment.spring.rabbitmq.port=5672<br>spring.cloud.stream.binders.rabbit2.environment.spring.rabbitmq.username=guest<br>spring.cloud.stream.binders.rabbit2.environment.spring.rabbitmq.password=guest<br>以下是对绑定器的一些属性配置 </p>
<p>spring.cloud.stream.binders.<configurationname>.type 指定了绑定器类型<br>spring.cloud.stream.binders.<configurationname>.environment 用来设置各种绑定器属性<br>spring.cloud.stream.binders.<configurationname>.inheritEnvironment=true 当前绑定器是否继承应用程序自身额环境配置<br>spring.cloud.stream.binders.<configurationname>.defaultCandidate=true 设置当前绑定器配置是否被视为默认绑定器的候选项  </configurationname></configurationname></configurationname></configurationname></p>
<h1 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h1><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>下面是spring cloud stream 应用级别的通用基础属性，这些属性都以spring.cloud.stream 为前缀</p>
<p>instanceCount=1 应用程序部署的实例数量。当使用Kafka的时候需要设置分区<br>instanceIndex  应用程序实例的索引，该值从0开始，最大值设置为-1.当使用分区和kafka的时候使用<br>dynamicDestinations 动态绑定的目标列表，该列表默认为空，当设置了具体列表之后，只有列表中的目标才能发现<br>defaultBinder 默认绑定器配置，在应用程序中有多个绑定器时使用<br>绑定通道配置<br>绑定通道分别为输入通道和输出通道，所以在绑定通道的配置中包含了三类面向不同通道类型的配置：通用配置、消费者配置、生产者配置</p>
<h2 id="通用配置"><a href="#通用配置" class="headerlink" title="通用配置"></a>通用配置</h2><p>下面省略spring.cloud.stream.bindings.<channelname>.前缀</channelname></p>
<p>destination  配置Topic名称，也就是exchange名称 ，如果是消费者可以配置多个并且用逗号隔开<br>group  消费组<br>contentType 消息类型<br>binder 指定那个具体的绑定器</p>
<h2 id="消费者配置"><a href="#消费者配置" class="headerlink" title="消费者配置"></a>消费者配置</h2><p>仅对消费者有效，下面省略spring.cloud.stream.bindings.<channelname>.consumer 前缀</channelname></p>
<p>concurrency 输入通道消费者的并发数，默认为1<br>partitioned 是否采用分区，默认false<br>headerMode 当设置为raw的时候将禁用对消息头的解析。该属性只有在使用不支持消息头功能的中间件时有效，因为Spring Cloud Stream 默认会解析嵌入的头部信息 ，默认值embeddedHeaders<br>maxAttempts 对输入通道消息处理的最大重试次数，默认值3<br>backOffInitialInterval  重试消息处理的初始间隔时间 ，默认1000<br>backOffMaxInterval 重试消息处理的最大间隔时间，默认为10000<br>backOffMultiplier 重试消息处理时间间隔的递增乘数 2.0</p>
<h2 id="生产者配置"><a href="#生产者配置" class="headerlink" title="生产者配置"></a>生产者配置</h2><p>仅对生产者者有效，下面省略spring.cloud.stream.bindings.<channelname>.producer 前缀</channelname></p>
<p>partitionKeyExpression 配置输出通道数据分区键的SpEL表达式。当设置该属性后，将对绑定通道的输出数据进行分区处理。同时，partitionCount参数必须大于1才能生效。<br>partitionKeyExtractorClass 配置分区键提取策略接口PartitionKeyExtractionStrategy 的实现。当设置该属性之后，将对当前绑定通道的输出数据进行分区处理。同时，partitionCount参数必须大于1才能生效，该参数与partitionKeyExpression互斥，不能同时使用<br>partitionSelectorClass 该参数用来指定分区选择器的接口PartitionSelectorStrategy的实现，如果两者都没设置，那么默认计算规则为hashCode(key)%partitionCount，这里的key根据上面的配置得到<br>partitionSelectorExpression  该参数用来设置自定义分区的选择器的SpEL表达式<br>headerMode  当设置为raw的时候将禁用对消息头的解析。该属性只有在使用不支持消息头功能的中间件时有效，因为Spring Cloud Stream 默认会解析嵌入的头部信息 ，默认值embeddedHeaders<br>绑定器配置<br>由于Stream只实现了kafka和rabbitmq的实现，所以下面只讲这两种实现</p>
<h2 id="RabbitMQ配置"><a href="#RabbitMQ配置" class="headerlink" title="RabbitMQ配置"></a>RabbitMQ配置</h2><h3 id="通用配置-1"><a href="#通用配置-1" class="headerlink" title="通用配置"></a>通用配置</h3><p>由于rabbitmq默认使用了spring boot 的ConnectFactory，所以Rabbitmq绑定器支持在Spring boot 中的配置选项，他们以spring.rabbitmq为前缀</p>
<p>在Spring Cloud Stream 对RabbitMQ时下的绑定器中，以spring.cloud.stream.rabbit.binder 为前缀</p>
<p>adminAddresses 该参数用来配置RabbitMQ管理插件的URL,当需要配置多个时用逗号分隔。该参数只有在nodes参数包含多个时使用，并且这里配置的内容必须在spring.rabbitmq.address 中存在<br>nodes 该参数用来配置RabbitMQ的节点名称，用逗号隔开，并且这里配置的内容必须在spring.rabbitmq.address 中存在。<br>compressinLevel 绑定通道的压缩级别，它的具体可选值及含义可见java.util.zip.Deflater的定义</p>
<h3 id="消费者配置-1"><a href="#消费者配置-1" class="headerlink" title="消费者配置"></a>消费者配置</h3><p>仅对消费者有效，下面省略spring.cloud.stream.rabbit.bindings.<channelname>.consumer 前缀</channelname></p>
<p>acknowledgeMode  用来设置消息的确认模式，可写：NONE、MANUAL、AUTO，默认值为AUTO<br>autoBindDlq 用来设置是否自动声明DLQ（queue），并绑定到DLX(exchange)上<br>durableSubScription 用来设置订阅是否被持久化，该参数被设置时有效。默认为true<br>maxConcurrency 用来设置消费者的最大并发数 ，默认为1<br>prefetch 用来设置预取数量，它表示在一次会话中从消息中间件中获取的消息数量，该值越大消息处理越快，但是会导致非顺序处理的风险。默认为1<br>prefix 用来设置统一的目标和队列名称前缀<br>recoveryInterval 用来设置恢复连接的尝试时间间隔，默认为5000<br>requeueRejected 用来设置消息传递失败时重传，默认为true<br>requestHeaderPatterns 用来设置需要被传递的请求头信息<br>replyHeaderPatterns 用来设置需要被传递的响应头信息<br>republishToDlq 默认情况下，消息在重试也失败之后会被拒绝。如果DLQ被配置的时候，RabbitMQ会将失败的消息路由到DLQ中。如果该参数被设置为true ,总线会将失败的消息附加一些头信息（包括异常信息，引入失败的跟踪堆栈）之后重新发布到DLQ中<br>transacted 用来设置是否启用channeltransacted 是否在消息中使用事务 ，默认false<br>txSize 用来设置transaction-size 的数量，当acknowledgeMode被设置为AUTO时候，容器会在处理txSize 数目消息之后才开始应答，默认为1</p>
<h3 id="生产者配置-1"><a href="#生产者配置-1" class="headerlink" title="生产者配置"></a>生产者配置</h3><p>仅对生产者者有效，下面省略spring.cloud.stream.rabbit.bindings.<channelname>.producer 前缀</channelname></p>
<p>autoBindDlq 用来设置是否自动声明DLQ（queue），并绑定到DLX(exchange)上<br>batchindEnabled 是否启用消息批处理 ，默认false<br>batchSize 当批处理开启时，用在设置缓存的批处理消息数量，默认为100<br>batchBufferLimit 批处理缓存限制 ，默认为10000<br>batchTimeout 批处理超时时间，默认5000<br>compress 消息发送时是否启用压缩 ，默认false<br>deliveryMode 消息发送模式 ,默认PERSISTENT<br>prefix 用来设置统一的目标前缀<br>requestHeaderPatterns 用来设置需要被传递的请求头信息<br>replyHeaderPatterns 用来设置需要被传递的响应头信息 </p>
<h2 id="KafKa配置"><a href="#KafKa配置" class="headerlink" title="KafKa配置"></a>KafKa配置</h2><h3 id="通用配置-2"><a href="#通用配置-2" class="headerlink" title="通用配置"></a>通用配置</h3><p>在Spring Cloud Stream 对kafka时下的绑定器中，以spring.cloud.stream.kafka.binder 为前缀</p>
<p>brokers =localhost：Kafka绑定器连接的消息中间件列表。需要配置多个时用逗号分隔，每个地址可以是单独的host,也可以是host:port 的形式<br>defaultBrokerPort=9092 ：用来设置默认的消息中间件端口号。当brokers中的配置地址没有包含端口信息时，将使用该参数配置的默认端口进行连接<br>zkNodes=localhost ：kakfa绑定器使用的Zookeeper端口号，当brokers中的配置地址没有包含端口信息时，将使用该参数配置的默认端口进行配置<br>defaultZKport=2181 : 用来设置默认的Zookeeper端口号。当zKNodes 中的配置地址没有包含端口信息时，将使用该参数配置的默认端口进行连接<br>headers : 用来设置会被传输的自定义头信息<br>offsetUpdateCountTImeout =10000: 用来设置offset的更新频率，以毫秒为单位，如果设置为0则忽略<br>offsetUpdateCount=0 : 用来设置offset以次数表示的更新频率，如果为0则忽略，该参数与offsetUpdateCountTImeout互斥<br>requireAcks =1：用来设置确认消息的数量<br>minParttitionCount 该参数仅在设置了autoCreateTopics和autoAddParttions时生效，用来设置该绑定器所使用主题的全局分区最小数量。如果当生产者的parttionCount的参数或instanceCount*concurrency 设置大于该参数配置时，该参数值将被覆盖<br>replicationFactor=1 当autoCreateTopics 参数为true时候，用来配置自动创建主题的副本数量<br>autoCreateTopics=true 该参数默认为true,绑定器会自动地创建新主题。如果设置为false,那么绑定器将使用已经配置的主题，但是在这种情况下，如果需要使用的主题不存在，绑定器会启动失败<br>huautoAddPartition=false 该参数默认为false,绑定器会根据已经配置的主题分区来实现，如果目标主题的分区数小于预期值，那么绑定器会启动失败。如果该参数设置为true,绑定器将在需要的时候自动创建新的分区<br>socketBufferSize =2097152 该参数用来设置KafKa 的Socket的缓存大小</p>
<h3 id="消费者配置-2"><a href="#消费者配置-2" class="headerlink" title="消费者配置"></a>消费者配置</h3><p>仅对消费者有效，下面省略spring.cloud.stream.kafka.bindings.<channelname>.consumer 前缀</channelname></p>
<p>autoCommitOffset=true ：用来设置是否在处理消息时自动提交offset。如果设置为false,在消息头 中会加入ACK头消息以实现延迟确认。<br>autoCommitOnError ：该参数只有在autoCommitOffset设置为true时才有效。当设置为false的时候，引起错误消息不会自动提交offset,仅提交成功消息的offset。如果设置为true,不论消息是否成功，都会自动提交。当不设置该值时，它实际上具有与enabledDlq相同配置<br>reconveryInterval =5000 ：尝试恢复连接的时间间隔，以毫秒为单位<br>resetOffsets =false ：是否使用提供的startOffset 值来重置消费者的offset值<br>startOffset =null : 用来设置新建组的起始offset,该值也会在resetOffsets开始时被使用<br>enableDlq =false : 该参数设置为true时，将为消费者启用DLQ行为，引起错误的消息将被发送到名为error.<destination>.<group>的主题去</group></destination></p>
<h3 id="生产者配置-2"><a href="#生产者配置-2" class="headerlink" title="生产者配置"></a>生产者配置</h3><p>仅对生产者者有效，下面省略spring.cloud.stream.kafka.bindings.<channelname>.producer 前缀</channelname></p>
<p>bufferSize = 16384 Kafka批量发送前的缓存数据上限，以字节为单位<br>sync=false 该参数用来设置Kafka消息生产者的发送模式，默认为false,即采用async配置，允许批量发送数据。当设置为true时，将采用sync配置，消息将不会被批量发送，而是一条一条发送<br>batchTimeout=0 消息生产者批量发送时，为了积累更多发送数据而设置的等待时间。通常情况下，生产者基本不会等待，而是直接发送所有在前一批此发送时基类的消息数据。当我们设置一个非0值时，可以以延迟为代价来增加系统的吞吐量</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>spring cloud</tag>
        <tag>stream</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud zuul集成管理swagger</title>
    <url>/2020/06/13/spring-cloud-zuul%E9%9B%86%E6%88%90%E7%AE%A1%E7%90%86swagger/</url>
    <content><![CDATA[<h1 id="spring-cloud-zuul-监听多个swagger2"><a href="#spring-cloud-zuul-监听多个swagger2" class="headerlink" title="spring cloud zuul 监听多个swagger2"></a>spring cloud zuul 监听多个swagger2</h1><h2 id="swagger服务"><a href="#swagger服务" class="headerlink" title="swagger服务"></a>swagger服务</h2><p>创建一个项目添加了swagger的项目，我这里使用的是已有一个项目schedule</p>
<p>引入swagger依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile <span class="string">group:</span> <span class="string">'io.springfox'</span>, <span class="string">name:</span> <span class="string">'springfox-swagger-ui'</span>, <span class="string">version:</span> <span class="string">'2.7.0'</span></span><br><span class="line">compile <span class="string">group:</span> <span class="string">'io.springfox'</span>, <span class="string">name:</span> <span class="string">'springfox-swagger2'</span>, <span class="string">version:</span> <span class="string">'2.7.0'</span></span><br></pre></td></tr></table></figure>
<p>添加swagger的配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.panghu"</span>))</span><br><span class="line">                .apis(RequestHandlerSelectors.withClassAnnotation(Api<span class="class">.<span class="keyword">class</span>))</span></span><br><span class="line"><span class="class">                .<span class="title">apis</span>(<span class="title">RequestHandlerSelectors</span>.<span class="title">withMethodAnnotation</span>(<span class="title">ApiOperation</span>.<span class="title">class</span>))</span></span><br><span class="line"><span class="class">                .<span class="title">paths</span>(<span class="title">PathSelectors</span>.<span class="title">any</span>())</span></span><br><span class="line"><span class="class">                .<span class="title">build</span>()</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">"schedule系统接口文档"</span>)</span><br><span class="line">                .description(<span class="string">"这是系统接口文档说明"</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> Contact(<span class="string">"panghu"</span>, <span class="string">"panghu的博客URL"</span>, <span class="string">"XXXX@qq.com"</span>))</span><br><span class="line">                .version(<span class="string">"1.0"</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">UiConfiguration <span class="title">uiConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UiConfiguration(<span class="keyword">null</span>, <span class="string">"list"</span>, <span class="string">"alpha"</span>, <span class="string">"schema"</span>,</span><br><span class="line">                UiConfiguration.Constants.DEFAULT_SUBMIT_METHODS, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="number">60000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个方法来测试swagger的文档</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api</span>(tags = <span class="string">"swagger测试"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/users"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"simpleTest"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"简单接口测试"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"简单接口测试"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/bodyTest"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"body参数测试"</span>, notes = <span class="string">"接收body参数测试"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bodyTest</span><span class="params">(@RequestBody ManualVo manualVo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"paramsDescTest"</span>)</span><br><span class="line">    <span class="meta">@ApiImplicitParam</span>(paramType = <span class="string">"path"</span>, dataType = <span class="string">"Long"</span>, name = <span class="string">"id"</span>, value = <span class="string">"这是id的描述"</span>, required = <span class="keyword">true</span>, example = <span class="string">"1"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"更新用户详细信息"</span>, notes = <span class="string">"根据url的id来指定更新对象，并根据传过来的user信息来更新用户详细信息"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">putUser</span><span class="params">(@PathVariable Long id, @RequestBody ManualVo manualVo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//api的model</span></span><br><span class="line"><span class="meta">@ApiModel</span>(description = <span class="string">"参数VO"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManualVo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"id参数"</span>)</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"参数字符串"</span>)</span><br><span class="line">    <span class="keyword">private</span> String param;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在启动类上添加swagger注解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableSwagger2</span><br><span class="line">@SpringCloudApplication</span><br><span class="line">@EnableJpaAuditing</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建网关服务-zuul"><a href="#创建网关服务-zuul" class="headerlink" title="创建网关服务 zuul"></a>创建网关服务 zuul</h2><p>前两部与其他服务相同，引入swagger和网关依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile <span class="string">group:</span> <span class="string">'io.springfox'</span>, <span class="string">name:</span> <span class="string">'springfox-swagger-ui'</span>, <span class="string">version:</span> <span class="string">'2.7.0'</span></span><br><span class="line">compile <span class="string">group:</span> <span class="string">'io.springfox'</span>, <span class="string">name:</span> <span class="string">'springfox-swagger2'</span>, <span class="string">version:</span> <span class="string">'2.7.0'</span></span><br><span class="line">implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-zuul'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class Swagger2Config &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi() &#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;系统集成api&quot;)</span><br><span class="line">                .description(&quot;系统接口集成文档说明&quot;)</span><br><span class="line">                .contact(new Contact(&quot;panghu&quot;, &quot;xxxx&quot;, &quot;xxx@qq.com&quot;))</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加读取的swagger配置"><a href="#添加读取的swagger配置" class="headerlink" title="添加读取的swagger配置"></a>添加读取的swagger配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Primary</span><br><span class="line">public class DocumentationConfig implements SwaggerResourcesProvider &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;SwaggerResource&gt; get() &#123;</span><br><span class="line">        List&lt;SwaggerResource&gt; resources = new ArrayList&lt;&gt;();</span><br><span class="line">        //这一步添加需要监听的swagger</span><br><span class="line">        resources.add(swaggerResource(&quot;schedule 服务&quot;, &quot;/schedule/v2/api-docs&quot;, &quot;1.0&quot;));</span><br><span class="line">        return resources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private SwaggerResource swaggerResource(String name, String location, String version) &#123;</span><br><span class="line">        SwaggerResource swaggerResource = new SwaggerResource();</span><br><span class="line">        swaggerResource.setName(name);</span><br><span class="line">        swaggerResource.setLocation(location);</span><br><span class="line">        swaggerResource.setSwaggerVersion(version);</span><br><span class="line">        return swaggerResource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在网关的bootstrap.properties中配置路径转发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#服务名路径转发</span><br><span class="line">zuul.routes.schedule=/schedule/**</span><br></pre></td></tr></table></figure>
<p>启动两个服务之后，打开网关的swagger地址 <a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a></p>
<p><img src="/2020/06/13/spring-cloud-zuul集成管理swagger/swagger.png" alt></p>
]]></content>
      <categories>
        <category>spring cloud alibaba</category>
      </categories>
      <tags>
        <tag>nacos</tag>
        <tag>spring cloud alibaba</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud 服务网关</title>
    <url>/2019/11/26/spring-cloud-%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/</url>
    <content><![CDATA[<h1 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h1><p> 之前几篇Spring Cloud中几个核心组件的介绍，我们已经可以构建一个简略的（不够完善）微服务架构了。比如下图所示： </p>
<p><img src="/2019/11/26/spring-cloud-服务网关/struct.png" alt></p>
<p> 我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。 </p>
<p> 在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。 </p>
<ul>
<li>首先，破坏了服务无状态特点。为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外可续对接口访问的控制处理。</li>
<li><p>其次，无法直接复用既有接口。当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。</p>
<p>为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器，它就是本文将来介绍的：服务网关。 </p>
<pre><code>服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。 
</code></pre></li>
</ul>
<h2 id="构建服务网关"><a href="#构建服务网关" class="headerlink" title="构建服务网关"></a>构建服务网关</h2><p> Spring Cloud Zuul来构建服务网关 </p>
<p>添加服务网关的依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'</span></span><br><span class="line">implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-eureka-server'</span></span><br><span class="line">implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-zuul'</span></span><br></pre></td></tr></table></figure>
<p>在启动类上添加服务网关注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiGatewayApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(ApiGatewayApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改配置文件application.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础信息配置</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">api-gateway</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">5679</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 路由规则配置</span></span><br><span class="line"><span class="comment">#zuul.routes.api-a.path=/demo/**</span></span><br><span class="line"><span class="comment">#zuul.routes.api-a.serviceId=practice</span></span><br><span class="line"><span class="meta">zuul.routes.ribbon-1</span>=<span class="string">/mypath/**</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># API网关也将作为一个服务注册到eureka-server上</span></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:5678/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注册中心上ip地址显示</span></span><br><span class="line"><span class="meta">eureka.instance.prefer-ip-address</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">eureka.instance.instance-id</span>=<span class="string">$&#123;spring.cloud.client.ipAddress&#125;:$&#123;server.port&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置服务注销事件(秒)</span></span><br><span class="line"><span class="meta">eureka.instance.lease-renewal-interval-in-seconds</span>=<span class="string">5</span></span><br><span class="line"><span class="meta">eureka.instance.lease-expiration-duration-in-seconds</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure>
<p>启动服务注册中心 eureka-service,服务消费则ribbon-1 ,服务网关api-gateway ,直接请求Hystrix-demo1的路径是localhost:5888/consumer，通过网关调用时，路劲可以写成 localhosy:5679/ribbon-1/consumer</p>
<h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><h3 id="传统路由配置"><a href="#传统路由配置" class="headerlink" title="传统路由配置"></a>传统路由配置</h3><p> 所谓的传统路由配置方式就是在不依赖于服务发现机制的情况下，通过在配置文件中具体指定每个路由表达式与服务实例的映射关系来实现API网关对外部请求的路由。 </p>
<p> 单实例配置：通过一组<code>zuul.routes..path</code>与<code>zuul.routes..url</code>参数对的方式配置，比如： </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">zuul.routes.user-service.path</span>=<span class="string">/user-service/**</span></span><br><span class="line"><span class="meta">zuul.routes.user-service.url</span>=<span class="string">http://localhost:8080/</span></span><br></pre></td></tr></table></figure>
<p> 该配置实现了对符合<code>/user-service/**</code>规则的请求路径转发到<code>http://localhost:8080/</code>地址的路由规则，比如，当有一个请求<code>http://localhost:5679/user-service/hello</code>被发送到API网关上，由于<code>/user-service/hello</code>能够被上述配置的<code>path</code>规则匹配，所以API网关会转发请求到<code>http://localhost:8080/hello</code>地址。 </p>
<p> 多实例配置：通过一组<code>zuul.routes..path</code>与<code>zuul.routes..serviceId</code>参数对的方式配置，比如： </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">zuul.routes.user-service.path</span>=<span class="string">/user-service/**</span></span><br><span class="line"><span class="meta">zuul.routes.user-service.serviceId</span>=<span class="string">user-service</span></span><br><span class="line"></span><br><span class="line"><span class="meta">ribbon.eureka.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">user-service.ribbon.listOfServers</span>=<span class="string">http://localhost:8080/,http://localhost:8081/</span></span><br></pre></td></tr></table></figure>
<p>该配置实现了对符合<code>/user-service/**</code>规则的请求路径转发到<code>http://localhost:8080/</code>和<code>http://localhost:8081/</code>两个实例地址的路由规则。它的配置方式与服务路由的配置方式一样，都采用了<code>zuul.routes..path</code>与<code>zuul.routes..serviceId</code>参数对的映射方式，只是这里的<code>serviceId</code>是由用户手工命名的服务名称，配合<code>.ribbon.listOfServers</code>参数实现服务与实例的维护。由于存在多个实例，API网关在进行路由转发时需要实现负载均衡策略，于是这里还需要Spring Cloud Ribbon的配合。由于在Spring Cloud Zuul中自带了对Ribbon的依赖，所以我们只需要做一些配置即可，比如上面示例中关于Ribbon的各个配置，它们的具体作用如下：</p>
<ul>
<li><code>ribbon.eureka.enabled</code>：由于<code>zuul.routes..serviceId</code>指定的是服务名称，默认情况下Ribbon会根据服务发现机制来获取配置服务名对应的实例清单。但是，该示例并没有整合类似Eureka之类的服务治理框架，所以需要将该参数设置为false，不然配置的<code>serviceId</code>是获取不到对应实例清单的。</li>
<li><code>user-service.ribbon.listOfServers</code>：该参数内容与<code>zuul.routes..serviceId</code>的配置相对应，开头的<code>user-service</code>对应了<code>serviceId</code>的值，这两个参数的配置相当于在该应用内部手工维护了服务与实例的对应关系。</li>
</ul>
<p>不论是单实例还是多实例的配置方式，我们都需要为每一对映射关系指定一个名称，也就是上面配置中的<code>，每一个</code>就对应了一条路由规则。每条路由规则都需要通过<code>path</code>属性来定义一个用来匹配客户端请求的路径表达式，并通过<code>url</code>或<code>serviceId</code>属性来指定请求表达式映射具体实例地址或服务名。</p>
<h3 id="服务路由配置"><a href="#服务路由配置" class="headerlink" title="服务路由配置"></a>服务路由配置</h3><p>服务路由我们在上一篇中也已经有过基础的介绍和体验，Spring Cloud Zuul通过与Spring Cloud Eureka的整合，实现了对服务实例的自动化维护，所以在使用服务路由配置的时候，我们不需要向传统路由配置方式那样为<code>serviceId</code>去指定具体的服务实例地址，只需要通过一组<code>zuul.routes..path</code>与<code>zuul.routes..serviceId</code>参数对的方式配置即可。</p>
<p>比如下面的示例，它实现了对符合<code>/user-service/**</code>规则的请求路径转发到名为<code>user-service</code>的服务实例上去的路由规则。其中<code></code>可以指定为任意的路由名称。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">zuul.routes.user-service.path</span>=<span class="string">/user-service/**</span></span><br><span class="line"><span class="meta">zuul.routes.user-service.serviceId</span>=<span class="string">user-service</span></span><br></pre></td></tr></table></figure>
<p> 对于面向服务的路由配置，除了使用<code>path</code>与<code>serviceId</code>映射的配置方式之外，还有一种更简洁的配置方式：<code>zuul.routes.=</code>，其中<code>用来指定路由的具体服务名，</code>用来配置匹配的请求表达式。比如下面的例子，它的路由规则等价于上面通过<code>path</code>与<code>serviceId</code>组合使用的配置方式。 </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">zuul.routes.user-service</span>=<span class="string">/user-service/**</span></span><br></pre></td></tr></table></figure>
<p> 传统路由的映射方式比较直观且容易理解，API网关直接根据请求的URL路径找到最匹配的<code>path</code>表达式，直接转发给该表达式对应的<code>url</code>或对应<code>serviceId</code>下配置的实例地址，以实现外部请求的路由。那么当采用<code>path</code>与<code>serviceId</code>以服务路由方式实现时候，没有配置任何实例地址的情况下，外部请求经过API网关的时候，它是如何被解析并转发到服务具体实例的呢？ </p>
<p> 在Spring Cloud Netflix中，Zuul巧妙的整合了Eureka来实现面向服务的路由。实际上，我们可以直接将API网关也看做是Eureka服务治理下的一个普通微服务应用。它除了会将自己注册到Eureka服务注册中心上之外，也会从注册中心获取所有服务以及它们的实例清单。所以，在Eureka的帮助下，API网关服务本身就已经维护了系统中所有serviceId与实例地址的映射关系。当有外部请求到达API网关的时候，根据请求的URL路径找到最佳匹配的<code>path</code>规则，API网关就可以知道要将该请求路由到哪个具体的<code>serviceId</code>上去。 </p>
<h2 id="过滤器示例"><a href="#过滤器示例" class="headerlink" title="过滤器示例"></a>过滤器示例</h2><p> 通过上面所述的两篇我们，我们已经能够实现请求的路由功能，所以我们的微服务应用提供的接口就可以通过统一的API网关入口被客户端访问到了。但是，每个客户端用户请求微服务应用提供的接口时，它们的访问权限往往都需要有一定的限制，系统并不会将所有的微服务接口都对它们开放。然而，目前的服务路由并没有限制权限这样的功能，所有请求都会被毫无保留地转发到具体的应用并返回结果，为了实现对客户端请求的安全校验和权限控制，最简单和粗暴的方法就是为每个微服务应用都实现一套用于校验签名和鉴别权限的过滤器或拦截器。不过，这样的做法并不可取，它会增加日后的系统维护难度，因为同一个系统中的各种校验逻辑很多情况下都是大致相同或类似的，这样的实现方式会使得相似的校验逻辑代码被分散到了各个微服务中去，冗余代码的出现是我们不希望看到的。所以，比较好的做法是将这些校验逻辑剥离出去，构建出一个独立的鉴权服务。在完成了剥离之后，有不少开发者会直接在微服务应用中通过调用鉴权服务来实现校验，但是这样的做法仅仅只是解决了鉴权逻辑的分离，并没有在本质上将这部分不属于业余的逻辑拆分出原有的微服务应用，冗余的拦截器或过滤器依然会存在。 </p>
<p>由于网关服务的加入，外部客户端访问我们的系统已经有了统一入口，既然这些校验与具体业务无关，那何不在请求到达的时候就完成校验和过滤，而不是转发后再过滤而导致更长的请求延迟。同时，通过在网关中完成校验和过滤，微服务应用端就可以去除各种复杂的过滤器和拦截器了，这使得微服务应用的接口开发和测试复杂度也得到了相应的降低。</p>
<p>为了在API网关中实现对客户端请求的校验，我们将需要使用到Spring Cloud Zuul的另外一个核心功能：<strong>过滤器</strong>。</p>
<p> 我们定义了一个简单的Zuul过滤器，它实现了在请求被路由之前检查HttpServletRequest中是否有login参数，若有就进行路由，若没有就拒绝访问，返回401 Unauthorized错误。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulFilter</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">netflix</span>.<span class="title">zuul</span>.<span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * fileType的返回值类型表示为过滤器的类型，过滤器的类型表示在那个生命周期执行</span></span><br><span class="line"><span class="comment">     * pre,post,error,route,static</span></span><br><span class="line"><span class="comment">     * pre表示的是在路由之前执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示过滤器的执行顺序（多个过滤器时有意义）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *表示过滤器是否执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体的过滤规则</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = ctx.getRequest();</span><br><span class="line">        String login = request.getParameter( <span class="string">"login"</span> );</span><br><span class="line">        <span class="keyword">if</span>(login == <span class="keyword">null</span>)&#123;</span><br><span class="line">            ctx.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            ctx.setResponseStatusCode(<span class="number">401</span>);</span><br><span class="line">            ctx.addZuulResponseHeader(<span class="string">"content-type"</span>,<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">            ctx.setResponseBody(<span class="string">"无登陆信息"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在实现了自定义过滤器之后，它并不会直接生效，我们还需要为其创建具体的Bean才能启动该过滤器，比如，在应用主类中增加如下内容 ,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiGatewayApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(ApiGatewayApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function">ZuulFilter <span class="title">getZuulFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ZuulFilter();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新启动服务网关，再次访问 <a href="http://localhost:5679/mypath/consumer" target="_blank" rel="noopener">http://localhost:5679/mypath/consumer</a> ,页面显示</p>
<p><img src="/2019/11/26/spring-cloud-服务网关/gate.png" alt></p>
<p>这个时候通过网关必须携带login的信息  <a href="http://localhost:5679/mypath/consumer?login=2" target="_blank" rel="noopener">http://localhost:5679/mypath/consumer?login=2</a> </p>
<p> 到这里，对于Spring Cloud Zuul过滤器的基本功能就已介绍完毕。 </p>
<h2 id="zuul核心过滤器源码分析"><a href="#zuul核心过滤器源码分析" class="headerlink" title="zuul核心过滤器源码分析"></a>zuul核心过滤器源码分析</h2><p> 包含了对请求的路由和过滤两个功能，其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础；而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础。然而实际上，路由功能在真正运行时，它的路由映射和请求转发都是由几个不同的过滤器完成的。其中，路由映射主要通过pre类型的过滤器完成，它将请求路径与配置的路由规则进行匹配，以找到需要转发的目标地址；而请求转发的部分则是由route类型的过滤器来完成，对pre类型过滤器获得的路由地址进行转发。所以，过滤器可以说是Zuul实现API网关功能最为核心的部件，每一个进入Zuul的HTTP请求都会经过一系列的过滤器处理链得到请求响应并返回给客户端。 </p>
<p> Spring Cloud Zuul中实现的过滤器必须包含4个基本特征：过滤类型、执行顺序、执行条件、具体操作。这些元素看着似乎非常的熟悉，实际上它就是ZuulFilter接口中定义的四个抽象方法： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">filterType</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function">Object <span class="title">run</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>filterType：该函数需要返回一个字符串来代表过滤器的类型，而这个类型就是在HTTP请求过程中定义的各个阶段。在Zuul中默认定义了四种不同生命周期的过滤器类型，具体如下：<ul>
<li>pre：可以在请求被路由之前调用。</li>
<li>routing：在路由请求时候被调用。</li>
<li>post：在routing和error过滤器之后被调用。</li>
<li>error：处理请求时发生错误时被调用。</li>
</ul>
</li>
<li>filterOrder：通过int值来定义过滤器的执行顺序，数值越小优先级越高。</li>
<li>shouldFilter：返回一个boolean类型来判断该过滤器是否要执行。我们可以通过此方法来指定过滤器的有效范围。</li>
<li>run：过滤器的具体逻辑。在该函数中，我们可以实现自定义的过滤逻辑，来确定是否要拦截当前的请求，不对其进行后续的路由，或是在请求路由返回结果之后，对处理结果做一些加工等。</li>
</ul>
<h2 id="请求生命周期"><a href="#请求生命周期" class="headerlink" title="请求生命周期"></a>请求生命周期</h2><pre><code>Zuul默认定义了四个不同的过滤器类型，它们覆盖了一个外部HTTP请求到达API网关，直到返回请求结果的全部生命周期。下图源自Zuul的官方WIKI中关于请求生命周期的图解，它描述了一个HTTP请求到达API网关之后，如何在各个不同类型的过滤器之间流转的详细过程。 
</code></pre><p><img src="/2019/11/26/spring-cloud-服务网关/lifeCycle.png" alt></p>
<p> 当外部HTTP请求到达API网关服务的时候，首先它会进入第一个阶段pre，在这里它会被pre类型的过滤器进行处理，该类型的过滤器主要目的是在进行请求路由之前做一些前置加工，比如请求的校验等。在完成了pre类型的过滤器处理之后，请求进入第二个阶段routing，也就是之前说的路由请求转发阶段，请求将会被routing类型过滤器处理，这里的具体处理内容就是将外部请求转发到具体服务实例上去的过程，当服务实例将请求结果都返回之后，routing阶段完成，请求进入第三个阶段post，此时请求将会被post类型的过滤器进行处理，这些过滤器在处理的时候不仅可以获取到请求信息，还能获取到服务实例的返回信息，所以在post类型的过滤器中，我们可以对处理结果进行一些加工或转换等内容。另外，还有一个特殊的阶段error，该阶段只有在上述三个阶段中发生异常的时候才会触发，但是它的最后流向还是post类型的过滤器，因为它需要通过post过滤器将最终结果返回给请求客户端。 </p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>spring cloud</tag>
        <tag>zuul</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-事务</title>
    <url>/2020/10/16/spring-%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h1><ul>
<li>原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。</li>
<li>一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。</li>
<li>隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。</li>
<li>持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。</li>
</ul>
<h2 id="Spring事务的配置方式"><a href="#Spring事务的配置方式" class="headerlink" title="Spring事务的配置方式"></a>Spring事务的配置方式</h2><p>Spring支持编程式事务管理以及声明式事务管理两种方式。</p>
<h3 id="1-编程式事务管理"><a href="#1-编程式事务管理" class="headerlink" title="1. 编程式事务管理"></a>1. 编程式事务管理</h3><p>编程式事务管理是侵入性事务管理，使用TransactionTemplate或者直接使用PlatformTransactionManager，对于编程式事务管理，Spring推荐使用TransactionTemplate。</p>
<h3 id="2-声明式事务管理"><a href="#2-声明式事务管理" class="headerlink" title="2. 声明式事务管理"></a>2. 声明式事务管理</h3><p>声明式事务管理建立在AOP之上，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，执行完目标方法之后根据执行的情况提交或者回滚。<br>编程式事务每次实现都要单独实现，但业务量大功能复杂时，使用编程式事务无疑是痛苦的，而声明式事务不同，声明式事务属于无侵入式，不会影响业务逻辑的实现，只需要在配置文件中做相关的事务规则声明或者通过注解的方式，便可以将事务规则应用到业务逻辑中。</p>
<h2 id="事务的传播机制"><a href="#事务的传播机制" class="headerlink" title="事务的传播机制"></a>事务的传播机制</h2><p>事务的传播性一般用在事务嵌套的场景，比如一个事务方法里面调用了另外一个事务方法，那么两个方法是各自作为独立的方法提交还是内层的事务合并到外层的事务一起提交，这就是需要事务传播机制的配置来确定怎么样执行。</p>
<table>
<thead>
<tr>
<th>传播级别</th>
<th>传播机制</th>
</tr>
</thead>
<tbody>
<tr>
<td>PROPAGATION_REQUIRED</td>
<td>Spring默认的传播机制，能满足绝大部分业务需求，如果外层有事务，则当前事务加入到外层事务，一块提交，一块回滚。如果外层没有事务，新建一个事务执行</td>
</tr>
<tr>
<td>PROPAGATION_REQUES_NEW</td>
<td>该事务传播机制是每次都会新开启一个事务，同时把外层事务挂起，当前事务执行完毕，恢复上层事务的执行。如果外层没有事务，执行当前新开启的事务即可</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORT</td>
<td>如果外层有事务，则加入外层事务，如果外层没有事务，则直接使用非事务方式执行。完全依赖外层的事务</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORT</td>
<td>该传播机制不支持事务，如果外层存在事务则挂起，执行完当前代码，则恢复外层事务，无论是否异常都不会回滚当前的代码</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>该传播机制不支持外层事务，即如果外层有事务就抛出异常</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>与NEVER相反，如果外层没有事务，则抛出异常</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>该传播机制的特点是可以保存状态保存点，当前事务回滚到某一个点，从而避免所有的嵌套事务都回滚，即各自回滚各自的，如果子事务没有把异常吃掉，基本还是会引起全部回滚的。</td>
</tr>
</tbody>
</table>
<h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><p>事务的隔离级别定义一个事务可能受其他并发务活动活动影响的程度。</p>
<p>在介绍隔离级别之前，先介绍几个概念</p>
<ul>
<li>脏读（Dirty read）<br>脏读发生在一个事务读取了被另一个事务改写但尚未提交的数据时。如果这些改变在稍后被回滚了，那么第一个事务读取的数据就会是无效的。</li>
<li>不可重复读（Nonrepeatable read）<br>不可重复读发生在一个事务执行相同的查询两次或两次以上，但每次查询结果都不相同时。这通常是由于另一个并发事务在两次查询之间更新了数据。</li>
<li>幻读（Phantom reads）<br>幻读和不可重复读相似。当一个事务（T1）读取几行记录后，另一个并发事务（T2）插入了一些记录时，幻读就发生了。在后来的查询中，第一个事务（T1）就会发现一些原来没有的额外记录。</li>
</ul>
<p>在理想状态下，事务之间将完全隔离，从而可以防止这些问题发生。然而，完全隔离会影响性能，因为隔离经常涉及到锁定在数据库中的记录（甚至有时是锁表）。完全隔离要求事务相互等待来完成工作，会阻碍并发。</p>
<table>
<thead>
<tr>
<th><strong>隔离级别</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>ISOLATION_DEFAULT</td>
<td>使用后端数据库默认的隔离级别</td>
</tr>
<tr>
<td>ISOLATION_READ_UNCOMMITTED</td>
<td>允许读取尚未提交的更改。可能导致脏读、幻读或不可重复读。</td>
</tr>
<tr>
<td>ISOLATION_READ_COMMITTED</td>
<td>（Oracle 默认级别）允许从已经提交的并发事务读取。可防止脏读，但幻读和不可重复读仍可能会发生。</td>
</tr>
<tr>
<td>ISOLATION_REPEATABLE_READ</td>
<td>（MYSQL默认级别）对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻读仍可能发生。</td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td>完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。</td>
</tr>
</tbody>
</table>
<h1 id="只读"><a href="#只读" class="headerlink" title="只读"></a>只读</h1><p>@Transactional(readOnly=true)<br>该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false</p>
<p>如果一个事务只对数据库执行读操作，那么该数据库就可能利用那个事务的只读特性，采取某些优化措施。通过把一个事务声明为只读，可以给后端数据库一个机会来应用那些它认为合适的优化措施。由于只读的优化措施是在一个事务启动时由后端数据库实施的， 因此，只有对于那些具有可能启动一个新事务的传播行为（PROPAGATION_REQUIRES_NEW、PROPAGATION_REQUIRED、 ROPAGATION_NESTED）的方法来说，将事务声明为只读才有意义。</p>
<h1 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h1><p>@Transactional(timeout=30)</p>
<p>该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false。</p>
<p>为了使一个应用程序很好地执行，它的事务不能运行太长时间。因此，声明式事务的下一个特性就是它的超时。</p>
<p>假设事务的运行时间变得格外的长，由于事务可能涉及对数据库的锁定，所以长时间运行的事务会不必要地占用数据库资源。这时就可以声明一个事务在特定秒数后自动回滚，不必等它自己结束。</p>
<p>由于超时时钟在一个事务启动的时候开始的，因此，只有对于那些具有可能启动一个新事务的传播行为（PROPAGATION_REQUIRES_NEW、PROPAGATION_REQUIRED、ROPAGATION_NESTED）的方法来说，声明事务超时才有意义。</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud 链路追踪</title>
    <url>/2020/06/24/spring-cloud-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</url>
    <content><![CDATA[<h1 id="Spring-cloud-服务链路追踪"><a href="#Spring-cloud-服务链路追踪" class="headerlink" title="Spring cloud 服务链路追踪"></a>Spring cloud 服务链路追踪</h1><p>Spring Cloud Sleuth 主要功能就是在分布式系统中提供追踪解决方案，并且兼容支持了 zipkin，zipkin为分布式链路调用监控系统，聚合各业务系统调用延迟数据，达到链路调用监控跟踪。</p>
<p>随着微服务数量不断增长，它们之间的关系会越来越复杂，如果链路上任何一个服务出现问题或者网络超时，都会形成导致接口调用失败，需要跟踪一个请求从一个微服务到下一个微服务的传播过程</p>
<p>分布式服务跟踪可以:</p>
<p>提供链路追踪，故障快速定位：可以通过调用链结合业务日志快速定位错误信息<br>可视化各个阶段耗时，进行性能分析<br>各个调用环节的可用性、梳理服务依赖关系以及优化<br>数据分析，优化链路：可以得到用户的行为路径，汇总分析应用在很多业务场景</p>
<p>zipkin涉及几个概念：</p>
<p>Span:基本工作单元，一次链路调用(可以是RPC，DB等没有特定的限制)创建一个span，通过一个64位ID标识它，<br>span通过还有其他的数据，例如描述信息，时间戳，key-value对的(Annotation)tag信息，parent-id等,其中parent-id ，可以表示span调用链路来源，通俗的理解span就是一次请求信息<br>Trace:类似于树结构的Span集合，表示一条调用链路，存在唯一标识<br>Annotation: 注解,用来记录请求特定事件相关信息(例如时间)，通常包含四个注解信息<br>cs - Client Start,表示客户端发起请求<br>sr - Server Receive,表示服务端收到请求<br>ss - Server Send,表示服务端完成处理，并将结果发送给客户端<br>cr - Client Received,表示客户端获取到服务端返回信息<br>完整的调用链路</p>
<h1 id="安装和启动Zipkin"><a href="#安装和启动Zipkin" class="headerlink" title="安装和启动Zipkin"></a>安装和启动Zipkin</h1><p><strong>新版本的Zipkin不再推荐我们自己定义Server端</strong>（也可以自定义服务，引入相关依赖），而且在新版本的Spring Cloud依赖管理里也已经没有zipkin-server了，按照官网的使用指南，我们可以在CMD中输入以下的命令下载Zipkin的jar包：<br>curl -sSL <a href="https://zipkin.io/quickstart.sh" target="_blank" rel="noopener">https://zipkin.io/quickstart.sh</a> | bash -s #下载Zipkin的jar包到本地<br>下载好了Zipkin的jar包之后，就可以直接在CMD中输入以下的Java命令启动Zipkin了：<br>java -jar zipkin.jar #启动Zipkin<br>启动Zipkin之后，就可以直接使用浏览器访问<a href="http://localhost:9411" target="_blank" rel="noopener">http://localhost:9411</a> 来查看Zipkin的跟踪结果了，查看结果界面如</p>
<p>SpringCloud Zipkin jar下载地址<br>Windows<br>Linux<br>Windows<br><a href="https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/" target="_blank" rel="noopener">https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/</a><br>//执行<br>java -jar zipkin-server-2.12.9-exec.jar<br>Linux<br>curl -sSL <a href="https://zipkin.io/quickstart.sh" target="_blank" rel="noopener">https://zipkin.io/quickstart.sh</a> | bash -s<br>//执行<br>java -jar zipkin.jar</p>
<h1 id="监控服务"><a href="#监控服务" class="headerlink" title="监控服务"></a>监控服务</h1><p>在网关中配置链路监控比重和zipkin的路径地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.sleuth.web.client.enabled=true</span><br><span class="line">spring.sleuth.sampler.probability=1.0</span><br><span class="line"></span><br><span class="line">spring.zipkin.base-url= http://localhost:9411/</span><br></pre></td></tr></table></figure>
<p>在被监控的服务中添加zipkin的地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.zipkin.base-url= http://localhost:9411/</span><br></pre></td></tr></table></figure>
<p>启动服务通过网关请求服务，在<a href="http://localhost:9411/就可以看见链路的详细信息" target="_blank" rel="noopener">http://localhost:9411/就可以看见链路的详细信息</a></p>
<p><img src="/2020/06/24/spring-cloud-链路追踪/zipkin.png" alt></p>
<h1 id="数据库持久化数据"><a href="#数据库持久化数据" class="headerlink" title="数据库持久化数据"></a>数据库持久化数据</h1><p>Zipkin默认把收集的跟踪信息存放在内存中，这样不但性能极差，而且在重启zipkin-server之后，之前记录的跟踪信息会被清空，所以需要引入持久化方案进行优化，官方推荐可以整合Mysql或Elasticsearch，这里只讲解Mysql</p>
<p>新建数据库表，sql语句如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS zipkin_spans (</span><br><span class="line">  `trace_id_high` BIGINT NOT NULL DEFAULT 0 COMMENT &apos;If non zero, this means the trace uses 128 bit traceIds instead of 64 bit&apos;,</span><br><span class="line">  `trace_id` BIGINT NOT NULL,</span><br><span class="line">  `id` BIGINT NOT NULL,</span><br><span class="line">  `name` VARCHAR(255) NOT NULL,</span><br><span class="line">  `parent_id` BIGINT,</span><br><span class="line">  `debug` BIT(1),</span><br><span class="line">  `start_ts` BIGINT COMMENT &apos;Span.timestamp(): epoch micros used for endTs query and to implement TTL&apos;,</span><br><span class="line">      `duration` BIGINT COMMENT &apos;Span.duration(): micros used for minDuration and maxDuration query&apos;</span><br><span class="line">) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;</span><br><span class="line"></span><br><span class="line">ALTER TABLE zipkin_spans ADD UNIQUE KEY(`trace_id_high`, `trace_id`, `id`) COMMENT &apos;ignore insert on duplicate&apos;;</span><br><span class="line">ALTER TABLE zipkin_spans ADD INDEX(`trace_id_high`, `trace_id`, `id`) COMMENT &apos;for joining with zipkin_annotations&apos;;</span><br><span class="line">ALTER TABLE zipkin_spans ADD INDEX(`trace_id_high`, `trace_id`) COMMENT &apos;for getTracesByIds&apos;;</span><br><span class="line">ALTER TABLE zipkin_spans ADD INDEX(`name`) COMMENT &apos;for getTraces and getSpanNames&apos;;</span><br><span class="line">ALTER TABLE zipkin_spans ADD INDEX(`start_ts`) COMMENT &apos;for getTraces ordering and range&apos;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE IF NOT EXISTS zipkin_annotations (</span><br><span class="line">  `trace_id_high` BIGINT NOT NULL DEFAULT 0 COMMENT &apos;If non zero, this means the trace uses 128 bit traceIds instead of 64 bit&apos;,</span><br><span class="line">  `trace_id` BIGINT NOT NULL COMMENT &apos;coincides with zipkin_spans.trace_id&apos;,</span><br><span class="line">  `span_id` BIGINT NOT NULL COMMENT &apos;coincides with zipkin_spans.id&apos;,</span><br><span class="line">  `a_key` VARCHAR(255) NOT NULL COMMENT &apos;BinaryAnnotation.key or Annotation.value if type == -1&apos;,</span><br><span class="line">  `a_value` BLOB COMMENT &apos;BinaryAnnotation.value(), which must be smaller than 64KB&apos;,</span><br><span class="line">  `a_type` INT NOT NULL COMMENT &apos;BinaryAnnotation.type() or -1 if Annotation&apos;,</span><br><span class="line">  `a_timestamp` BIGINT COMMENT &apos;Used to implement TTL; Annotation.timestamp or zipkin_spans.timestamp&apos;,</span><br><span class="line">  `endpoint_ipv4` INT COMMENT &apos;Null when Binary/Annotation.endpoint is null&apos;,</span><br><span class="line">  `endpoint_ipv6` BINARY(16) COMMENT &apos;Null when Binary/Annotation.endpoint is null, or no IPv6 address&apos;,</span><br><span class="line">  `endpoint_port` SMALLINT COMMENT &apos;Null when Binary/Annotation.endpoint is null&apos;,</span><br><span class="line">  `endpoint_service_name` VARCHAR(255) COMMENT &apos;Null when Binary/Annotation.endpoint is null&apos;</span><br><span class="line">) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;</span><br><span class="line"></span><br><span class="line">ALTER TABLE zipkin_annotations ADD UNIQUE KEY(`trace_id_high`, `trace_id`, `span_id`, `a_key`, `a_timestamp`) COMMENT &apos;Ignore insert on duplicate&apos;;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`, `span_id`) COMMENT &apos;for joining with zipkin_spans&apos;;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`) COMMENT &apos;for getTraces/ByIds&apos;;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`endpoint_service_name`) COMMENT &apos;for getTraces and getServiceNames&apos;;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`a_type`) COMMENT &apos;for getTraces&apos;;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`a_key`) COMMENT &apos;for getTraces&apos;;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`trace_id`, `span_id`, `a_key`) COMMENT &apos;for dependencies job&apos;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE IF NOT EXISTS zipkin_dependencies (</span><br><span class="line">  `day` DATE NOT NULL,</span><br><span class="line">  `parent` VARCHAR(255) NOT NULL,</span><br><span class="line">  `child` VARCHAR(255) NOT NULL,</span><br><span class="line">  `call_count` BIGINT,</span><br><span class="line">  `error_count` BIGINT</span><br><span class="line">) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;</span><br><span class="line"></span><br><span class="line">ALTER TABLE zipkin_dependencies ADD UNIQUE KEY(`day`, `parent`, `child`);</span><br></pre></td></tr></table></figure>
<p>启动jar时添加数据库配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar zipkin-server-2.12.9-exec.jar --STORAGE_TYPE=mysql --MYSQL_DB=zipkin --MYSQL_USER=password --MYSQL_PASS=WEIxy.789 --MYSQL_HOST=localhost --MYSQL_TCP_PORT=3306</span><br></pre></td></tr></table></figure>
<p>重新启动zipkin，记录仍然还在。至此，SpringCLoud Sleuth+Zipkin整合Mysql实现持久化完成了！！！</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>spring cloud</tag>
        <tag>zipkin</tag>
      </tags>
  </entry>
  <entry>
    <title>spring cloud 集成练习项目</title>
    <url>/2019/12/15/spring-cloud-%E9%9B%86%E6%88%90%E7%BB%83%E4%B9%A0%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="创建服务注册中心-（eureka）"><a href="#创建服务注册中心-（eureka）" class="headerlink" title="创建服务注册中心 （eureka）"></a>创建服务注册中心 （eureka）</h1><p>环境配置:</p>
<p>JDK 1.8</p>
<p>spring cloud version:Greenwich.SR1</p>
<p>spring boot version:2.1.5.RELEASE</p>
<p>eureka-server作为服务发现的核心，第一个搭建，后面的服务都要注册到eureka-server上，意思是告诉eureka-server自己的服务地址是啥。当然还可以用zookeeper或者spring consul。</p>
<p>这里我用的gradle构建的项目，再build.gradle中添加依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">	id <span class="string">'org.springframework.boot'</span> version <span class="string">'2.2.2.RELEASE'</span></span><br><span class="line">	id <span class="string">'io.spring.dependency-management'</span> version <span class="string">'1.0.8.RELEASE'</span></span><br><span class="line">	id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'idea'</span></span><br><span class="line">group = <span class="string">'com.example'</span></span><br><span class="line">version = <span class="string">'0.0.3'</span></span><br><span class="line">sourceCompatibility = <span class="string">'1.8'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">	mavenCentral()</span><br><span class="line"><span class="comment">//	maven &#123; url "http://maven.aliyun.com/nexus/content/groups/public/" &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">	set(<span class="string">'springCloudVersion'</span>, <span class="string">"Hoxton.RELEASE"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">	implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-eureka-server'</span></span><br><span class="line">	compile(<span class="string">'org.springframework.boot:spring-boot-starter-security'</span>)</span><br><span class="line">	testImplementation(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>) &#123;</span><br><span class="line">		exclude <span class="string">group:</span> <span class="string">'org.junit.vintage'</span>, <span class="string">module:</span> <span class="string">'junit-vintage-engine'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencyManagement &#123;</span><br><span class="line">	imports &#123;</span><br><span class="line">		mavenBom <span class="string">"org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">	useJUnitPlatform()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jar &#123;</span><br><span class="line">    String someString = <span class="string">''</span></span><br><span class="line">    configurations.runtime.each &#123; someString = someString + <span class="string">" lib\\"</span> + it.name &#125;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes <span class="string">'Main-Class'</span>: <span class="string">'com.each.dubboMainEnd'</span></span><br><span class="line">        attributes <span class="string">'Class-Path'</span>: someString</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task copyJar(<span class="string">type:</span>Copy)&#123;</span><br><span class="line">    from configurations.runtime</span><br><span class="line">    into (<span class="string">'build/libs/lib'</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task release(<span class="string">type:</span> Copy,<span class="string">dependsOn:</span> [build,copyJar]) &#123;</span><br><span class="line"><span class="comment">//    from  'conf'</span></span><br><span class="line">    <span class="comment">//   into ('build/libs/eachend/conf')</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在resurce下的application.properties修改配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">5678</span></span><br><span class="line"><span class="meta">spring.security.user.roles</span>=<span class="string">SUPERUSER</span></span><br><span class="line"><span class="meta">spring.security.user.name</span>=<span class="string">wxy</span></span><br><span class="line"><span class="meta">spring.security.user.password</span>=<span class="string">wxy123</span></span><br><span class="line"><span class="meta">eureka.client.register-with-eureka</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">eureka.client.fetch-registry</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">eureka.instance.hostname</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://wxy:wxy123@localhost:5678/eureka</span></span><br></pre></td></tr></table></figure>
<p>在启动类上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableEurekaServer</span> <span class="comment">//启动服务注册中心</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudEurekaServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(CloudEurekaServiceApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动服务，访问<a href="http://localhost:5678/，出现登陆页面，输入账号密码，就可以访问到注册中心" target="_blank" rel="noopener">http://localhost:5678/，出现登陆页面，输入账号密码，就可以访问到注册中心</a></p>
<h1 id="创建config-server分布式配置中心服务（git版）"><a href="#创建config-server分布式配置中心服务（git版）" class="headerlink" title="创建config-server分布式配置中心服务（git版）"></a>创建config-server分布式配置中心服务（git版）</h1><p>首先要准备一个<a href="https://github.com/pignum1/config" target="_blank" rel="noopener">git仓库</a>,然后新建一个springboot项目，修改build.gradle</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">	id <span class="string">'org.springframework.boot'</span> version <span class="string">'2.2.2.RELEASE'</span></span><br><span class="line">	id <span class="string">'io.spring.dependency-management'</span> version <span class="string">'1.0.8.RELEASE'</span></span><br><span class="line">	id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'idea'</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">'com.example'</span></span><br><span class="line">version = <span class="string">'0.0.4'</span></span><br><span class="line">sourceCompatibility = <span class="string">'1.8'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">	mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">	set(<span class="string">'springCloudVersion'</span>, <span class="string">"Hoxton.SR1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">	implementation <span class="string">'org.springframework.cloud:spring-cloud-config-server'</span></span><br><span class="line">	implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'</span></span><br><span class="line"><span class="comment">//	implementation 'org.springframework.cloud:spring-cloud-starter-security'</span></span><br><span class="line">	compile(<span class="string">'org.springframework.boot:spring-boot-starter-security'</span>)</span><br><span class="line"></span><br><span class="line">	compile(<span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span>)</span><br><span class="line">	testImplementation(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>) &#123;</span><br><span class="line">		exclude <span class="string">group:</span> <span class="string">'org.junit.vintage'</span>, <span class="string">module:</span> <span class="string">'junit-vintage-engine'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencyManagement &#123;</span><br><span class="line">	imports &#123;</span><br><span class="line">		mavenBom <span class="string">"org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">	useJUnitPlatform()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jar &#123;</span><br><span class="line">	String someString = <span class="string">''</span></span><br><span class="line">	configurations.runtime.each &#123; someString = someString + <span class="string">" lib\\"</span> + it.name &#125;</span><br><span class="line">	manifest &#123;</span><br><span class="line">		attributes <span class="string">'Main-Class'</span>: <span class="string">'com.each.dubboMainEnd'</span></span><br><span class="line">		attributes <span class="string">'Class-Path'</span>: someString</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task copyJar(<span class="string">type:</span>Copy)&#123;</span><br><span class="line">	from configurations.runtime</span><br><span class="line">	into (<span class="string">'build/libs/lib'</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task release(<span class="string">type:</span> Copy,<span class="string">dependsOn:</span> [build,copyJar]) &#123;</span><br><span class="line"><span class="comment">//    from  'conf'</span></span><br><span class="line">	<span class="comment">//   into ('build/libs/eachend/conf')</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改配置application.yml,添加仓库配置和自动刷新配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5679</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">basic:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">wxy</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">wxy123</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-server</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://github.com/pignum1/config.git</span></span><br><span class="line">          <span class="attr">searchPaths:</span> <span class="string">'&#123;application&#125;'</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://wxy:wxy123@47.102.99.93:5678/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;server.port&#125;&#125;</span></span><br><span class="line">    <span class="attr">appname:</span> <span class="string">config-server</span></span><br></pre></td></tr></table></figure>
<p>在启动类上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.configserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.config.server.EnableConfigServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(ConfigServerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动服务配置中心</p>
<h1 id="创建provider生产者"><a href="#创建provider生产者" class="headerlink" title="创建provider生产者"></a>创建provider生产者</h1><p>创建springboot项目， 修改build.gradle文件</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile(<span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'</span>)</span><br><span class="line">compile(<span class="string">'org.springframework.cloud:spring-cloud-starter-config'</span>)</span><br><span class="line">compile(<span class="string">'org.springframework.boot:spring-boot-starter-webflux'</span>)</span><br><span class="line">compile(<span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span>)</span><br><span class="line">compile(<span class="string">'org.springframework.cloud:spring-cloud-starter-openfeign'</span>)</span><br><span class="line">compile(<span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-hystrix'</span>)</span><br></pre></td></tr></table></figure>
<p>创建bootstrap.properties文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#datasource</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/cloud?useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">dawei</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">WEIxy.789</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.jackson.date-format</span>=<span class="string">yyyy-MM-dd HH:mm:ss</span></span><br><span class="line"><span class="meta">spring.jackson.time-zone</span>=<span class="string">GMT+8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.jpa.properties.hibernate.hbm2ddl.auto</span>=<span class="string">update</span></span><br><span class="line"><span class="meta">spring.jpa.database-platform</span>=<span class="string">org.hibernate.dialect.MySQL5Dialect</span></span><br><span class="line"><span class="meta">spring.datasource.dbcp.max-wait</span>=<span class="string">300</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">provider</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">5682</span></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://wxy:wxy123@localhost:5678/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.instance.status-page-url</span>=<span class="string">http://$&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;/swagger-ui.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#心跳频率</span></span><br><span class="line"><span class="meta">eureka.instance.lease-renewal-interval-in-seconds</span>=<span class="string">5</span></span><br><span class="line"><span class="meta">eureka.instance.lease-expiration-duration-in-seconds</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure>
<p>修改启动类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//@EnableSwagger2</span><br><span class="line">@SpringCloudApplication</span><br><span class="line">//@EntityScan(&quot;com.example.provider&quot;)</span><br><span class="line">//@EnableJpaRepositories(&quot;com.example.provider&quot;)</span><br><span class="line">@EnableJpaAuditing</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建服务生产类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/hello&quot;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDao userDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ProviderDao providerDao;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;打个招呼&quot;, notes = &quot;打个招呼&quot;)</span><br><span class="line">    @PostMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello(@RequestParam String name ) &#123;</span><br><span class="line">//        Provider</span><br><span class="line">        return &quot;你好啊!&quot;+name ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="创建服务消费者consumer服务"><a href="#创建服务消费者consumer服务" class="headerlink" title="创建服务消费者consumer服务"></a>创建服务消费者consumer服务</h1><p>新建一个spring boot服务, 修改buid.gradle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">	id &apos;org.springframework.boot&apos; version &apos;2.2.4.RELEASE&apos;</span><br><span class="line">	id &apos;io.spring.dependency-management&apos; version &apos;1.0.9.RELEASE&apos;</span><br><span class="line">	id &apos;java&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group = &apos;com.example&apos;</span><br><span class="line">version = &apos;0.0.1-SNAPSHOT&apos;</span><br><span class="line">sourceCompatibility = &apos;1.8&apos;</span><br><span class="line"></span><br><span class="line">configurations &#123;</span><br><span class="line">	developmentOnly</span><br><span class="line">	runtimeClasspath &#123;</span><br><span class="line">		extendsFrom developmentOnly</span><br><span class="line">	&#125;</span><br><span class="line">	compileOnly &#123;</span><br><span class="line">		extendsFrom annotationProcessor</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">	mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">	set(&apos;springCloudVersion&apos;, &quot;Hoxton.SR1&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">	implementation &apos;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&apos;</span><br><span class="line">	compile(&apos;org.springframework.cloud:spring-cloud-starter-config&apos;)</span><br><span class="line">	compile(&apos;org.springframework.boot:spring-boot-starter-webflux&apos;)</span><br><span class="line">	compile(&apos;org.springframework.boot:spring-boot-starter-actuator&apos;)</span><br><span class="line">	compile(&apos;org.springframework.cloud:spring-cloud-starter-openfeign&apos;)</span><br><span class="line">	compile(&apos;org.springframework.cloud:spring-cloud-starter-netflix-hystrix&apos;)</span><br><span class="line">	compileOnly &apos;org.projectlombok:lombok&apos;</span><br><span class="line">	developmentOnly &apos;org.springframework.boot:spring-boot-devtools&apos;</span><br><span class="line">	annotationProcessor &apos;org.projectlombok:lombok&apos;</span><br><span class="line">	testImplementation(&apos;org.springframework.boot:spring-boot-starter-test&apos;) &#123;</span><br><span class="line">		exclude group: &apos;org.junit.vintage&apos;, module: &apos;junit-vintage-engine&apos;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencyManagement &#123;</span><br><span class="line">	imports &#123;</span><br><span class="line">		mavenBom &quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">	useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改bootstrap.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">consumer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://wxy:wxy123@localhost:5678/eureka/</span></span><br><span class="line"><span class="meta">eureka.instance.prefer-ip-address</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">eureka.instance.instance-id</span>=<span class="string">$&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;server.port&#125;&#125;</span></span><br><span class="line"><span class="meta">eureka.instance.appname</span>=<span class="string">consumer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务配置中心</span></span><br><span class="line"><span class="meta">spring.cloud.config.discovery.service-id</span>=<span class="string">config-server</span></span><br><span class="line"><span class="meta">spring.cloud.config.discovery.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.cloud.config.fail-fast</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.cloud.config.username</span>=<span class="string">wxy</span></span><br><span class="line"><span class="meta">spring.cloud.config.password</span>=<span class="string">wxy123</span></span><br><span class="line"><span class="meta">spring.cloud.config.profile</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure>
<p>启动类修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class ConsumerApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@LoadBalanced</span><br><span class="line">	public RestTemplate restTemplate()&#123;</span><br><span class="line">		RestTemplate restTemplate = new RestTemplate();</span><br><span class="line">		List&lt;HttpMessageConverter&lt;?&gt;&gt; list = restTemplate.getMessageConverters();</span><br><span class="line">		for (HttpMessageConverter&lt;?&gt; httpMessageConverter : list) &#123;</span><br><span class="line">			if(httpMessageConverter instanceof StringHttpMessageConverter) &#123;</span><br><span class="line">				((StringHttpMessageConverter) httpMessageConverter).setDefaultCharset(Charset.forName(&quot;utf-8&quot;));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return restTemplate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建服务调用类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetHello</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/greet"</span>)</span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"fallbackMethod"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHelloWorld</span><span class="params">(String parm)</span> </span>&#123;</span><br><span class="line">        MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> LinkedMultiValueMap&lt;String, String&gt;();</span><br><span class="line">        map.add(<span class="string">"name"</span>,parm);</span><br><span class="line">        String res = <span class="keyword">this</span>.restTemplate.postForObject(<span class="string">"http://provider/hello/hello"</span>, map, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fallbackMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="fegin服务消费者"><a href="#fegin服务消费者" class="headerlink" title="fegin服务消费者"></a>fegin服务消费者</h1><p>使用fegin的方式调用生产者,仍然需要新建一个spring boot项目</p>
<p>引入依赖,修改build.gradle</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">	id <span class="string">'org.springframework.boot'</span> version <span class="string">'2.2.4.RELEASE'</span></span><br><span class="line">	id <span class="string">'io.spring.dependency-management'</span> version <span class="string">'1.0.9.RELEASE'</span></span><br><span class="line">	id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group = <span class="string">'com.example'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="string">'1.8'</span></span><br><span class="line"></span><br><span class="line">configurations &#123;</span><br><span class="line">	developmentOnly</span><br><span class="line">	runtimeClasspath &#123;</span><br><span class="line">		extendsFrom developmentOnly</span><br><span class="line">	&#125;</span><br><span class="line">	compileOnly &#123;</span><br><span class="line">		extendsFrom annotationProcessor</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">	mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">	set(<span class="string">'springCloudVersion'</span>, <span class="string">"Hoxton.SR1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">	implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'</span></span><br><span class="line">	compile(<span class="string">'org.springframework.cloud:spring-cloud-starter-config'</span>)</span><br><span class="line">	compile(<span class="string">'org.springframework.boot:spring-boot-starter-webflux'</span>)</span><br><span class="line">	compile(<span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span>)</span><br><span class="line">	compile(<span class="string">'org.springframework.cloud:spring-cloud-starter-openfeign'</span>)</span><br><span class="line">	compile(<span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-hystrix'</span>)</span><br><span class="line"></span><br><span class="line">	compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line"><span class="comment">// https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-feign</span></span><br><span class="line">	compile <span class="string">group:</span> <span class="string">'org.springframework.cloud'</span>, <span class="string">name:</span> <span class="string">'spring-cloud-starter-feign'</span>, <span class="string">version:</span> <span class="string">'1.4.7.RELEASE'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	compileOnly <span class="string">'org.projectlombok:lombok'</span></span><br><span class="line">	developmentOnly <span class="string">'org.springframework.boot:spring-boot-devtools'</span></span><br><span class="line">	annotationProcessor <span class="string">'org.projectlombok:lombok'</span></span><br><span class="line">	testImplementation(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>) &#123;</span><br><span class="line">		exclude <span class="string">group:</span> <span class="string">'org.junit.vintage'</span>, <span class="string">module:</span> <span class="string">'junit-vintage-engine'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencyManagement &#123;</span><br><span class="line">	imports &#123;</span><br><span class="line">		mavenBom <span class="string">"org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">	useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改application.properties配置，基本和ribbon的配置是一样的,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name=fegin</span><br><span class="line">server.port=5685</span><br><span class="line"></span><br><span class="line">eureka.client.service-url.defaultZone=http://wxy:wxy123@47.102.99.93:5678/eureka/</span><br><span class="line"></span><br><span class="line">eureka.instance.status-page-url=http://$&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;/swagger-ui.html</span><br><span class="line"></span><br><span class="line">#心跳频率</span><br><span class="line">eureka.instance.lease-renewal-interval-in-seconds=5</span><br><span class="line">eureka.instance.lease-expiration-duration-in-seconds=10</span><br></pre></td></tr></table></figure>
<p>创建映射的服务调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"provider"</span>,fallback = FeignClientFallback<span class="class">.<span class="keyword">class</span>, <span class="title">configuration</span> </span>= FeignConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">FeginClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/hello/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">greet</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientFallback</span>  <span class="keyword">implements</span> <span class="title">FeginClient</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">greet</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"greet error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建调用的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">     FeginClient feginClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String  <span class="title">hello</span> <span class="params">( String  name )</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> feginClient.greet(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在启动类上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringCloudApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableHystrix</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.example.*"</span>)</span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeginApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(FeginApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动服务后就可以试着用fegin的方式调用方法打招呼的方法了</p>
<h1 id="创建ZUUL服务网关"><a href="#创建ZUUL服务网关" class="headerlink" title="创建ZUUL服务网关"></a>创建ZUUL服务网关</h1><p>新建一个项目，修改build.gradle</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">	id <span class="string">'org.springframework.boot'</span> version <span class="string">'2.2.4.RELEASE'</span></span><br><span class="line">	id <span class="string">'io.spring.dependency-management'</span> version <span class="string">'1.0.9.RELEASE'</span></span><br><span class="line">	id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group = <span class="string">'com.example'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="string">'1.8'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">	mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">	set(<span class="string">'springCloudVersion'</span>, <span class="string">"Hoxton.SR1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">	implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-zuul'</span></span><br><span class="line"></span><br><span class="line">	compile(<span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'</span>)</span><br><span class="line">	compile(<span class="string">'org.springframework.cloud:spring-cloud-starter-config'</span>)</span><br><span class="line">	compile(<span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span>)</span><br><span class="line">	testImplementation(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>) &#123;</span><br><span class="line">		exclude <span class="string">group:</span> <span class="string">'org.junit.vintage'</span>, <span class="string">module:</span> <span class="string">'junit-vintage-engine'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencyManagement &#123;</span><br><span class="line">	imports &#123;</span><br><span class="line">		mavenBom <span class="string">"org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">	useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建bootstrap.properties，修改配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">zuul</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://wxy:wxy123@localhost:5678/eureka/</span></span><br><span class="line"><span class="meta">eureka.instance.prefer-ip-address</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">eureka.instance.instance-id</span>=<span class="string">$&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;server.port&#125;&#125;</span></span><br><span class="line"><span class="meta">eureka.instance.appname</span>=<span class="string">zuul</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务配置中心</span></span><br><span class="line"><span class="meta">spring.cloud.config.discovery.service-id</span>=<span class="string">config-server</span></span><br><span class="line"><span class="meta">spring.cloud.config.discovery.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.cloud.config.fail-fast</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.cloud.config.username</span>=<span class="string">wxy</span></span><br><span class="line"><span class="meta">spring.cloud.config.password</span>=<span class="string">wxy123</span></span><br><span class="line"><span class="meta">spring.cloud.config.profile</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure>
<p>git上的配置application-dev.properties内容如下,转发路劲和超时时间</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">5684</span></span><br><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">zuul.routes.consumer</span>=<span class="string">/consumer/**</span></span><br><span class="line"><span class="meta">zuul.routes.provider</span>=<span class="string">/provider/**</span></span><br><span class="line"><span class="meta">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</span>=<span class="string">80000</span></span><br></pre></td></tr></table></figure>
<p>修改启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@SpringCloudApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(ZuulApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时访问其他服务可以通过访问网关上的路径转发来访问其他服务，来隐藏其他服务的地址，还可以做鉴权等其他功能。</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud-hystrix</title>
    <url>/2019/11/12/springcloud-hystrix/</url>
    <content><![CDATA[<h1 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h1><pre><code>在分布式环境中，许多服务依赖项中的一些必然会失败。Hystrix是一个库，通过添加延迟容忍和容错逻辑，帮助你控制这些分布式服务之间的交互。Hystrix通过隔离服务之间的访问点、停止级联失败和提供回退选项来实现这一点，所有这些都可以提高系统的整体弹性 
</code></pre><h2 id="Hystrix的设计目的"><a href="#Hystrix的设计目的" class="headerlink" title="Hystrix的设计目的"></a>Hystrix的设计目的</h2><ol>
<li>对通过第三方客户端库访问的依赖项（通常是通过网络）的延迟和故障进行保护和控制。</li>
<li>在复杂的分布式系统中阻止级联故障。</li>
<li>快速失败，快速恢复。</li>
<li>回退，尽可能优雅地降级。</li>
<li>启用近实时监控、警报和操作控制。</li>
</ol>
<p>​        复杂分布式体系结构中的应用程序有许多依赖项，每个依赖项在某些时候都不可避免地会失败。如果主机应用程序没有与这些外部故障隔离，那么它有可能被他们拖垮。</p>
<h2 id="Hystrix设计原则"><a href="#Hystrix设计原则" class="headerlink" title="Hystrix设计原则"></a>Hystrix设计原则</h2><ul>
<li>防止任何单个依赖项耗尽所有容器（如Tomcat）用户线程。</li>
<li>甩掉包袱，快速失败而不是排队。</li>
<li>在任何可行的地方提供回退，以保护用户不受失败的影响。</li>
<li>使用隔离技术（如隔离板、泳道和断路器模式）来限制任何一个依赖项的影响。</li>
<li>通过近实时的度量、监视和警报来优化发现时间。</li>
<li>通过配置的低延迟传播来优化恢复时间。</li>
<li>支持对Hystrix的大多数方面的动态属性更改，允许使用低延迟反馈循环进行实时操作修改。</li>
<li>避免在整个依赖客户端执行中出现故障，而不仅仅是在网络流量中。</li>
</ul>
<h2 id="Hystrix是如何实现它的目标的"><a href="#Hystrix是如何实现它的目标的" class="headerlink" title="Hystrix是如何实现它的目标的"></a>Hystrix是如何实现它的目标的</h2><ol>
<li>用一个HystrixCommand 或者 HystrixObservableCommand （这是命令模式的一个例子）包装所有的对外部系统（或者依赖）的调用，典型地它们在一个单独的线程中执行</li>
<li>调用超时时间比你自己定义的阈值要长。有一个默认值，对于大多数的依赖项你是可以自定义超时时间的。</li>
<li>为每个依赖项维护一个小的线程池(或信号量)；如果线程池满了，那么该依赖性将会立即拒绝请求，而不是排队。</li>
<li>调用的结果有这么几种：成功、失败（客户端抛出异常）、超时、拒绝。</li>
<li>在一段时间内，如果服务的错误百分比超过了一个阈值，就会触发一个断路器来停止对特定服务的所有请求，无论是手动的还是自动的。</li>
<li>当请求失败、被拒绝、超时或短路时，执行回退逻辑。</li>
<li><p>近实时监控指标和配置变化。</p>
<p>当你使用Hystrix来包装每个依赖项时，上图中所示的架构会发生变化，如下图所示： </p>
<p>每个依赖项相互隔离，当延迟发生时，它会被限制在资源中，并包含回退逻辑，该逻辑决定在依赖项中发生任何类型的故障时应作出何种响应： </p>
</li>
</ol>
<p><img src="/2019/11/12/springcloud-hystrix/depence.png" alt></p>
<h1 id="Hystrix的使用"><a href="#Hystrix的使用" class="headerlink" title="Hystrix的使用"></a>Hystrix的使用</h1><h2 id="服务容错保护（Hystrix服务降级）"><a href="#服务容错保护（Hystrix服务降级）" class="headerlink" title="服务容错保护（Hystrix服务降级）"></a>服务容错保护（Hystrix服务降级）</h2><p> 使用Spring Cloud Hystrix实现断路器 </p>
<p>创建两个spring cloud服务，一个服务方，一个调用方，在调用方中添加断路器的依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-hystrix'</span></span><br></pre></td></tr></table></figure>
<p>创建服务提供方 Hystrix-demo1，创建测试方法，添加线程睡眠5秒来触发断路器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep( <span class="number">50000</span> );</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"wake"</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="string">"sleep"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建调用方  Hystrix-demo2，</p>
<p>在启动类商添加注解来启用断路器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br></pre></td></tr></table></figure>
<p>测试请求方法， API方法加上了@HystrixCommand注解，并设置fallbackMethod属性为回退方法名称 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">consumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/consumer"</span>)</span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"fallback"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://hystrix-demo1/hello"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"fallback"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分别启动服务提供者和服务消费者，并用POSTMAN 调用consumer方法，此时页面返回的数据为</p>
<p><img src="/2019/11/12/springcloud-hystrix/down.png" alt></p>
<pre><code>以看到服务提供方输出了原本要返回的结果，但是由于返回前延迟了5秒，而服务消费方触发了服务请求超时异常，服务消费者就通过HystrixCommand注解中指定的降级逻辑进行执行，因此该请求的结果返回了`fallback`。这样的机制，对自身服务起到了基础的保护，同时还为异常情况提供了自动的服务降级切换机制。 
</code></pre><h2 id="依赖隔离"><a href="#依赖隔离" class="headerlink" title="依赖隔离"></a>依赖隔离</h2><pre><code>而Hystrix使用该模式实现线程池的隔离，它会为每一个Hystrix命令创建一个独立的线程池，这样就算某个在Hystrix命令包装下的依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响，而不会拖慢其他的服务。 
</code></pre><ul>
<li>应用自身得到完全的保护，不会受不可控的依赖服务影响。即便给依赖服务分配的线程池被填满，也不会影响应用自身的额其余部分。</li>
<li>可以有效的降低接入新服务的风险。如果新服务接入后运行不稳定或存在问题，完全不会影响到应用其他的请求。</li>
<li>当依赖的服务从失效恢复正常后，它的线程池会被清理并且能够马上恢复健康的服务，相比之下容器级别的清理恢复速度要慢得多。</li>
<li>当依赖的服务出现配置错误的时候，线程池会快速的反应出此问题（通过失败次数、延迟、超时、拒绝等指标的增加情况）。同时，我们可以在不影响应用功能的情况下通过实时的动态属性刷新（后续会通过Spring Cloud Config与Spring Cloud Bus的联合使用来介绍）来处理它。</li>
<li>当依赖的服务因实现机制调整等原因造成其性能出现很大变化的时候，此时线程池的监控指标信息会反映出这样的变化。同时，我们也可以通过实时动态刷新自身应用对依赖服务的阈值进行调整以适应依赖方的改变。</li>
<li><p>除了上面通过线程池隔离服务发挥的优点之外，每个专有线程池都提供了内置的并发实现，可以利用它为同步的依赖服务构建异步的访问。</p>
<p>我们使用了@HystrixCommand来将某个函数包装成了Hystrix命令，这里除了定义服务降级之外，Hystrix框架就会自动的为这个函数实现调用的隔离。所以，依赖隔离、服务降级在使用时候都是一体化实现的，这样利用Hystrix来实现服务容错保护在编程模型上就非常方便的，并且考虑更为全面。 </p>
</li>
</ul>
<h2 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h2><p> “断路器”本身是一种开关装置，用于在电路上保护线路过载，当线路中有电器发生短路时，“断路器”能够及时的切断故障电路，  分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），直接切断原来的主逻辑调用。 </p>
<p> 那么断路器是在什么情况下开始起作用呢？这里涉及到断路器的三个重要参数：快照时间窗、请求总数下限、错误百分比下限 </p>
<ul>
<li>快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。</li>
<li>请求总数下限：在快照时间窗内，必须满足请求总数下限才有资格根据熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用此时不足20次，即时所有的请求都超时或其他原因失败，断路器都不会打开。</li>
<li><p>错误百分比下限：当请求总数在快照时间窗内超过了下限，比如发生了30次调用，如果在这30次调用中，有16次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%下限情况下，这时候就会将断路器打开。</p>
<p>在断路器打开之后，处理逻辑并没有结束，我们的降级逻辑已经被成了主逻辑，那么原来的主逻辑要如何恢复呢？对于这一问题，hystrix也为我们实现了自动恢复功能。当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。 </p>
</li>
</ul>
<h1 id="Hystrix监控面板"><a href="#Hystrix监控面板" class="headerlink" title="Hystrix监控面板"></a>Hystrix监控面板</h1><p> 断路器是根据一段时间窗内的请求情况来判断并操作断路器的打开和关闭状态的。而这些请求情况的指标信息都是HystrixCommand和HystrixObservableCommand实例在执行过程中记录的重要度量信息，它们除了Hystrix断路器实现中使用之外，对于系统运维也有非常大的帮助。 </p>
<p> 下面我们基于之前的示例来结合Hystrix Dashboard实现Hystrix指标数据的可视化面板， 我们将用到的几个应用  </p>
<ul>
<li>cloud-eureka-server：服务注册中心</li>
<li>Hystrix-demo1：服务提供者</li>
<li><p>Hystrix-demo2：使服务消费者</p>
<p>创建一个标准的Spring Boot工程，命名为：hystrix-dashboard ,添加依赖</p>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span></span><br><span class="line">implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-hystrix'</span></span><br><span class="line">implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-hystrix-dashboard'</span></span><br></pre></td></tr></table></figure>
<p>在启动类上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixDashboardApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(HystrixDashboardApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">hystrix-dashboard</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">1301</span></span><br></pre></td></tr></table></figure>
<p>启动项目后访问  <a href="http://localhost:1301/hystrix" target="_blank" rel="noopener">http://localhost:1301/hystrix</a> ，显示页面如下</p>
<p><img src="/2019/11/12/springcloud-hystrix/hystrix.png" alt></p>
<p>这是Hystrix Dashboard的监控首页，该页面中并没有具体的监控信息。从页面的文字内容中我们可以知道，Hystrix Dashboard共支持三种不同的监控方式，依次为：</p>
<ul>
<li>默认的集群监控：通过URL<code>http://turbine-h；ostname:port/turbine.stream</code>开启，实现对默认集群的监控。</li>
<li>指定的集群监控：通过URL<code>http://turbine-hostname:port/turbine.stream?cluster=[clusterName]</code>开启，实现对clusterName集群的监控。</li>
<li>单体应用的监控：通过URL<code>http://hystrix-app:port/hystrix.stream</code>开启，实现对具体某个服务实例的监控。</li>
</ul>
<p>前两者都对集群的监控，需要整合Turbine才能实现，我们主要实现对单个服务实例的监控，所以这里我们先来实现<strong>单个服务实例</strong>的监控。</p>
<p>既然Hystrix Dashboard监控单实例节点需要通过访问实例的<code>/hystrix.stream</code>接口来实现，自然我们需要为服务实例添加这个端点，而添加该功能的步骤也同样简单。</p>
<h2 id="单个服务实例的监控"><a href="#单个服务实例的监控" class="headerlink" title="单个服务实例的监控"></a><strong>单个服务实例</strong>的监控</h2><p> Hystrix Dashboard 监控的结构</p>
<p><img src="/2019/11/12/springcloud-hystrix/struct.png" alt></p>
<p>在<strong>服务消费者</strong>（Hystrix-demo2）实例中添加监听配置</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-hystrix'</span>implementation <span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span></span><br></pre></td></tr></table></figure>
<p>添加配置文件</p>
 <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#为服务实例（被监控服务）添加这个 endpoint，修改服务实例的配置文件，添加对actuator的配置</span></span><br><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">hystrix.stream</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改Hystrix默认超时时间</span></span><br><span class="line"><span class="meta">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</span> = <span class="string">2000</span></span><br></pre></td></tr></table></figure>
<p>在启动类种添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">hystrixMetricsStreamServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServletRegistrationBean registration = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> HystrixMetricsStreamServlet());</span><br><span class="line">    registration.addUrlMappings(<span class="string">"/hystrix.stream"</span>);</span><br><span class="line">    <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时在 <a href="http://localhost:1301/hystrix" target="_blank" rel="noopener">http://localhost:1301/hystrix</a>  输入框中输入http://:服务消费者IP:服务消费端口/hystrix.stream，</p>
<p>这个时候页面显示的是Loading,发起服务容错种的consumer请求，页面上<img src="/2019/11/12/springcloud-hystrix/hystrixScreen.png" alt></p>
<p>显示的各个参数解释引用别人的图<img src="/2019/11/12/springcloud-hystrix/hystrixParams.png" alt></p>
<p> 这里就对单体服务的监控介绍完了。但是在分布式系统中往往有很多服务需要监控。</p>
<p> <em>注意：当使用Hystrix Dashboard监控Spring Cloud Zuul构建的API网关时，ThreadPool信息会一直处于Loading状态，这是由于Zuul默认使用信号量来实现隔离，只有通过Hystrix配置把隔离机制改为线程池的方式才能得以展示。</em> </p>
<h1 id="Hystrix监控数据聚合"><a href="#Hystrix监控数据聚合" class="headerlink" title="Hystrix监控数据聚合"></a>Hystrix监控数据聚合</h1><p>​        通过Hystrix Dashboard，我们可以方便的查看服务实例的综合情况，比如：服务调用次数、服务调用延迟等。但是仅通过Hystrix Dashboard我们只能实现对服务当个实例的数据展现，在生产环境我们的服务是肯定需要做高可用的，那么对于多实例的情况，我们就需要将这些度量指标数据进行聚合。下面我们就来介绍一下另外一个工具：Turbine。 </p>
<p>​    上文中构建的有</p>
<ul>
<li>eureka-server：服务注册中心</li>
<li>Hystrix-demo1：服务提供者</li>
<li>Hystrix-demo1：使用ribbon和hystrix实现的服务消费者</li>
<li>hystrix-dashboard：用于展示<code>eureka-consumer-ribbon-hystrix</code>服务的Hystrix数据</li>
</ul>
<h3 id="通过HTTP收集聚合（turbine检测单个集群-）"><a href="#通过HTTP收集聚合（turbine检测单个集群-）" class="headerlink" title="通过HTTP收集聚合（turbine检测单个集群 ）"></a>通过HTTP收集聚合（turbine检测单个集群 ）</h3><p>创建一个新的 Spring Boot工程，命名为：turbine </p>
<p>添加依赖和properties的配置</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">	implementation <span class="string">'org.springframework.boot:spring-boot-starter-web'</span></span><br><span class="line"></span><br><span class="line">	implementation <span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span></span><br><span class="line">	implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-hystrix'</span></span><br><span class="line"><span class="comment">//	implementation 'org.springframework.cloud:spring-cloud-starter-netflix-turbine-stream'</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-turbine</span></span><br><span class="line">	compile <span class="string">group:</span> <span class="string">'org.springframework.cloud'</span>, <span class="string">name:</span> <span class="string">'spring-cloud-starter-turbine'</span>, <span class="string">version:</span> <span class="string">'1.4.7.RELEASE'</span></span><br><span class="line"><span class="comment">// https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka</span></span><br><span class="line">	compile <span class="string">group:</span> <span class="string">'org.springframework.cloud'</span>, <span class="string">name:</span> <span class="string">'spring-cloud-starter-eureka'</span>, <span class="string">version:</span> <span class="string">'1.4.7.RELEASE'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">turbine</span></span><br><span class="line"></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8989</span></span><br><span class="line"></span><br><span class="line"><span class="meta">management.server.port</span>=<span class="string">8990</span></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://localhost:5678/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#turbine.app-config参数指定了需要收集监控信息的服务名,这里监测的服务消费者，多个,隔开</span></span><br><span class="line"><span class="meta">turbine.app-config</span>=<span class="string">Hystrix-demo2 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数指定了集群名称为default，当我们服务数量非常多的时候，可以启动多个Turbine服务来构建不同的聚合集群，而该参数可以用来区分这些不同的聚合集群，</span></span><br><span class="line"><span class="comment"># 同时该参数值可以在Hystrix仪表盘中用来定位不同的聚合集群，只需要在Hystrix Stream的URL中通过cluster参数来指定；</span></span><br><span class="line"><span class="meta">turbine.cluster-name-expression</span>=<span class="string">"default"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#eureka.instance.hostname= mymaster</span></span><br><span class="line"><span class="comment">#eureka.instance.prefer-ip-address=false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数设置为true，可以让同一主机上的服务通过主机名与端口号的组合来进行区分，</span></span><br><span class="line"><span class="comment"># 默认情况下会以host来区分不同的服务，这会使得在本地调试的时候，本机上的不同服务聚合成一个服务来统计</span></span><br><span class="line"><span class="meta">turbine.combine-host-port</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<p>在启动类上添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableTurbine</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurbineApplication</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(TurbineApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时再启动turbine 服务，再在 <a href="http://localhost:1301/hystrix" target="_blank" rel="noopener">http://localhost:1301/hystrix</a>  输入turbine 的<a href="http://localhost:8989/turbine.stream，这时候页面上还是Loading,再访问一次消费者的consumer端口" target="_blank" rel="noopener">http://localhost:8989/turbine.stream，这时候页面上还是Loading,再访问一次消费者的consumer端口</a> <a href="http://localhost:5888/consumer" target="_blank" rel="noopener">http://localhost:5888/consumer</a> </p>
<p><img src="/2019/11/12/springcloud-hystrix/single.png" alt></p>
<p>这格式化系统的架构如下图</p>
<p><img src="/2019/11/12/springcloud-hystrix/singleStruct.png" alt> </p>
<h3 id="通过消息代理收集聚合（AMQP）"><a href="#通过消息代理收集聚合（AMQP）" class="headerlink" title="通过消息代理收集聚合（AMQP）"></a>通过消息代理收集聚合（AMQP）</h3><p> pring Cloud在封装Turbine的时候，还实现了基于消息代理的收集实现。所以，我们可以将所有需要收集的监控信息都输出到消息代理中，然后Turbine服务再从消息代理中异步的获取这些监控信息，最后将这些监控信息聚合并输出到Hystrix Dashboard中。通过引入消息代理，我们的Turbine和Hystrix Dashoard实现的监控架构可以改成如下图所示的结构： </p>
<p><img src="/2019/11/12/springcloud-hystrix/t-ampq.png" alt></p>
<p>这块等我整理完rabbitmq在回来</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>spring cloud</tag>
        <tag>hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>spring ioc&amp;aop</title>
    <url>/2020/07/01/spring-ioc-aop/</url>
    <content><![CDATA[<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p><em>IOC（Inverse of Contro）控制反转，有时候也被称为DI依赖注入，它是一种降低对象耦合关系的一种设计思想。</em></p>
<p>​    一般而言，在开发中使用分层体系结构，都是上层调用下层的接口，上层依赖下层的执行，这就使得调用者依赖被调用者。所以现在调用者和被调用者之间就错在紧密得联系，假如现在一方要进行变动，那么就会导致程序出现较大得变动，显然这不合适，这样降低了程序得可扩展性。</p>
<p>目前开发常用于依赖注入的有spring的@Service,@Resposity,@Component</p>
<p>​    随着SpringBoot的流行，基于注解式开发的热潮逐渐覆盖了基于XML纯配置的开发，而作为Spring中最核心的bean当然也能够使用注解的方式进行表示。使用bean的注解来实现类管理交由spring,</p>
<h2 id="Bean-基础声明"><a href="#Bean-基础声明" class="headerlink" title="@Bean 基础声明"></a>@Bean 基础声明</h2><p>Spring的@Bean注解用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中。</p>
<p>SpringIOC 容器管理一个或者多个bean，<strong><em>这些bean都需要在@Configuration注解下进行创建</em></strong>，在一个方法上使用@Bean注解就表明这个方法需要交给Spring进行管理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class BeanConfig &#123;</span><br><span class="line"></span><br><span class="line">    // 使用@Bean 注解表明myBean需要交给Spring进行管理</span><br><span class="line">    // 未指定bean 的名称，默认采用的是 &quot;方法名&quot; + &quot;首字母小写&quot;的配置方式</span><br><span class="line">    @Bean(&quot;myBean&quot;)</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        return new MyBean();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    @Bean(&quot;myBean2&quot;)</span><br><span class="line">    public MyBean myBean2()&#123;</span><br><span class="line">        MyBean myBean = new MyBean();</span><br><span class="line">        myBean.setValue(&quot;test2&quot;);</span><br><span class="line">        return myBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyBean &#123;</span><br><span class="line"></span><br><span class="line">    private String value;</span><br><span class="line">    public MyBean() &#123;</span><br><span class="line">        System.out.println(&quot;MyBean Initializing&quot;);</span><br><span class="line">        value=&quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加测试方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;myBean2&quot;)//这是指定注入方法</span><br><span class="line">private MyBean myBean;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@PostMapping(&quot;/test&quot;)</span><br><span class="line">public String test() &#123;</span><br><span class="line">    return myBean.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Bean-基本构成"><a href="#Bean-基本构成" class="headerlink" title="@Bean 基本构成"></a>@Bean 基本构成</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Bean &#123;</span><br><span class="line"></span><br><span class="line">	@AliasFor(&quot;name&quot;)</span><br><span class="line">	String[] value() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	@AliasFor(&quot;value&quot;)</span><br><span class="line">	String[] name() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	Autowire autowire() default Autowire.NO;</span><br><span class="line"></span><br><span class="line">	String initMethod() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	String destroyMethod() default AbstractBeanDefinition.INFER_METHOD;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Bean不仅可以作用在方法上，也可以作用在注解类型上，在运行时提供注册。</p>
<p><strong>value</strong>： name属性的别名，在不需要其他属性时使用，也就是说value 就是默认值</p>
<p><strong>name</strong>： 此bean 的名称，或多个名称，主要的bean的名称加别名。如果未指定，则bean的名称是带注解方法的名称。如果指定了，方法的名称就会忽略，如果没有其他属性声明的话，bean的名称和别名可能通过value属性配置</p>
<p><strong>autowire</strong> ： 此注解的方法表示自动装配的类型，返回一个<code>Autowire</code>类型的枚举，我们来看一下<code>Autowire</code>枚举类型的概念</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 枚举确定自动装配状态：即，bean是否应该使用setter注入由Spring容器自动注入其依赖项。</span><br><span class="line">// 这是Spring DI的核心概念</span><br><span class="line">public enum Autowire &#123;</span><br><span class="line"></span><br><span class="line">  	// 常量，表示根本没有自动装配。</span><br><span class="line">	NO(AutowireCapableBeanFactory.AUTOWIRE_NO),</span><br><span class="line">	// 常量，通过名称进行自动装配</span><br><span class="line">	BY_NAME(AutowireCapableBeanFactory.AUTOWIRE_BY_NAME),</span><br><span class="line">	// 常量，通过类型进行自动装配</span><br><span class="line">	BY_TYPE(AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE);</span><br><span class="line"></span><br><span class="line">	private final int value;</span><br><span class="line">	Autowire(int value) &#123;</span><br><span class="line">		this.value = value;</span><br><span class="line">	&#125;</span><br><span class="line">	public int value() &#123;</span><br><span class="line">		return this.value;</span><br><span class="line">	&#125;</span><br><span class="line">	public boolean isAutowire() &#123;</span><br><span class="line">		return (this == BY_NAME || this == BY_TYPE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>nitMethod</strong>: 这个可选择的方法在bean实例化的时候调用，<code>InitializationBean</code>接口允许bean在合适的时机通过设置注解的初始化属性从而调用初始化方法，InitializationBean 接口有一个定义好的初始化方法</p>
<p><strong>destroyMethod</strong>: 方法的可选择名称在调用bean示例在关闭上下文的时候，例如JDBC的close()方法，或者SqlSession的close()方法。<code>DisposableBean</code> 接口的实现允许在bean销毁的时候进行回调调用，DisposableBean 接口之后一个单个的方法</p>
<p>这两个方法都不推荐使用</p>
<h2 id="Bean-注解与其他注解结合使用"><a href="#Bean-注解与其他注解结合使用" class="headerlink" title="@Bean 注解与其他注解结合使用"></a>@Bean 注解与其他注解结合使用</h2><h3 id="Profile-注解"><a href="#Profile-注解" class="headerlink" title="@Profile 注解"></a>@Profile 注解</h3><p>​        @Profile的作用是把一些meta-data进行分类，分成Active和InActive这两种状态，然后你可以选择在active 和在Inactive这两种状态下配置bean，在Inactive状态通常的注解有一个！操作符，通常写为：@Profile(“!p”),这里的p是Profile的名字。</p>
<p>三种激活Profile的方式</p>
<ul>
<li>可以通过ConfigurableEnvironment.setActiveProfiles()以编程的方式激活</li>
<li>可以通过AbstractEnvironment.ACTIVE_PROFILES_PROPERTY_NAME (spring.profiles.active )属性设置JVM属性</li>
<li>作为环境变量，或作为web.xml 应用程序的Servlet 上下文参数。也可以通过@ActiveProfiles 注解在集成测试中以声明方式激活配置文件。</li>
</ul>
<p>现有一个POJO类为Subject学科类，里面有两个属性，一个是like(理科)属性，一个是wenke(文科)属性，分别有两个配置类，一个是<code>AppConfigWithActiveProfile</code> ，一个是<code>AppConfigWithInactiveProfile</code>，当系统环境是 “like”的时候就注册 AppConfigWithActiveProfile ，如果是 “wenke”，就注册 AppConfigWithInactiveProfile，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 学科</span><br><span class="line">public class Subject &#123;</span><br><span class="line"></span><br><span class="line">    // 理科</span><br><span class="line">    private String like;</span><br><span class="line">    // 文科</span><br><span class="line">    private String wenke;</span><br><span class="line"></span><br><span class="line">   //get and set 省略 ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置两个环境不同的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Profile(&quot;like&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class AppConfigWithActiveProfile &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Subject subject()&#123;</span><br><span class="line">        Subject subject = new Subject();</span><br><span class="line">        subject.setLike(&quot;物理&quot;);</span><br><span class="line">        return subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Profile(&quot;wenke&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class AppConfigWithInactiveProfile &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Subject subject()&#123;</span><br><span class="line">        Subject subject = new Subject();</span><br><span class="line">        subject.setWenke(&quot;历史&quot;);</span><br><span class="line">        return subject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加测试方法，测试设置不同的proFile来加载不同的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();</span><br><span class="line">        // 激活 like 的profile</span><br><span class="line">        context.getEnvironment().setActiveProfiles(&quot;like&quot;);</span><br><span class="line">//        context.getEnvironment().setActiveProfiles(&quot;wenke&quot;);</span><br><span class="line">        context.register(AppConfigWithActiveProfile.class,AppConfigWithInactiveProfile.class);</span><br><span class="line">        context.refresh();</span><br><span class="line">        Subject subject = (Subject) context.getBean(&quot;subject&quot;);</span><br><span class="line">        System.out.println(&quot;subject = &quot; + JSON.toJSONString(subject));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Scope-注解"><a href="#Scope-注解" class="headerlink" title="@Scope 注解"></a>@Scope 注解</h3><p>在Spring中对于bean的默认处理都是单例的，我们通过上下文容器.getBean方法拿到bean容器，并对其进行实例化，这个实例化的过程其实只进行一次，即多次getBean 获取的对象都是同一个对象，也就相当于这个bean的实例在IOC容器中是public的，对于所有的bean请求来讲都可以共享此bean。</p>
<p>bean的非单例原型范围会使每次发出对该特定bean的请求时都创建新的bean实例，也就是说，bean被注入另一个bean，或者通过对容器的getBean()方法调用来请求它，可以用如下图来表示：</p>
<p>下面是返回多个实例的示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfigWithAliasAndScope &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 为myBean起两个名字，b1 和 b2</span><br><span class="line">     * @Scope 默认为 singleton，但是可以指定其作用域</span><br><span class="line">     * prototype 是多例的，即每一次调用都会生成一个新的实例。</span><br><span class="line">     */</span><br><span class="line">    @Bean(&#123;&quot;b1&quot;,&quot;b2&quot;&#125;)</span><br><span class="line">    @Scope(&quot;prototype&quot;)</span><br><span class="line">    public MyBean myBean()&#123;</span><br><span class="line">        return new MyBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // ------------------------------ 测试scope  ------------------------------</span><br><span class="line">        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfigWithAliasAndScope.class);</span><br><span class="line">        MyBean myBean = (MyBean) context.getBean(&quot;b1&quot;);</span><br><span class="line">        MyBean myBean2 = (MyBean) context.getBean(&quot;b2&quot;);</span><br><span class="line">        System.out.println(myBean);</span><br><span class="line">        System.out.println(myBean2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Primary和@DependsOn使用的比较简单也比较多，就不赘述了</p>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p><em>AOP面向切面编程，是面向对象开发的一种补充，它允许开发人员在不改变原来模型的以满足新的需求，例如，开发人员可以在不改变原来业务逻辑模型的基础可以进行动态的增加日志，安全或异常处理功能</em></p>
<p>spring cloud 添加切面编程方法，引入切面依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile group: &apos;org.springframework.boot&apos;, name: &apos;spring-boot-starter-aop&apos;, version: &apos;2.3.1.RELEASE&apos;</span><br></pre></td></tr></table></figure>
<p>测试使用注解的方式添加切面的日志</p>
<h2 id="添加自定义注解ServiceLog"><a href="#添加自定义注解ServiceLog" class="headerlink" title="添加自定义注解ServiceLog"></a>添加自定义注解ServiceLog</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//日志级别类</span><br><span class="line">public enum LogType &#123;</span><br><span class="line">    INFO, WARN, ERROR</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//切面编程注解</span><br><span class="line">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface ServiceLog &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作描述</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String operation();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 日志级别</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public LogType level() default LogType.INFO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="切面日志LogAspect"><a href="#切面日志LogAspect" class="headerlink" title="切面日志LogAspect"></a>切面日志LogAspect</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class LogAspect &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger log = LoggerFactory.getLogger(LogAspect.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @Description: 切面方法日志功能</span><br><span class="line">     * @Param: [joinPoint]</span><br><span class="line">     * @return: void</span><br><span class="line">     * @Author: Mr.Wei</span><br><span class="line">     * @Date: 2020/7/2</span><br><span class="line">     */</span><br><span class="line">    public void operateLog(JoinPoint joinPoint) throws ClassNotFoundException &#123;</span><br><span class="line">        String targetName = joinPoint.getTarget().getClass().getName();</span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        Object[] arguments = joinPoint.getArgs();</span><br><span class="line">        Class&lt;?&gt; targetClass = Class.forName(targetName);</span><br><span class="line">        Method[] methods = targetClass.getMethods();</span><br><span class="line">        String operation = &quot;&quot;;</span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">            if (method.getName().equals(methodName)) &#123;</span><br><span class="line">                Class&lt;?&gt;[] clazzs = method.getParameterTypes();</span><br><span class="line">                if (clazzs.length == arguments.length) &#123;</span><br><span class="line">                    operation = method.getAnnotation(ServiceLog.class).operation();// 操作</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder paramsBuf = new StringBuilder();</span><br><span class="line">        for (Object arg : arguments) &#123;</span><br><span class="line">            paramsBuf.append(arg);</span><br><span class="line">            paramsBuf.append(&quot;&amp;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // *========控制台输出=========*//</span><br><span class="line">        log.info(&quot;执行了[&quot; + operation + &quot;],类:&quot; + targetName + &quot;,方法名：&quot; + methodName + &quot;,参数:&quot;</span><br><span class="line">                + paramsBuf.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 切入点</span><br><span class="line">     */</span><br><span class="line">    @Pointcut(&quot;@annotation(com.panghu.rabbit.aop.anno.ServiceLog) &quot;)</span><br><span class="line">    public void entryPoint() &#123;</span><br><span class="line">        // 无需内容</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 切入之前</span><br><span class="line">     *</span><br><span class="line">     * @param joinPoint</span><br><span class="line">     */</span><br><span class="line">    @Before(&quot;entryPoint()&quot;)</span><br><span class="line">    public void before(JoinPoint joinPoint) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            log.info(&quot;=====================开始执行前置通知==================&quot;);</span><br><span class="line">            operateLog(joinPoint);</span><br><span class="line">            log.info(&quot;=====================执行前置通知结束==================&quot;);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            log.info(&quot;around &quot; + joinPoint + &quot; with exception : &quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After(&quot;entryPoint()&quot;)</span><br><span class="line">    public void after(JoinPoint joinPoint) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            log.info(&quot;=====================开始执行后置通知==================&quot;);</span><br><span class="line">            operateLog(joinPoint);</span><br><span class="line">            log.info(&quot;=====================执行后置通知结束==================&quot;);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            log.info(&quot;around &quot; + joinPoint + &quot; with exception : &quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 环绕通知处理处理</span><br><span class="line">     *</span><br><span class="line">     * @param point</span><br><span class="line">     * @throws Throwable</span><br><span class="line">     */</span><br><span class="line">    @Around(&quot;entryPoint()&quot;)</span><br><span class="line">    public Object around(ProceedingJoinPoint point) throws Throwable &#123;</span><br><span class="line">        // 先执行业务,注意:业务这样写业务发生异常不会拦截日志。</span><br><span class="line">        Object result = point.proceed();</span><br><span class="line">        try &#123;</span><br><span class="line">            handleAround(point);// 处理日志</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;日志记录异常&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * around日志记录</span><br><span class="line">     *</span><br><span class="line">     * @param point</span><br><span class="line">     * @throws SecurityException</span><br><span class="line">     * @throws NoSuchMethodException</span><br><span class="line">     */</span><br><span class="line">    public void handleAround(ProceedingJoinPoint point) throws Exception &#123;</span><br><span class="line">        Signature sig = point.getSignature();</span><br><span class="line">        MethodSignature msig = null;</span><br><span class="line">        if (!(sig instanceof MethodSignature)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;该注解只能用于方法&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        msig = (MethodSignature) sig;</span><br><span class="line">        Object target = point.getTarget();</span><br><span class="line">        Method currentMethod = target.getClass().getMethod(msig.getName(), msig.getParameterTypes());</span><br><span class="line">        // 方法名称</span><br><span class="line">        String methodName = currentMethod.getName();</span><br><span class="line">        // 获取注解对象</span><br><span class="line">        ServiceLog aLog = currentMethod.getAnnotation(ServiceLog.class);</span><br><span class="line">        // 类名</span><br><span class="line">        String className = point.getTarget().getClass().getName();</span><br><span class="line">        // 方法的参数</span><br><span class="line">        Object[] params = point.getArgs();</span><br><span class="line"></span><br><span class="line">        StringBuilder paramsBuf = new StringBuilder();</span><br><span class="line">        for (Object arg : params) &#123;</span><br><span class="line">            paramsBuf.append(arg);</span><br><span class="line">            paramsBuf.append(&quot;&amp;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 处理log。。。。</span><br><span class="line">        log.info(&quot;执行了[&quot; + aLog.operation() + &quot;],类:&quot; + className + &quot;,方法名：&quot; + methodName + &quot;,参数:&quot;</span><br><span class="line">                + paramsBuf.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @AfterThrowing(pointcut = &quot;entryPoint()&quot;, throwing = &quot;e&quot;)</span><br><span class="line">    public void doAfterThrowing(JoinPoint joinPoint, Throwable e) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String targetName = joinPoint.getTarget().getClass().getName();</span><br><span class="line">            String methodName = joinPoint.getSignature().getName();</span><br><span class="line">            Object[] arguments = joinPoint.getArgs();</span><br><span class="line">            Class&lt;?&gt; targetClass = Class.forName(targetName);</span><br><span class="line">            Method[] methods = targetClass.getMethods();</span><br><span class="line">            String operation = &quot;&quot;;</span><br><span class="line">            for (Method method : methods) &#123;</span><br><span class="line">                if (method.getName().equals(methodName)) &#123;</span><br><span class="line">                    Class&lt;?&gt;[] clazzs = method.getParameterTypes();</span><br><span class="line">                    if (clazzs.length == arguments.length) &#123;</span><br><span class="line">                        operation = method.getAnnotation(ServiceLog.class).operation();</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            StringBuilder paramsBuf = new StringBuilder();</span><br><span class="line">            for (Object arg : arguments) &#123;</span><br><span class="line">                paramsBuf.append(arg);</span><br><span class="line">                paramsBuf.append(&quot;&amp;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            log.info(&quot;异常方法:&quot; + targetName + &quot;.&quot; + methodName + &quot;();参数:&quot; + paramsBuf.toString() + &quot;,处理:&quot; + operation);</span><br><span class="line">            log.info(&quot;异常信息:&quot; + e.getMessage());</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            log.error(&quot;异常信息:&#123;&#125;&quot;, ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加监听的方法"><a href="#添加监听的方法" class="headerlink" title="添加监听的方法"></a>添加监听的方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ServiceLog(operation = &quot;测试切面编程操作....&quot;)</span><br><span class="line">@PostMapping(&quot;/test&quot;)</span><br><span class="line">public String test(String v1,String v2) throws Exception &#123;</span><br><span class="line">    throw new Exception(&quot;手动抛出异常&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是在监听的方法上添加一个自定义的注解就可以，这样就可以不影响原本的业务逻辑模型，切面记录日志</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring ioc&amp;aop</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud 集成shiro</title>
    <url>/2020/05/25/spring-cloud-%E9%9B%86%E6%88%90shiro/</url>
    <content><![CDATA[<h1 id="Spring-cloud-集成shiro"><a href="#Spring-cloud-集成shiro" class="headerlink" title="Spring cloud 集成shiro"></a>Spring cloud 集成shiro</h1><p>使用的redis作为缓存,不多逼逼，直接上代码</p>
<h3 id="自定义序列化类SerializeUtils"><a href="#自定义序列化类SerializeUtils" class="headerlink" title="自定义序列化类SerializeUtils"></a>自定义序列化类SerializeUtils</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SerializeUtils implements RedisSerializer &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(SerializeUtils.class);</span><br><span class="line"></span><br><span class="line">    public static boolean isEmpty(byte[] data) &#123;</span><br><span class="line">        return (data == null || data.length == 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 序列化</span><br><span class="line">     * @param object</span><br><span class="line">     * @return</span><br><span class="line">     * @throws SerializationException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public byte[] serialize(Object object) throws SerializationException &#123;</span><br><span class="line">        byte[] result = null;</span><br><span class="line"></span><br><span class="line">        if (object == null) &#123;</span><br><span class="line">            return new byte[0];</span><br><span class="line">        &#125;</span><br><span class="line">        try (</span><br><span class="line">                ByteArrayOutputStream byteStream = new ByteArrayOutputStream(128);</span><br><span class="line">                ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteStream)</span><br><span class="line">        )&#123;</span><br><span class="line"></span><br><span class="line">            if (!(object instanceof Serializable)) &#123;</span><br><span class="line">                throw new IllegalArgumentException(SerializeUtils.class.getSimpleName() + &quot; requires a Serializable payload &quot; +</span><br><span class="line">                        &quot;but received an object of type [&quot; + object.getClass().getName() + &quot;]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            objectOutputStream.writeObject(object);</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">            result =  byteStream.toByteArray();</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            logger.error(&quot;Failed to serialize&quot;,ex);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 反序列化</span><br><span class="line">     * @param bytes</span><br><span class="line">     * @return</span><br><span class="line">     * @throws SerializationException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Object deserialize(byte[] bytes) throws SerializationException &#123;</span><br><span class="line"></span><br><span class="line">        Object result = null;</span><br><span class="line"></span><br><span class="line">        if (isEmpty(bytes)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try (</span><br><span class="line">                ByteArrayInputStream byteStream = new ByteArrayInputStream(bytes);</span><br><span class="line">                ObjectInputStream objectInputStream = new ObjectInputStream(byteStream)</span><br><span class="line">        )&#123;</span><br><span class="line">            result = objectInputStream.readObject();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;Failed to deserialize&quot;,e);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RedisConfig"><a href="#RedisConfig" class="headerlink" title="RedisConfig"></a>RedisConfig</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.panghu.config;</span><br><span class="line"></span><br><span class="line">import com.panghu.global.MyByteSource;</span><br><span class="line">import com.panghu.global.SerializeUtils;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line">import org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line">import org.springframework.cache.annotation.EnableCaching;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line">import org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line">import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line">import org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line">import redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: nacos_base4j</span><br><span class="line"> * @Package: com.panghu.config</span><br><span class="line"> * @ClassName: RedisConfig</span><br><span class="line"> * @Author: wxy</span><br><span class="line"> * @Description: redis配置类</span><br><span class="line"> * @Date: 2020/5/18 10:35</span><br><span class="line"> * @Version: 1.0</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableCaching</span><br><span class="line">@Data</span><br><span class="line">public class RedisConfig extends CachingConfigurerSupport &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * spring管理自动注入  redisTemplate &lt;String ,Object&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param factory</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">        // 1.创建 redisTemplate 模版</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();</span><br><span class="line">        // 2.关联 redisConnectionFactory</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        // 3.创建 自定义序列化类</span><br><span class="line"></span><br><span class="line">//        FastJsonRedisSerializer myRedisSerializer = new FastJsonRedisSerializer(Object.class);</span><br><span class="line">        // 7.设置 value 的转化格式和 key 的转化格式 默认使用的是JdkSerializationRedisSerializer</span><br><span class="line">//        template.setValueSerializer(myRedisSerializer);</span><br><span class="line">//        template.setHashValueSerializer(myRedisSerializer);</span><br><span class="line">//        template.setDefaultSerializer(myRedisSerializer);</span><br><span class="line">        GenericJackson2JsonRedisSerializer jackson2JsonRedisSerializer = new GenericJackson2JsonRedisSerializer();</span><br><span class="line">        template.setValueSerializer(new SerializeUtils());</span><br><span class="line">        template.setHashValueSerializer(new SerializeUtils());</span><br><span class="line">        // 设置键（key）的序列化采用StringRedisSerializer。</span><br><span class="line">        template.setKeySerializer(new StringRedisSerializer());</span><br><span class="line">        template.setHashKeySerializer(new StringRedisSerializer());</span><br><span class="line"></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * spring管理自动注入  redisTemplate &lt;String ,String&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param factory</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(StringRedisTemplate.class)</span><br><span class="line">    public RedisTemplate&lt;String, String&gt; stringRedisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">        return new StringRedisTemplate(factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// ################################jedis连接池配置###################################</span><br><span class="line">    /**</span><br><span class="line">     * redis地址</span><br><span class="line">     */</span><br><span class="line">    @Value(&quot;$&#123;spring.redis.host&#125;&quot;)</span><br><span class="line">    private String host;</span><br><span class="line">    /**</span><br><span class="line">     * redis端口号</span><br><span class="line">     */</span><br><span class="line">    @Value(&quot;$&#123;spring.redis.port&#125;&quot;)</span><br><span class="line">    private Integer port;</span><br><span class="line">//    /**</span><br><span class="line">//     * redis密码</span><br><span class="line">//     */</span><br><span class="line">//    @Value(&quot;$&#123;spring.redis.password&#125;&quot;)</span><br><span class="line">//    private String password;</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * JedisPoolConfig 连接池</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public JedisPoolConfig jedisPoolConfig() &#123;</span><br><span class="line">        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();</span><br><span class="line">        //最大空闲数</span><br><span class="line">        jedisPoolConfig.setMaxIdle(300);</span><br><span class="line">        //连接池的最大数据库连接数</span><br><span class="line">        jedisPoolConfig.setMaxTotal(1000);</span><br><span class="line">        //最大建立连接等待时间</span><br><span class="line">        jedisPoolConfig.setMaxWaitMillis(1000);</span><br><span class="line">        //逐出连接的最小空闲时间 默认1800000毫秒(30分钟)</span><br><span class="line">        jedisPoolConfig.setMinEvictableIdleTimeMillis(300000);</span><br><span class="line">        //每次逐出检查时 逐出的最大数目 如果为负数就是 : 1/abs(n), 默认3</span><br><span class="line">        jedisPoolConfig.setNumTestsPerEvictionRun(10);</span><br><span class="line">        //逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1</span><br><span class="line">        jedisPoolConfig.setTimeBetweenEvictionRunsMillis(30000);</span><br><span class="line">        //是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个</span><br><span class="line">        jedisPoolConfig.setTestOnBorrow(true);</span><br><span class="line">        //在空闲时检查有效性, 默认false</span><br><span class="line">        jedisPoolConfig.setTestWhileIdle(true);</span><br><span class="line">        return jedisPoolConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//    /**</span><br><span class="line">//     * 配置工厂</span><br><span class="line">//     *</span><br><span class="line">//     * @param jedisPoolConfig</span><br><span class="line">//     * @return</span><br><span class="line">//     */</span><br><span class="line">//    @Bean</span><br><span class="line">//    public JedisConnectionFactory jedisConnectionFactory(JedisPoolConfig jedisPoolConfig) &#123;</span><br><span class="line">//        JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory();</span><br><span class="line">//        //连接池</span><br><span class="line">//        jedisConnectionFactory.setPoolConfig(jedisPoolConfig);</span><br><span class="line">//        //IP地址</span><br><span class="line">//        jedisConnectionFactory.setHostName(host);</span><br><span class="line">//        //端口号</span><br><span class="line">//        jedisConnectionFactory.setPort(port);</span><br><span class="line">//        //如果Redis设置有密码</span><br><span class="line">////        jedisConnectionFactory.setPassword(password);</span><br><span class="line">//        //客户端超时时间单位是毫秒</span><br><span class="line">//        jedisConnectionFactory.setTimeout(5000);</span><br><span class="line">//        return jedisConnectionFactory;</span><br><span class="line">//    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="RedisManager"><a href="#RedisManager" class="headerlink" title="RedisManager"></a>RedisManager</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RedisManager &#123;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    //=============================common============================</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 指定缓存失效时间</span><br><span class="line">     *</span><br><span class="line">     * @param key  键</span><br><span class="line">     * @param time 时间(秒)</span><br><span class="line">     */</span><br><span class="line">    public void expire(String key, long time) &#123;</span><br><span class="line">        redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断key是否存在</span><br><span class="line">     *</span><br><span class="line">     * @param key 键</span><br><span class="line">     * @return true 存在 false不存在</span><br><span class="line">     */</span><br><span class="line">    public Boolean hasKey(String key) &#123;</span><br><span class="line">        return redisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除缓存</span><br><span class="line">     *</span><br><span class="line">     * @param key 可以传一个值 或多个</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public void del(String... key) &#123;</span><br><span class="line">        if (key != null &amp;&amp; key.length &gt; 0) &#123;</span><br><span class="line">            if (key.length == 1) &#123;</span><br><span class="line">                redisTemplate.delete(key[0]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                redisTemplate.delete(CollectionUtils.arrayToList(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量删除key</span><br><span class="line">     *</span><br><span class="line">     * @param keys</span><br><span class="line">     */</span><br><span class="line">    public void del(Collection keys) &#123;</span><br><span class="line">        redisTemplate.delete(keys);</span><br><span class="line">    &#125;</span><br><span class="line">    //============================String=============================</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 普通缓存获取</span><br><span class="line">     *</span><br><span class="line">     * @param key 键</span><br><span class="line">     * @return 值</span><br><span class="line">     */</span><br><span class="line">    public Object get(String key) &#123;</span><br><span class="line">        return redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 普通缓存放入</span><br><span class="line">     *</span><br><span class="line">     * @param key   键</span><br><span class="line">     * @param value 值</span><br><span class="line">     */</span><br><span class="line">    public void set(String key, Object value) &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 普通缓存放入并设置时间</span><br><span class="line">     *</span><br><span class="line">     * @param key   键</span><br><span class="line">     * @param value 值</span><br><span class="line">     * @param time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span><br><span class="line">     */</span><br><span class="line">    public void set(String key, Object value, long time) &#123;</span><br><span class="line">        if (time &gt; 0) &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            set(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用scan命令 查询某些前缀的key</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; scan(String key) &#123;</span><br><span class="line">        Set&lt;String&gt; execute = this.redisTemplate.execute(new RedisCallback&lt;Set&lt;String&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Set&lt;String&gt; doInRedis(RedisConnection connection) throws DataAccessException &#123;</span><br><span class="line">                Set&lt;String&gt; binaryKeys = new HashSet&lt;&gt;();</span><br><span class="line">                Cursor&lt;byte[]&gt; cursor = connection.scan(new ScanOptions.ScanOptionsBuilder().match(key).count(1000).build());</span><br><span class="line">                while (cursor.hasNext()) &#123;</span><br><span class="line">                    binaryKeys.add(new String(cursor.next()));</span><br><span class="line">                &#125;</span><br><span class="line">                return binaryKeys;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return execute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用scan命令 查询某些前缀的key 有多少个</span><br><span class="line">     * 用来获取当前session数量,也就是在线用户</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long scanSize(String key) &#123;</span><br><span class="line">        long dbSize = this.redisTemplate.execute(new RedisCallback&lt;Long&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Long doInRedis(RedisConnection connection) throws DataAccessException &#123;</span><br><span class="line">                long count = 0L;</span><br><span class="line">                Cursor&lt;byte[]&gt; cursor = connection.scan(ScanOptions.scanOptions().match(key).count(1000).build());</span><br><span class="line">                while (cursor.hasNext()) &#123;</span><br><span class="line">                    cursor.next();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                return count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return dbSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="redis-作为缓存管理shiro"><a href="#redis-作为缓存管理shiro" class="headerlink" title="redis 作为缓存管理shiro"></a>redis 作为缓存管理shiro</h2><p>使用Redis作为缓存需要shiro重写RedisCache、RedisCacheManager、SessionDAO</p>
<h3 id="RedisCache"><a href="#RedisCache" class="headerlink" title="RedisCache"></a>RedisCache</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RedisCache&lt;K,V&gt; implements Cache&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(RedisCache.class);</span><br><span class="line">    private RedisManager redisManager;</span><br><span class="line">    private String keyPrefix = &quot;&quot;;</span><br><span class="line">    private int expire = 0;</span><br><span class="line">    private String principalIdFieldName =  RedisCacheManager.DEFAULT_PRINCIPAL_ID_FIELD_NAME;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造方法</span><br><span class="line">     * @param redisManager</span><br><span class="line">     */</span><br><span class="line">    public RedisCache(RedisManager redisManager, String prefix, int expire, String principalIdFieldName) &#123;</span><br><span class="line">        if (redisManager == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;redisManager cannot be null.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.redisManager = redisManager;</span><br><span class="line">        if (prefix != null &amp;&amp; !&quot;&quot;.equals(prefix)) &#123;</span><br><span class="line">            this.keyPrefix = prefix;</span><br><span class="line">        &#125;</span><br><span class="line">        if (expire != -1) &#123;</span><br><span class="line">            this.expire = expire;</span><br><span class="line">        &#125;</span><br><span class="line">        if (principalIdFieldName != null &amp;&amp; !&quot;&quot;.equals(principalIdFieldName)) &#123;</span><br><span class="line">            this.principalIdFieldName = principalIdFieldName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据key 获取value</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     * @throws CacheException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public V get(K key) throws CacheException &#123;</span><br><span class="line">        logger.debug(&quot;get key [&#123;&#125;]&quot;,key);</span><br><span class="line">        if (key == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            String redisCacheKey = getRedisCacheKey(key);</span><br><span class="line">            Object rawValue = redisManager.get(redisCacheKey);</span><br><span class="line">            if (rawValue == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            V value = (V) rawValue;</span><br><span class="line">            return value;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new CacheException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 存放key -value到缓存中</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     * @throws CacheException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public V put(K key, V value) throws CacheException &#123;</span><br><span class="line">        logger.debug(&quot;put key [&#123;&#125;]&quot;,key);</span><br><span class="line">        if (key == null) &#123;</span><br><span class="line">            logger.warn(&quot;Saving a null key is meaningless, return value directly without call Redis.&quot;);</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            String redisCacheKey = getRedisCacheKey(key);</span><br><span class="line">            redisManager.set(redisCacheKey, value != null ? value : null, expire);</span><br><span class="line">            return value;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new CacheException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除一个缓存数据源</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     * @throws CacheException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public V remove(K key) throws CacheException &#123;</span><br><span class="line">        logger.debug(&quot;remove key [&#123;&#125;]&quot;,key);</span><br><span class="line">        if (key == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            String redisCacheKey = getRedisCacheKey(key);</span><br><span class="line">            Object rawValue = redisManager.get(redisCacheKey);</span><br><span class="line">            V previous = (V) rawValue;</span><br><span class="line">            redisManager.del(redisCacheKey);</span><br><span class="line">            return previous;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new CacheException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private String getRedisCacheKey(K key) &#123;</span><br><span class="line">        if (key == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return this.keyPrefix + getStringRedisKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">    private String getStringRedisKey(K key) &#123;</span><br><span class="line">        String redisKey;</span><br><span class="line">        if (key instanceof PrincipalCollection) &#123;</span><br><span class="line">            redisKey = getRedisKeyFromPrincipalIdField((PrincipalCollection) key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            redisKey = key.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        return redisKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getRedisKeyFromPrincipalIdField(PrincipalCollection key) &#123;</span><br><span class="line">        String redisKey;</span><br><span class="line">        Object principalObject = key.getPrimaryPrincipal();</span><br><span class="line">        Method pincipalIdGetter = null;</span><br><span class="line">        Method[] methods = principalObject.getClass().getDeclaredMethods();</span><br><span class="line">        for (Method m:methods) &#123;</span><br><span class="line">            if (RedisCacheManager.DEFAULT_PRINCIPAL_ID_FIELD_NAME.equals(this.principalIdFieldName)</span><br><span class="line">                    &amp;&amp; (&quot;getAuthCacheKey&quot;.equals(m.getName()) || &quot;getId&quot;.equals(m.getName()))) &#123;</span><br><span class="line">                pincipalIdGetter = m;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (m.getName().equals(&quot;get&quot; + this.principalIdFieldName.substring(0, 1).toUpperCase() + this.principalIdFieldName.substring(1))) &#123;</span><br><span class="line">                pincipalIdGetter = m;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pincipalIdGetter == null) &#123;</span><br><span class="line">            throw new PrincipalInstanceException(principalObject.getClass(), this.principalIdFieldName);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            Object idObj = pincipalIdGetter.invoke(principalObject);</span><br><span class="line">            if (idObj == null) &#123;</span><br><span class="line">                throw new PrincipalIdNullException(principalObject.getClass(), this.principalIdFieldName);</span><br><span class="line">            &#125;</span><br><span class="line">            redisKey = idObj.toString();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            throw new PrincipalInstanceException(principalObject.getClass(), this.principalIdFieldName, e);</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            throw new PrincipalInstanceException(principalObject.getClass(), this.principalIdFieldName, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return redisKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clear() throws CacheException &#123;</span><br><span class="line">        logger.debug(&quot;clear cache&quot;);</span><br><span class="line">        Set&lt;String&gt; keys = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            keys = redisManager.scan(this.keyPrefix + &quot;*&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;get keys error&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        if (keys == null || keys.size() == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (String key: keys) &#123;</span><br><span class="line">            redisManager.del(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        Long longSize = 0L;</span><br><span class="line">        try &#123;</span><br><span class="line">            longSize = new Long(redisManager.scanSize(this.keyPrefix + &quot;*&quot;));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;get keys error&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return longSize.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;K&gt; keys() &#123;</span><br><span class="line">        Set&lt;String&gt; keys = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            keys = redisManager.scan(this.keyPrefix + &quot;*&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;get keys error&quot;, e);</span><br><span class="line">            return Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line">        if (CollectionUtils.isEmpty(keys)) &#123;</span><br><span class="line">            return Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;K&gt; convertedKeys = new HashSet&lt;K&gt;();</span><br><span class="line">        for (String key:keys) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                convertedKeys.add((K) key);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logger.error(&quot;deserialize keys error&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return convertedKeys;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Collection&lt;V&gt; values() &#123;</span><br><span class="line">        Set&lt;String&gt; keys = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            keys = redisManager.scan(this.keyPrefix + &quot;*&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;get values error&quot;, e);</span><br><span class="line">            return Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line">        if (CollectionUtils.isEmpty(keys)) &#123;</span><br><span class="line">            return Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;V&gt; values = new ArrayList&lt;V&gt;(keys.size());</span><br><span class="line">        for (String key : keys) &#123;</span><br><span class="line">            V value = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                value = (V) redisManager.get(key);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logger.error(&quot;deserialize values= error&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">            if (value != null) &#123;</span><br><span class="line">                values.add(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Collections.unmodifiableList(values);</span><br><span class="line">    &#125;</span><br><span class="line">    public String getKeyPrefix() &#123;</span><br><span class="line">        return keyPrefix;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setKeyPrefix(String keyPrefix) &#123;</span><br><span class="line">        this.keyPrefix = keyPrefix;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getPrincipalIdFieldName() &#123;</span><br><span class="line">        return principalIdFieldName;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setPrincipalIdFieldName(String principalIdFieldName) &#123;</span><br><span class="line">        this.principalIdFieldName = principalIdFieldName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RedisCacheManager"><a href="#RedisCacheManager" class="headerlink" title="RedisCacheManager"></a>RedisCacheManager</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RedisCacheManager implements CacheManager &#123;</span><br><span class="line"></span><br><span class="line">    private final Logger logger = LoggerFactory.getLogger(RedisCacheManager.class);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * fast lookup by name map</span><br><span class="line">     */</span><br><span class="line">    private final ConcurrentMap&lt;String, Cache&gt; caches = new ConcurrentHashMap&lt;String, Cache&gt;();</span><br><span class="line">    private RedisManager redisManager;</span><br><span class="line">    /**</span><br><span class="line">     * expire time in seconds</span><br><span class="line">     */</span><br><span class="line">    private static final int DEFAULT_EXPIRE = 1800;</span><br><span class="line">    private int expire = DEFAULT_EXPIRE;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The Redis key prefix for caches</span><br><span class="line">     */</span><br><span class="line">    public static final String DEFAULT_CACHE_KEY_PREFIX = &quot;shiro:cache:&quot;;</span><br><span class="line">    private String keyPrefix = DEFAULT_CACHE_KEY_PREFIX;</span><br><span class="line">    public static final String DEFAULT_PRINCIPAL_ID_FIELD_NAME = &quot;authCacheKey or id&quot;;</span><br><span class="line">    private String principalIdFieldName = DEFAULT_PRINCIPAL_ID_FIELD_NAME;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;K, V&gt; Cache&lt;K, V&gt; getCache(String name) throws CacheException &#123;</span><br><span class="line">        logger.debug(&quot;get cache, name=&#123;&#125;&quot;,name);</span><br><span class="line">        Cache cache = caches.get(name);</span><br><span class="line">        if (cache == null) &#123;</span><br><span class="line">            cache = new RedisCache&lt;K, V&gt;(redisManager,keyPrefix + name + &quot;:&quot;, expire, principalIdFieldName);</span><br><span class="line">            caches.put(name, cache);</span><br><span class="line">        &#125;</span><br><span class="line">        return cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Logger getLogger() &#123;</span><br><span class="line">        return logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ConcurrentMap&lt;String, Cache&gt; getCaches() &#123;</span><br><span class="line">        return caches;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RedisManager getRedisManager() &#123;</span><br><span class="line">        return redisManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRedisManager(RedisManager redisManager) &#123;</span><br><span class="line">        this.redisManager = redisManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int getDefaultExpire() &#123;</span><br><span class="line">        return DEFAULT_EXPIRE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getExpire() &#123;</span><br><span class="line">        return expire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setExpire(int expire) &#123;</span><br><span class="line">        this.expire = expire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getDefaultCacheKeyPrefix() &#123;</span><br><span class="line">        return DEFAULT_CACHE_KEY_PREFIX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getKeyPrefix() &#123;</span><br><span class="line">        return keyPrefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setKeyPrefix(String keyPrefix) &#123;</span><br><span class="line">        this.keyPrefix = keyPrefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getDefaultPrincipalIdFieldName() &#123;</span><br><span class="line">        return DEFAULT_PRINCIPAL_ID_FIELD_NAME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPrincipalIdFieldName() &#123;</span><br><span class="line">        return principalIdFieldName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrincipalIdFieldName(String principalIdFieldName) &#123;</span><br><span class="line">        this.principalIdFieldName = principalIdFieldName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RedisSessionDAO"><a href="#RedisSessionDAO" class="headerlink" title="RedisSessionDAO"></a>RedisSessionDAO</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RedisSessionDAO extends AbstractSessionDAO &#123;</span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(RedisSessionDAO.class);</span><br><span class="line">    private static final String DEFAULT_SESSION_KEY_PREFIX = &quot;shiro:session:&quot;;</span><br><span class="line">    private String keyPrefix = DEFAULT_SESSION_KEY_PREFIX;</span><br><span class="line">    private static final long DEFAULT_SESSION_IN_MEMORY_TIMEOUT = 1000L;</span><br><span class="line">    /**</span><br><span class="line">     * doReadSession be called about 10 times when login.</span><br><span class="line">     * Save Session in ThreadLocal to resolve this problem. sessionInMemoryTimeout is expiration of Session in ThreadLocal.</span><br><span class="line">     * The default value is 1000 milliseconds (1s).</span><br><span class="line">     * Most of time, you don&apos;t need to change it.</span><br><span class="line">     */</span><br><span class="line">    private long sessionInMemoryTimeout = DEFAULT_SESSION_IN_MEMORY_TIMEOUT;</span><br><span class="line">    /**</span><br><span class="line">     * expire time in seconds</span><br><span class="line">     */</span><br><span class="line">    private static final int DEFAULT_EXPIRE = -2;</span><br><span class="line">    private static final int NO_EXPIRE = -1;</span><br><span class="line">    /**</span><br><span class="line">     * Please make sure expire is longer than sesion.getTimeout()</span><br><span class="line">     */</span><br><span class="line">    private int expire = DEFAULT_EXPIRE;</span><br><span class="line">    private static final int MILLISECONDS_IN_A_SECOND = 1000;</span><br><span class="line">    private RedisManager redisManager;</span><br><span class="line">    private static ThreadLocal sessionsInThread = new ThreadLocal();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update(Session session) throws UnknownSessionException &#123;</span><br><span class="line">        //如果会话过期/停止 没必要再更新了</span><br><span class="line">        try &#123;</span><br><span class="line">            if (session instanceof ValidatingSession &amp;&amp; !((ValidatingSession) session).isValid()) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (session instanceof ShiroSession) &#123;</span><br><span class="line">                // 如果没有主要字段(除lastAccessTime以外其他字段)发生改变</span><br><span class="line">                ShiroSession ss = (ShiroSession) session;</span><br><span class="line">                if (!ss.isChanged()) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                //如果没有返回 证明有调用 setAttribute往redis 放的时候永远设置为false</span><br><span class="line">                ss.setChanged(false);</span><br><span class="line">            &#125;</span><br><span class="line">            this.saveSession(session);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.warn(&quot;update Session is failed&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * save session</span><br><span class="line">     *</span><br><span class="line">     * @param session</span><br><span class="line">     * @throws UnknownSessionException</span><br><span class="line">     */</span><br><span class="line">    private void saveSession(Session session) throws UnknownSessionException &#123;</span><br><span class="line">        if (session == null || session.getId() == null) &#123;</span><br><span class="line">            logger.error(&quot;session or session id is null&quot;);</span><br><span class="line">            throw new UnknownSessionException(&quot;session or session id is null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        String key = getRedisSessionKey(session.getId());</span><br><span class="line">        if (expire == DEFAULT_EXPIRE) &#123;</span><br><span class="line">            this.redisManager.set(key, session, (int) (session.getTimeout() / MILLISECONDS_IN_A_SECOND));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (expire != NO_EXPIRE &amp;&amp; expire * MILLISECONDS_IN_A_SECOND &lt; session.getTimeout()) &#123;</span><br><span class="line">            logger.warn(&quot;Redis session expire time: &quot;</span><br><span class="line">                    + (expire * MILLISECONDS_IN_A_SECOND)</span><br><span class="line">                    + &quot; is less than Session timeout: &quot;</span><br><span class="line">                    + session.getTimeout()</span><br><span class="line">                    + &quot; . It may cause some problems.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.redisManager.set(key, session, expire);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void delete(Session session) &#123;</span><br><span class="line">        if (session == null || session.getId() == null) &#123;</span><br><span class="line">            logger.error(&quot;session or session id is null&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            redisManager.del(getRedisSessionKey(session.getId()));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;delete session error. session id= &#123;&#125;&quot;, session.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Collection&lt;Session&gt; getActiveSessions() &#123;</span><br><span class="line">        Set&lt;Session&gt; sessions = new HashSet&lt;Session&gt;();</span><br><span class="line">        try &#123;</span><br><span class="line">            Set&lt;String&gt; keys = redisManager.scan(this.keyPrefix + &quot;*&quot;);</span><br><span class="line">            if (keys != null &amp;&amp; keys.size() &gt; 0) &#123;</span><br><span class="line">                for (String key : keys) &#123;</span><br><span class="line">                    Session s = (Session) redisManager.get(key);</span><br><span class="line">                    sessions.add(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;get active sessions error.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return sessions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long getActiveSessionsSize() &#123;</span><br><span class="line">        Long size = 0L;</span><br><span class="line">        try &#123;</span><br><span class="line">            size = redisManager.scanSize(this.keyPrefix + &quot;*&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;get active sessions error.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Serializable doCreate(Session session) &#123;</span><br><span class="line">        if (session == null) &#123;</span><br><span class="line">            logger.error(&quot;session is null&quot;);</span><br><span class="line">            throw new UnknownSessionException(&quot;session is null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Serializable sessionId = this.generateSessionId(session);</span><br><span class="line">        this.assignSessionId(session, sessionId);</span><br><span class="line">        this.saveSession(session);</span><br><span class="line">        return sessionId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Session doReadSession(Serializable sessionId) &#123;</span><br><span class="line">        if (sessionId == null) &#123;</span><br><span class="line">            logger.warn(&quot;session id is null&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //线程缓存中获取sessionId</span><br><span class="line">        Session s = getSessionFromThreadLocal(sessionId);</span><br><span class="line">        if (s != null) &#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        logger.debug(&quot;read session from redis&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            s = (Session) redisManager.get(getRedisSessionKey(sessionId));</span><br><span class="line">            setSessionToThreadLocal(sessionId, s);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;read session error. settionId= &#123;&#125;&quot;, sessionId);</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setSessionToThreadLocal(Serializable sessionId, Session s) &#123;</span><br><span class="line">        Map&lt;Serializable, SessionInMemory&gt; sessionMap = (Map&lt;Serializable, SessionInMemory&gt;) sessionsInThread.get();</span><br><span class="line">        if (sessionMap == null) &#123;</span><br><span class="line">            sessionMap = new HashMap&lt;Serializable, SessionInMemory&gt;();</span><br><span class="line">            sessionsInThread.set(sessionMap);</span><br><span class="line">        &#125;</span><br><span class="line">        SessionInMemory sessionInMemory = new SessionInMemory();</span><br><span class="line">        sessionInMemory.setCreateTime(new Date());</span><br><span class="line">        sessionInMemory.setSession(s);</span><br><span class="line">        sessionMap.put(sessionId, sessionInMemory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Session getSessionFromThreadLocal(Serializable sessionId) &#123;</span><br><span class="line">        Session s = null;</span><br><span class="line">        if (sessionsInThread.get() == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Serializable, SessionInMemory&gt; sessionMap = (Map&lt;Serializable, SessionInMemory&gt;) sessionsInThread.get();</span><br><span class="line">        SessionInMemory sessionInMemory = sessionMap.get(sessionId);</span><br><span class="line">        if (sessionInMemory == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Date now = new Date();</span><br><span class="line">        long duration = now.getTime() - sessionInMemory.getCreateTime().getTime();</span><br><span class="line">        if (duration &lt; sessionInMemoryTimeout) &#123;</span><br><span class="line">            s = sessionInMemory.getSession();</span><br><span class="line">            logger.debug(&quot;read session from memory&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sessionMap.remove(sessionId);</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private String getRedisSessionKey(Serializable sessionId) &#123;</span><br><span class="line">        return this.keyPrefix + sessionId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RedisManager getRedisManager() &#123;</span><br><span class="line">        return redisManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRedisManager(RedisManager redisManager) &#123;</span><br><span class="line">        this.redisManager = redisManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getKeyPrefix() &#123;</span><br><span class="line">        return keyPrefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setKeyPrefix(String keyPrefix) &#123;</span><br><span class="line">        this.keyPrefix = keyPrefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getSessionInMemoryTimeout() &#123;</span><br><span class="line">        return sessionInMemoryTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSessionInMemoryTimeout(long sessionInMemoryTimeout) &#123;</span><br><span class="line">        this.sessionInMemoryTimeout = sessionInMemoryTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getExpire() &#123;</span><br><span class="line">        return expire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setExpire(int expire) &#123;</span><br><span class="line">        this.expire = expire;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="shiro配置"><a href="#shiro配置" class="headerlink" title="shiro配置"></a>shiro配置</h2><h3 id="ShiroConfig"><a href="#ShiroConfig" class="headerlink" title="ShiroConfig"></a>ShiroConfig</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.panghu.config;</span><br><span class="line"></span><br><span class="line">import com.panghu.reids.RedisCacheManager;</span><br><span class="line">import com.panghu.reids.RedisManager;</span><br><span class="line">import com.panghu.reids.RedisSessionDAO;</span><br><span class="line">import com.panghu.shiro.*;</span><br><span class="line">import org.apache.shiro.mgt.SecurityManager;</span><br><span class="line">import org.apache.shiro.session.SessionListener;</span><br><span class="line">import org.apache.shiro.session.mgt.SessionManager;</span><br><span class="line">import org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator;</span><br><span class="line">import org.apache.shiro.session.mgt.eis.SessionDAO;</span><br><span class="line">import org.apache.shiro.session.mgt.eis.SessionIdGenerator;</span><br><span class="line">import org.apache.shiro.spring.LifecycleBeanPostProcessor;</span><br><span class="line">import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;</span><br><span class="line">import org.apache.shiro.spring.web.ShiroFilterFactoryBean;</span><br><span class="line">import org.apache.shiro.web.filter.authc.FormAuthenticationFilter;</span><br><span class="line">import org.apache.shiro.web.mgt.DefaultWebSecurityManager;</span><br><span class="line">import org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line">import org.springframework.beans.factory.config.MethodInvokingFactoryBean;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.handler.SimpleMappingExceptionResolver;</span><br><span class="line"></span><br><span class="line">import javax.servlet.Filter;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.LinkedHashMap;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: nacos_base4j</span><br><span class="line"> * @Package: com.panghu.config</span><br><span class="line"> * @ClassName: ShiroConfig</span><br><span class="line"> * @Author: wxy</span><br><span class="line"> * @Description: shiro配置</span><br><span class="line"> * @Date: 2020/5/5 14:19</span><br><span class="line"> * @Version: 1.0</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class ShiroConfig &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @Description: 过滤器配置</span><br><span class="line">     * @Param: [securityManager]</span><br><span class="line">     * @return: org.apache.shiro.spring.web.ShiroFilterFactoryBean</span><br><span class="line">     * @Author: Mr.Wei</span><br><span class="line">     * @Date: 2020/5/19</span><br><span class="line">     */</span><br><span class="line">    @Bean(name = &quot;shirFilter&quot;)</span><br><span class="line">    public ShiroFilterFactoryBean shirFilter(@Qualifier(&quot;securityManager&quot;) SecurityManager securityManager) &#123;</span><br><span class="line">        System.out.println(&quot;ShiroConfiguration.shirFilter()&quot;);</span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();</span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        // 如果不设置默认会自动寻找Web工程根目录下的&quot;/login.jsp&quot;页面,设置的话没经过验证会发送test请求到控制器，由控制器决定转到对应视图</span><br><span class="line">//        shiroFilterFactoryBean.setLoginUrl(&quot;/login&quot;);</span><br><span class="line">        // 登录成功后要跳转的链接url</span><br><span class="line">//        shiroFilterFactoryBean.setSuccessUrl(&quot;/index&quot;);</span><br><span class="line">        //未授权界面,该配置无效，并不会进行页面跳转</span><br><span class="line">        shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/unauthorized&quot;);</span><br><span class="line"></span><br><span class="line">        //自定义拦截器限制并发人数,参考博客：</span><br><span class="line">        LinkedHashMap&lt;String, Filter&gt; filtersMap = new LinkedHashMap&lt;&gt;();</span><br><span class="line">        //限制同一帐号同时在线的个数</span><br><span class="line">//        filtersMap.put(&quot;kickout&quot;, kickoutSessionControlFilter());</span><br><span class="line">        //统计登录人数</span><br><span class="line">        shiroFilterFactoryBean.setFilters(filtersMap);</span><br><span class="line"></span><br><span class="line">        // 配置访问权限 必须是LinkedHashMap，因为它必须保证有序</span><br><span class="line">        // 过滤链定义，从上向下顺序执行，一般将 /**放在最为下边 --&gt; : 这是一个坑，一不小心代码就不好使了</span><br><span class="line">        LinkedHashMap&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;();</span><br><span class="line">        //配置不登录可以访问的资源，anon 表示资源都可以匿名访问</span><br><span class="line">        //配置记住我或认证通过可以访问的地址</span><br><span class="line">//        filterChainDefinitionMap.put(&quot;/login&quot;, &quot;anon&quot;);</span><br><span class="line">        filterChainDefinitionMap.put(&quot;/&quot;, &quot;anon&quot;);</span><br><span class="line">        filterChainDefinitionMap.put(&quot;/druid/**&quot;, &quot;anon&quot;);</span><br><span class="line">        //解锁用户专用 测试用的</span><br><span class="line">        filterChainDefinitionMap.put(&quot;/unlockAccount&quot;, &quot;anon&quot;);</span><br><span class="line">        filterChainDefinitionMap.put(&quot;/Captcha.jpg&quot;, &quot;anon&quot;);</span><br><span class="line">        //logout是shiro提供的过滤器</span><br><span class="line">        filterChainDefinitionMap.put(&quot;/logout&quot;, &quot;logout&quot;);</span><br><span class="line">        //此时访问/user/delete需要delete权限,在自定义Realm中为用户授权。</span><br><span class="line">        //filterChainDefinitionMap.put(&quot;/user/delete&quot;, &quot;perms[\&quot;user:delete\&quot;]&quot;);</span><br><span class="line">        //其他资源都需要认证  authc 表示需要认证才能进行访问 user表示配置记住我或认证通过可以访问的地址</span><br><span class="line">        //如果开启限制同一账号登录,改为 .put(&quot;/**&quot;, &quot;kickout,user&quot;);</span><br><span class="line">//        filterChainDefinitionMap.put(&quot;/**&quot;, &quot;kickout,user&quot;);</span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">        return shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @Description: 配置核心安全事务管理器</span><br><span class="line">     * @Param: []</span><br><span class="line">     * @return: org.apache.shiro.mgt.SecurityMasnager</span><br><span class="line">     * @Author: Mr.Wei</span><br><span class="line">     * @Date: 2020/5/17</span><br><span class="line">     */</span><br><span class="line">    @Bean(name = &quot;securityManager&quot;)</span><br><span class="line">    public SecurityManager securityManager() &#123;</span><br><span class="line">        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();</span><br><span class="line">        //自定义权限方法和权限方法</span><br><span class="line">        securityManager.setRealm(shiroRealm());</span><br><span class="line">        // 自定义session管理 使用redis</span><br><span class="line">        securityManager.setSessionManager(sessionManager());</span><br><span class="line">        // 自定义缓存实现 使用redis</span><br><span class="line">        securityManager.setCacheManager(redisCacheManager());</span><br><span class="line">        return securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @Description: 自定义权限/密码验证方式</span><br><span class="line">     * @Param: []</span><br><span class="line">     * @return: com.panghu.shiro.MyShiroRealm</span><br><span class="line">     * @Author: Mr.Wei</span><br><span class="line">     * @Date: 2020/5/17</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public ShiroRealm shiroRealm() &#123;</span><br><span class="line">        ShiroRealm shiroRealm = new ShiroRealm();</span><br><span class="line">        //启用全局缓存</span><br><span class="line">        shiroRealm.setCachingEnabled(true);</span><br><span class="line">        //启用身份验证缓存，即缓存AuthenticationInfo信息，默认false</span><br><span class="line">        shiroRealm.setAuthenticationCachingEnabled(true);</span><br><span class="line">        //缓存AuthenticationInfo信息的缓存名称 在ehcache-shiro.xml中有对应缓存的配置</span><br><span class="line">        shiroRealm.setAuthenticationCacheName(&quot;authenticationCache&quot;);</span><br><span class="line">        //启用授权缓存，即缓存AuthorizationInfo信息，默认false</span><br><span class="line">        shiroRealm.setAuthorizationCachingEnabled(true);</span><br><span class="line">        //缓存AuthorizationInfo信息的缓存名称  在ehcache-shiro.xml中有对应缓存的配置</span><br><span class="line">        shiroRealm.setAuthorizationCacheName(&quot;authorizationCache&quot;);</span><br><span class="line">        //设置自定义密码匹配</span><br><span class="line">        shiroRealm.setCredentialsMatcher(retryLimitHashedCredentialsMatcher());</span><br><span class="line">        return shiroRealm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置Shiro生命周期处理器</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean(name = &quot;lifecycleBeanPostProcessor&quot;)</span><br><span class="line">    public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() &#123;</span><br><span class="line">        return new LifecycleBeanPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 开启shiro aop注解支持.</span><br><span class="line">     * 使用代理方式;所以需要开启代码支持;</span><br><span class="line">     *</span><br><span class="line">     * @param securityManager</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) &#123;</span><br><span class="line">        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor();</span><br><span class="line">        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line">        return authorizationAttributeSourceAdvisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解决： 无权限页面不跳转 shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/unauthorized&quot;) 无效</span><br><span class="line">     * shiro的源代码ShiroFilterFactoryBean.Java定义的filter必须满足filter instanceof AuthorizationFilter，</span><br><span class="line">     * 只有perms，roles，ssl，rest，port才是属于AuthorizationFilter，而anon，authcBasic，auchc，user是AuthenticationFilter，</span><br><span class="line">     * 所以unauthorizedUrl设置后页面不跳转 Shiro注解模式下，登录失败与没有权限都是通过抛出异常。</span><br><span class="line">     * 并且默认并没有去处理或者捕获这些异常。在SpringMVC下需要配置捕获相应异常来通知用户信息</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public SimpleMappingExceptionResolver simpleMappingExceptionResolver() &#123;</span><br><span class="line">        SimpleMappingExceptionResolver simpleMappingExceptionResolver = new SimpleMappingExceptionResolver();</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        //这里的 /unauthorized 是页面，不是访问的路径</span><br><span class="line">        properties.setProperty(&quot;org.apache.shiro.authz.UnauthorizedException&quot;, &quot;/unauthorized&quot;);</span><br><span class="line">        properties.setProperty(&quot;org.apache.shiro.authz.UnauthenticatedException&quot;, &quot;/unauthorized&quot;);</span><br><span class="line">        simpleMappingExceptionResolver.setExceptionMappings(properties);</span><br><span class="line">        return simpleMappingExceptionResolver;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * FormAuthenticationFilter 过滤器 过滤记住我</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public FormAuthenticationFilter formAuthenticationFilter() &#123;</span><br><span class="line">        FormAuthenticationFilter formAuthenticationFilter = new FormAuthenticationFilter();</span><br><span class="line">        //对应前端的checkbox的name = rememberMe</span><br><span class="line">        formAuthenticationFilter.setRememberMeParam(&quot;rememberMe&quot;);</span><br><span class="line">        return formAuthenticationFilter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * shiro缓存管理器;</span><br><span class="line">     * 需要添加到securityManager中</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public RedisCacheManager redisCacheManager() &#123;</span><br><span class="line">        RedisCacheManager redisCacheManager = new RedisCacheManager();</span><br><span class="line">        redisCacheManager.setRedisManager(redisManager());</span><br><span class="line">        //redis中针对不同用户缓存</span><br><span class="line">        redisCacheManager.setPrincipalIdFieldName(&quot;username&quot;);</span><br><span class="line">        //用户权限信息缓存时间</span><br><span class="line">        redisCacheManager.setExpire(200000);</span><br><span class="line">        return redisCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 让某个实例的某个方法的返回值注入为Bean的实例</span><br><span class="line">     * Spring静态注入</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public MethodInvokingFactoryBean getMethodInvokingFactoryBean() &#123;</span><br><span class="line">        MethodInvokingFactoryBean factoryBean = new MethodInvokingFactoryBean();</span><br><span class="line">        factoryBean.setStaticMethod(&quot;org.apache.shiro.SecurityUtils.setSecurityManager&quot;);</span><br><span class="line">        factoryBean.setArguments(new Object[]&#123;securityManager()&#125;);</span><br><span class="line">        return factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置session监听</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean(&quot;sessionListener&quot;)</span><br><span class="line">    public ShiroSessionListener sessionListener() &#123;</span><br><span class="line">        ShiroSessionListener sessionListener = new ShiroSessionListener();</span><br><span class="line">        return sessionListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置会话ID生成器</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public SessionIdGenerator sessionIdGenerator() &#123;</span><br><span class="line">        return new JavaUuidSessionIdGenerator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisManager redisManager() &#123;</span><br><span class="line">        RedisManager redisManager = new RedisManager();</span><br><span class="line">        return redisManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;sessionFactory&quot;)</span><br><span class="line">    public ShiroSessionFactory sessionFactory() &#123;</span><br><span class="line">        ShiroSessionFactory sessionFactory = new ShiroSessionFactory();</span><br><span class="line">        return sessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * SessionDAO的作用是为Session提供CRUD并进行持久化的一个shiro组件</span><br><span class="line">     * MemorySessionDAO 直接在内存中进行会话维护</span><br><span class="line">     * EnterpriseCacheSessionDAO  提供了缓存功能的会话维护，默认情况下使用MapCache实现，内部使用ConcurrentHashMap保存缓存的会话。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public SessionDAO sessionDAO() &#123;</span><br><span class="line">        RedisSessionDAO redisSessionDAO = new RedisSessionDAO();</span><br><span class="line">        redisSessionDAO.setRedisManager(redisManager());</span><br><span class="line">        redisSessionDAO.setSessionIdGenerator(sessionIdGenerator());</span><br><span class="line">        //session在redis中的保存时间,最好大于session会话超时时间</span><br><span class="line">        redisSessionDAO.setExpire(12000);</span><br><span class="line">        return redisSessionDAO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置会话管理器，设定会话超时及保存</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean(&quot;sessionManager&quot;)</span><br><span class="line">    public SessionManager sessionManager() &#123;</span><br><span class="line">        ShiroSessionManager sessionManager = new ShiroSessionManager();</span><br><span class="line">        Collection&lt;SessionListener&gt; listeners = new ArrayList&lt;SessionListener&gt;();</span><br><span class="line">        //配置监听</span><br><span class="line">        listeners.add(sessionListener());</span><br><span class="line">        sessionManager.setSessionListeners(listeners);</span><br><span class="line">//        sessionManager.setSessionIdCookie(sessionIdCookie());</span><br><span class="line">        sessionManager.setSessionDAO(sessionDAO());</span><br><span class="line">        sessionManager.setCacheManager(redisCacheManager());</span><br><span class="line">        sessionManager.setSessionFactory(sessionFactory());</span><br><span class="line">        //全局会话超时时间（单位毫秒），默认30分钟  暂时设置为10秒钟 用来测试</span><br><span class="line">        sessionManager.setGlobalSessionTimeout(1800000);</span><br><span class="line">        //是否开启删除无效的session对象  默认为true</span><br><span class="line">        sessionManager.setDeleteInvalidSessions(true);</span><br><span class="line">        //是否开启定时调度器进行检测过期session 默认为true</span><br><span class="line">        sessionManager.setSessionValidationSchedulerEnabled(true);</span><br><span class="line">        //设置session失效的扫描时间, 清理用户直接关闭浏览器造成的孤立会话 默认为 1个小时</span><br><span class="line">        //设置该属性 就不需要设置 ExecutorServiceSessionValidationScheduler 底层也是默认自动调用ExecutorServiceSessionValidationScheduler</span><br><span class="line">        //暂时设置为 5秒 用来测试</span><br><span class="line">        sessionManager.setSessionValidationInterval(3600000);</span><br><span class="line">        //取消url 后面的 JSESSIONID</span><br><span class="line">        sessionManager.setSessionIdUrlRewritingEnabled(false);</span><br><span class="line">        return sessionManager;</span><br><span class="line">    &#125;</span><br><span class="line">//    /**</span><br><span class="line">//     * 并发登录控制</span><br><span class="line">//     * @return</span><br><span class="line">//     */</span><br><span class="line">//    @Bean</span><br><span class="line">//    public KickoutSessionControlFilter kickoutSessionControlFilter()&#123;</span><br><span class="line">//        KickoutSessionControlFilter kickoutSessionControlFilter = new KickoutSessionControlFilter();</span><br><span class="line">//        //用于根据会话ID，获取会话进行踢出操作的；</span><br><span class="line">//        kickoutSessionControlFilter.setSessionManager(sessionManager());</span><br><span class="line">//        //使用cacheManager获取相应的cache来缓存用户登录的会话；用于保存用户—会话之间的关系的；</span><br><span class="line">//        kickoutSessionControlFilter.setRedisManager(redisManager());</span><br><span class="line">//        //是否踢出后来登录的，默认是false；即后者登录的用户踢出前者登录的用户；</span><br><span class="line">//        kickoutSessionControlFilter.setKickoutAfter(false);</span><br><span class="line">//        //同一个用户最大的会话数，默认1；比如2的意思是同一个用户允许最多同时两个人登录；</span><br><span class="line">//        kickoutSessionControlFilter.setMaxSession(1);</span><br><span class="line">//        //被踢出后重定向到的地址；</span><br><span class="line">////        kickoutSessionControlFilter.setKickoutUrl(&quot;/login?kickout=1&quot;);</span><br><span class="line">//        return kickoutSessionControlFilter;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置密码比较器</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean(&quot;credentialsMatcher&quot;)</span><br><span class="line">    public RetryLimitHashedCredentialsMatcher retryLimitHashedCredentialsMatcher()&#123;</span><br><span class="line">        RetryLimitHashedCredentialsMatcher retryLimitHashedCredentialsMatcher = new RetryLimitHashedCredentialsMatcher();</span><br><span class="line">        retryLimitHashedCredentialsMatcher.setRedisManager(redisManager());</span><br><span class="line">        //如果密码加密,可以打开下面配置</span><br><span class="line">        //加密算法的名称</span><br><span class="line">        //retryLimitHashedCredentialsMatcher.setHashAlgorithmName(&quot;MD5&quot;);</span><br><span class="line">        //配置加密的次数</span><br><span class="line">        //retryLimitHashedCredentialsMatcher.setHashIterations(1024);</span><br><span class="line">        //是否存储为16进制</span><br><span class="line">        //retryLimitHashedCredentialsMatcher.setStoredCredentialsHexEncoded(true);</span><br><span class="line">        return retryLimitHashedCredentialsMatcher;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ShiroRealm"><a href="#ShiroRealm" class="headerlink" title="ShiroRealm"></a><strong>ShiroRealm</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.panghu.shiro;</span><br><span class="line"></span><br><span class="line">import com.panghu.dao.SysUserDao;</span><br><span class="line">import com.panghu.entity.SysRole;</span><br><span class="line">import com.panghu.entity.SysUser;</span><br><span class="line">import com.panghu.global.MyByteSource;</span><br><span class="line">import org.apache.shiro.authc.AuthenticationInfo;</span><br><span class="line">import org.apache.shiro.authc.AuthenticationToken;</span><br><span class="line">import org.apache.shiro.authc.SimpleAuthenticationInfo;</span><br><span class="line">import org.apache.shiro.authz.AuthorizationInfo;</span><br><span class="line">import org.apache.shiro.authz.SimpleAuthorizationInfo;</span><br><span class="line">import org.apache.shiro.realm.AuthorizingRealm;</span><br><span class="line">import org.apache.shiro.subject.PrincipalCollection;</span><br><span class="line">import org.apache.shiro.util.ByteSource;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: nacos_base4j</span><br><span class="line"> * @Package: com.panghu</span><br><span class="line"> * @ClassName: MyShiroRealm</span><br><span class="line"> * @Author: wxy</span><br><span class="line"> * @Description: 拦截实现</span><br><span class="line"> * @Date: 2020/5/5 14:23</span><br><span class="line"> * @Version: 1.0</span><br><span class="line"> */</span><br><span class="line">public class ShiroRealm extends AuthorizingRealm &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SysUserDao userDao;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @Description: 用户权限配置</span><br><span class="line">     * @Param: [principals]</span><br><span class="line">     * @return: org.apache.shiro.authz.AuthorizationInfo</span><br><span class="line">     * @Author: Mr.Wei</span><br><span class="line">     * @Date: 2020/5/19</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;</span><br><span class="line">        System.out.println(&quot;权限调用方法开始&quot;);</span><br><span class="line">        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();</span><br><span class="line">        SysUser userInfo = (SysUser) principals.getPrimaryPrincipal();</span><br><span class="line">        for (SysRole role : userInfo.getRoles()) &#123;</span><br><span class="line">            authorizationInfo.addRoles(new ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">            authorizationInfo.addStringPermission(&quot;321&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return authorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @Description: 身份验证</span><br><span class="line">     * @Param: [token]</span><br><span class="line">     * @return: org.apache.shiro.authc.AuthenticationInfo</span><br><span class="line">     * @Author: Mr.Wei</span><br><span class="line">     * @Date: 2020/5/5</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) &#123;</span><br><span class="line">        System.out.println(&quot;MyShiroRealm.doGetAuthenticationInfo()&quot;);</span><br><span class="line"></span><br><span class="line">        // 获取用户的输入的账号.</span><br><span class="line">        String name = (String) token.getPrincipal();</span><br><span class="line">        System.out.println(token.getCredentials());</span><br><span class="line"></span><br><span class="line">        // 通过name和password从数据库中查找 User对象，</span><br><span class="line">        SysUser userInfo = userDao.findByAccount(name);</span><br><span class="line">        if (userInfo == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String uid = userInfo.getId();</span><br><span class="line">//        List&lt;Role&gt; roles = userService.getRoles(uid);</span><br><span class="line">//        int roleId = roles.get(0).getId();</span><br><span class="line">//        List&lt;Permission&gt; permissions = userService.getPermissions(roleId);</span><br><span class="line">//        roles.get(0).setPermissions(permissions);</span><br><span class="line">//        userInfo.setRoleList(roles);</span><br><span class="line">        // 加密方式;</span><br><span class="line">        // 交给AuthenticatingRealm使用CredentialsMatcher进行密码匹配</span><br><span class="line">        String password = userInfo.getPassword();</span><br><span class="line">        // 秘钥</span><br><span class="line">        ByteSource salt = ByteSource.Util.bytes(userInfo.getAccount());</span><br><span class="line">        // 当前域的名称（MyShiroRealm）</span><br><span class="line">        String realmName = getName();</span><br><span class="line">        // 认证信息</span><br><span class="line">//        SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(userInfo.getAccount(), password, salt, realmName);</span><br><span class="line">        SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(userInfo, userInfo.getPassword(), new MyByteSource(userInfo.getUserName()), getName());</span><br><span class="line"></span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ShiroSession"><a href="#ShiroSession" class="headerlink" title="ShiroSession"></a>ShiroSession</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.panghu.shiro;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.session.InvalidSessionException;</span><br><span class="line">import org.apache.shiro.session.mgt.SimpleSession;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: nacos_base4j</span><br><span class="line"> * @Package: com.panghu.shiro</span><br><span class="line"> * @ClassName: ShiroSession</span><br><span class="line"> * @Author: wxy</span><br><span class="line"> * @Description: session 由于SimpleSession lastAccessTime更改后也会调用SessionDao update方法，</span><br><span class="line"> * 增加标识位，如果只是更新lastAccessTime SessionDao update方法直接返回</span><br><span class="line"> * @Date: 2020/5/19 10:39</span><br><span class="line"> * @Version: 1.0</span><br><span class="line"> */</span><br><span class="line">public class ShiroSession extends SimpleSession implements Serializable &#123;</span><br><span class="line">    // 除lastAccessTime以外其他字段发生改变时为true</span><br><span class="line">    private boolean isChanged = false;</span><br><span class="line"></span><br><span class="line">//    private String id = &quot;init&quot;;</span><br><span class="line"></span><br><span class="line">    public ShiroSession() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.setChanged(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ShiroSession(String host) &#123;</span><br><span class="line">        super(host);</span><br><span class="line">        this.setChanged(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setId(Serializable id) &#123;</span><br><span class="line">        super.setId(id);</span><br><span class="line">        this.setChanged(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setStopTimestamp(Date stopTimestamp) &#123;</span><br><span class="line">        super.setStopTimestamp(stopTimestamp);</span><br><span class="line">        this.setChanged(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setExpired(boolean expired) &#123;</span><br><span class="line">        super.setExpired(expired);</span><br><span class="line">        this.setChanged(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setTimeout(long timeout) &#123;</span><br><span class="line">        super.setTimeout(timeout);</span><br><span class="line">        this.setChanged(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setHost(String host) &#123;</span><br><span class="line">        super.setHost(host);</span><br><span class="line">        this.setChanged(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setAttributes(Map&lt;Object, Object&gt; attributes) &#123;</span><br><span class="line">        super.setAttributes(attributes);</span><br><span class="line">        this.setChanged(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setAttribute(Object key, Object value) &#123;</span><br><span class="line">        super.setAttribute(key, value);</span><br><span class="line">        this.setChanged(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object removeAttribute(Object key) &#123;</span><br><span class="line">        this.setChanged(true);</span><br><span class="line">        return super.removeAttribute(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 停止</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        super.stop();</span><br><span class="line">        this.setChanged(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置过期</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void expire() &#123;</span><br><span class="line">        this.stop();</span><br><span class="line">        this.setExpired(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isChanged() &#123;</span><br><span class="line">        return isChanged;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setChanged(boolean isChanged) &#123;</span><br><span class="line">        this.isChanged = isChanged;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object obj) &#123;</span><br><span class="line">        return super.equals(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean onEquals(SimpleSession ss) &#123;</span><br><span class="line">        return super.onEquals(ss);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return super.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return super.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Serializable getId() &#123;</span><br><span class="line">        return super.getId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Date getStartTimestamp() &#123;</span><br><span class="line">        return super.getStartTimestamp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setStartTimestamp(Date startTimestamp) &#123;</span><br><span class="line">        super.setStartTimestamp(startTimestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Date getStopTimestamp() &#123;</span><br><span class="line">        return super.getStopTimestamp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Date getLastAccessTime() &#123;</span><br><span class="line">        return super.getLastAccessTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setLastAccessTime(Date lastAccessTime) &#123;</span><br><span class="line">        super.setLastAccessTime(lastAccessTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isExpired() &#123;</span><br><span class="line">        return super.isExpired();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long getTimeout() &#123;</span><br><span class="line">        return super.getTimeout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getHost() &#123;</span><br><span class="line">        return super.getHost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Map&lt;Object, Object&gt; getAttributes() &#123;</span><br><span class="line">        return super.getAttributes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void touch() &#123;</span><br><span class="line">        super.touch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean isStopped() &#123;</span><br><span class="line">        return super.isStopped();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isValid() &#123;</span><br><span class="line">        return super.isValid();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean isTimedOut() &#123;</span><br><span class="line">        return super.isTimedOut();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void validate() throws InvalidSessionException &#123;</span><br><span class="line">        super.validate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Collection&lt;Object&gt; getAttributeKeys() throws InvalidSessionException &#123;</span><br><span class="line">        return super.getAttributeKeys();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object getAttribute(Object key) &#123;</span><br><span class="line">        return super.getAttribute(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ShiroSessionFactory"><a href="#ShiroSessionFactory" class="headerlink" title="ShiroSessionFactory"></a>ShiroSessionFactory</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.panghu.shiro;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.lang3.StringUtils;</span><br><span class="line">import org.apache.shiro.session.Session;</span><br><span class="line">import org.apache.shiro.session.mgt.SessionContext;</span><br><span class="line">import org.apache.shiro.session.mgt.SessionFactory;</span><br><span class="line">import org.apache.shiro.web.session.mgt.DefaultWebSessionContext;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: nacos_base4j</span><br><span class="line"> * @Package: com.panghu.shiro</span><br><span class="line"> * @ClassName: ShiroSessionFactory</span><br><span class="line"> * @Author: wxy</span><br><span class="line"> * @Description: sessionFactory</span><br><span class="line"> * @Date: 2020/5/19 17:03</span><br><span class="line"> * @Version: 1.0</span><br><span class="line"> */</span><br><span class="line">public class ShiroSessionFactory implements SessionFactory &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(ShiroSessionFactory.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Session createSession(SessionContext initData) &#123;</span><br><span class="line">        ShiroSession session = new ShiroSession();</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest)initData.get(DefaultWebSessionContext.class.getName() + &quot;.SERVLET_REQUEST&quot;);</span><br><span class="line">        session.setHost(getIpAddress(request));</span><br><span class="line">        return session;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getIpAddress(HttpServletRequest request) &#123;</span><br><span class="line">        String localIP = &quot;127.0.0.1&quot;;</span><br><span class="line">        String ip = request.getHeader(&quot;x-forwarded-for&quot;);</span><br><span class="line">        if (StringUtils.isBlank(ip) || (ip.equalsIgnoreCase(localIP)) || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (StringUtils.isBlank(ip) || (ip.equalsIgnoreCase(localIP)) || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (StringUtils.isBlank(ip) || (ip.equalsIgnoreCase(localIP)) || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line">        return ip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ShiroSessionListener"><a href="#ShiroSessionListener" class="headerlink" title="ShiroSessionListener"></a>ShiroSessionListener</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: nacos_base4j</span><br><span class="line"> * @Package: com.panghu.shiro</span><br><span class="line"> * @ClassName: ShiroSessionListener</span><br><span class="line"> * @Author: wxy</span><br><span class="line"> * @Description: 在线人数监听</span><br><span class="line"> * @Date: 2020/5/19 16:57</span><br><span class="line"> * @Version: 1.0</span><br><span class="line"> */</span><br><span class="line">public class ShiroSessionListener implements SessionListener &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 统计在线人数</span><br><span class="line">     * juc包下线程安全自增</span><br><span class="line">     */</span><br><span class="line">    private final AtomicInteger sessionCount = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 会话创建时触发</span><br><span class="line">     *</span><br><span class="line">     * @param session</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void onStart(Session session) &#123;</span><br><span class="line">        //会话创建，在线人数加一</span><br><span class="line">        sessionCount.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 退出会话时触发</span><br><span class="line">     *</span><br><span class="line">     * @param session</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void onStop(Session session) &#123;</span><br><span class="line">        //会话退出,在线人数减一</span><br><span class="line">        sessionCount.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 会话过期时触发</span><br><span class="line">     *</span><br><span class="line">     * @param session</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void onExpiration(Session session) &#123;</span><br><span class="line">        //会话过期,在线人数减一</span><br><span class="line">        sessionCount.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取在线人数使用</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public AtomicInteger getSessionCount() &#123;</span><br><span class="line">        return sessionCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ShiroSessionManager"><a href="#ShiroSessionManager" class="headerlink" title="ShiroSessionManager"></a>ShiroSessionManager</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.panghu.shiro;</span><br><span class="line"></span><br><span class="line">import com.panghu.reids.RedisSessionDAO;</span><br><span class="line">import org.apache.shiro.session.Session;</span><br><span class="line">import org.apache.shiro.session.UnknownSessionException;</span><br><span class="line">import org.apache.shiro.session.mgt.SessionKey;</span><br><span class="line">import org.apache.shiro.session.mgt.eis.SessionDAO;</span><br><span class="line">import org.apache.shiro.web.session.mgt.DefaultWebSessionManager;</span><br><span class="line">import org.apache.shiro.web.session.mgt.WebSessionKey;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: nacos_base4j</span><br><span class="line"> * @Package: com.panghu.shiro</span><br><span class="line"> * @ClassName: ShiroSessionManager</span><br><span class="line"> * @Author: wxy</span><br><span class="line"> * @Description: session管理</span><br><span class="line"> * @Date: 2020/5/19 17:01</span><br><span class="line"> * @Version: 1.0</span><br><span class="line"> */</span><br><span class="line">public class ShiroSessionManager extends DefaultWebSessionManager &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(DefaultWebSessionManager.class);</span><br><span class="line">    /**</span><br><span class="line">     * 获取session</span><br><span class="line">     * 优化单次请求需要多次访问redis的问题</span><br><span class="line">     * @param sessionKey</span><br><span class="line">     * @return</span><br><span class="line">             * @throws UnknownSessionException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected Session retrieveSession(SessionKey sessionKey) throws UnknownSessionException &#123;</span><br><span class="line">        Serializable sessionId = getSessionId(sessionKey);</span><br><span class="line"></span><br><span class="line">        ServletRequest request = null;</span><br><span class="line">        if (sessionKey instanceof WebSessionKey) &#123;</span><br><span class="line">            request = ((WebSessionKey) sessionKey).getServletRequest();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (request != null &amp;&amp; null != sessionId) &#123;</span><br><span class="line">            Object sessionObj = request.getAttribute(sessionId.toString());</span><br><span class="line">            if (sessionObj != null) &#123;</span><br><span class="line">                logger.debug(&quot;read session from request&quot;);</span><br><span class="line">                return (Session) sessionObj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Session session = super.retrieveSession(sessionKey);</span><br><span class="line">        if (request != null &amp;&amp; null != sessionId) &#123;</span><br><span class="line">            request.setAttribute(sessionId.toString(), session);</span><br><span class="line">        &#125;</span><br><span class="line">        return session;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring cloud alibaba</category>
      </categories>
      <tags>
        <tag>spring cloud alibaba</tag>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2019/04/15/test/</url>
    <content><![CDATA[<p><img src="/2019/04/15/test/five.jpg" alt><br><img src="/2019/04/15/test/moon.jpg" alt></p>
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>npm</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized解析</title>
    <url>/2019/04/26/synchronized%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="synchronized的底层实现原理"><a href="#synchronized的底层实现原理" class="headerlink" title="synchronized的底层实现原理"></a>synchronized的底层实现原理</h1><p>Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现， 无论是显式同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。在 Java 语言中，同步用的最多的地方可能是被 synchronized 修饰的同步方法。</p>
<h2 id="synchronized-的主要作用"><a href="#synchronized-的主要作用" class="headerlink" title="synchronized 的主要作用"></a>synchronized 的主要作用</h2><p>1、保证线程间互斥的同步访问。</p>
<p>2、保证共享变量的可见性。</p>
<p>3、jvm层面实现加锁（Lock）与解锁(unLock),</p>
<p>synchronized常用的三用加锁方式分别是</p>
<p>一. 修饰实例方法，作用于当前实例加锁，对象锁。</p>
<p>二. 修饰静态方法，作用于当前类对象加锁，类锁。</p>
<p>三. 修饰代码块，指定加锁对象，对给定对象加锁，对象锁。</p>
<p>synchronized同步块使用了monitorenter和monitorexit指令实现同步，这两个指令，本质上都是对一个对象的监视器(monitor)进行获取，这个过程是排他的，也就是说同一时刻只能有一个线程获取到由synchronized所保护对象的监视器。线程执行到monitorenter指令时，会尝试获取对象所对应的monitor所有权，也就是尝试获取对象的锁，而执行monitorexit，就是释放monitor的所有权。</p>
<h2 id="synchronized的锁的原理"><a href="#synchronized的锁的原理" class="headerlink" title="synchronized的锁的原理"></a>synchronized的锁的原理</h2><p>synchronized使用的锁对象是存储在Java对象头，它是轻量级锁和偏向锁的关键。</p>
<p>Mark Word<br>Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的<br>锁、偏向线程 ID、偏向时间戳等等。Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，<br>也就是32bit）。</p>
<p><img src="/2019/04/26/synchronized解析/E:/blog\source\_posts\synchronized解析\markdown.png" alt></p>
<p>Class Metadata Address<br>类型指针，即是对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p>jdk1.6以后对synchronized的锁进行了优化，引入了偏向锁、轻量级锁，锁的级别从低到高逐步升级：</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>线程的挂起和恢复会极大的影响开销。并且jdk官方人员发现，很多线程在等待锁的时候，在很短的一段时间就获得了锁，所以它们在线程等待的时候，并不需要把线程挂起，而是让他无目的的循环，一般设置10次。这样就避免了线程切换的开销，极大的提升了性能。</p>
<h3 id="偏向锁："><a href="#偏向锁：" class="headerlink" title="偏向锁："></a>偏向锁：</h3><p>多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让其获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>引入轻量级锁的主要目的是在多线程竞争不激烈的情况下，通过CAS竞争锁，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p>
<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><p>由于ReentrantLock是java.util.concurrent包下面提供的一套互斥锁，相比Synchronized类提供了一些高级的功能。</p>
<p>1、 等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。通过lock.lockInterruptibly()来实现这个机制。</p>
<p>2、公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数也是非公平锁，可以通过参数true设为公平锁，获取锁的顺序按请求的顺序。</p>
<p>3、多条件绑定、ReentrantLock提供了Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</p>
<p>ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。</p>
<p>Condition中的await()方法相当于Object的wait()方法，Condition中的signal()方法相当于Object的notify()方法，Condition中的signalAll()相当于Object的notifyAll()方法。<br>不同的是，Object中的这些方法是和同步锁捆绑使用的；而Condition是需要与互斥锁/共享锁捆绑使用的。</p>
<p>Condition它更强大的地方在于：能够更加精细的控制多线程的休眠与唤醒。对于同一个锁，我们可以创建多个Condition，在不同的情况下使用不同的Condition。</p>
<p>例如下方的唤醒不同Condition的示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    static class NumberWrapper &#123;</span><br><span class="line">        public int value = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        //初始化可重入锁</span><br><span class="line">        final Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">        //第一个条件当屏幕上输出到3</span><br><span class="line">        final Condition reachThreeCondition = lock.newCondition();</span><br><span class="line">        //第二个条件当屏幕上输出到6</span><br><span class="line">        final Condition reachSixCondition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        //NumberWrapper只是为了封装一个数字，一边可以将数字对象共享，并可以设置为final</span><br><span class="line">        //注意这里不要用Integer, Integer 是不可变对象</span><br><span class="line">        final NumberWrapper num = new NumberWrapper();</span><br><span class="line">        //初始化A线程</span><br><span class="line">        Thread threadA = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                //需要先获得锁</span><br><span class="line">                lock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;threadA start write&quot;);</span><br><span class="line">                    //A线程先输出前3个数</span><br><span class="line">                    while (num.value &lt;= 3) &#123;</span><br><span class="line">                        System.out.println(num.value);</span><br><span class="line">                        num.value++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //输出到3时要signal，告诉B线程可以开始了</span><br><span class="line">                    reachThreeCondition.signal();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                lock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    //等待输出6的条件</span><br><span class="line">                    reachSixCondition.await();</span><br><span class="line">                    System.out.println(&quot;threadA start write&quot;);</span><br><span class="line">                    //输出剩余数字</span><br><span class="line">                    while (num.value &lt;= 9) &#123;</span><br><span class="line">                        System.out.println(num.value);</span><br><span class="line">                        num.value++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread threadB = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line"></span><br><span class="line">                    while (num.value &lt;= 3) &#123;</span><br><span class="line">                        //等待3输出完毕的信号</span><br><span class="line">                        reachThreeCondition.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    //已经收到信号，开始输出4，5，6</span><br><span class="line">                    System.out.println(&quot;threadB start write&quot;);</span><br><span class="line">                    while (num.value &lt;= 6) &#123;</span><br><span class="line">                        System.out.println(num.value);</span><br><span class="line">                        num.value++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //4，5，6输出完毕，告诉A线程6输出完了</span><br><span class="line">                    reachSixCondition.signal();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        //启动两个线程</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java线程锁</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper集群</title>
    <url>/2020/07/11/zookeeper%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h1 id="zookeeper概述"><a href="#zookeeper概述" class="headerlink" title="zookeeper概述"></a>zookeeper概述</h1><p>Zookeeper 是一个分布式协调服务的开源框架。 主要用来解决分布式集群中应用系统的一致性问题，例如怎样避免同时操作同一数据造成脏读的问题。<br>ZooKeeper 本质上是一个分布式的小文件存储系统。 提供基于类似于文件系统的目录树方式的数据存储，并且可以对树中的节点进行有效管理。从而用来维护和监控你存储的数据的状态变化。通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。 诸如： 统一命名服务(dubbo)、分布式配置管理(solr的配置集中管理)、分布式消息队列（sub/pub）、分布式锁、分布式协调等功能。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>​    1.全局数据一致：每个 server 保存一份相同的数据副本， client 无论连<br>接到哪个 server，展示的数据都是一致的，这是最重要的特征；</p>
<ol start="2">
<li>可靠性：如果消息被其中一台服务器接受，那么将被所有的服务器接受。</li>
<li>顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上<br>消息 a 在消息 b 前发布，则在所有 Server 上消息 a 都将在消息 b 前被<br>发布；偏序是指如果一个消息 b 在消息 a 后被同一个发送者发布， a 必<br>将排在 b 前面。</li>
<li>数据更新原子性：一次数据更新要么成功（半数以上节点成功），要么失<br>败，不存在中间状态；</li>
<li>实时性： Zookeeper 保证客户端将在一个时间间隔范围内获得服务器的<br>更新信息，或者服务器失效的信息。</li>
</ol>
<h1 id="安装Zookeeper"><a href="#安装Zookeeper" class="headerlink" title="安装Zookeeper"></a>安装Zookeeper</h1><p>下载最新的zookeeper，我安装的是  zookeeper-3.4.12.tar.gz</p>
<p>链接：<a href="https://pan.baidu.com/s/1wr-iFQno65sukzrWPXU_Sg" target="_blank" rel="noopener">https://pan.baidu.com/s/1wr-iFQno65sukzrWPXU_Sg</a><br>提取码：ykyz </p>
<p>解压到对应的服务器目录。我这里要做做伪集群，所以在一个服务器中创建了三个目录</p>
<p><img src="/2020/07/11/zookeeper集群/path.png" alt="path"></p>
<p>在每个安装解压的conf目录下修改zoo.cfg</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*更改解压的文件下面没有zoo.cfg文件，但是有zoo_sample.cfg文件*</span><br><span class="line">cp zoo_sample.cfg zoo.cfg（这是复制一份新的，原文件保留）</span><br><span class="line">mv zoo_sample.cfg zoo.cfg（这是直接将原文件改名）</span><br></pre></td></tr></table></figure>
<p>下面只复制了第一个zookeeper的配置，第二个第三个复制操作，就不赘述</p>
<h2 id="1-修改对应的conf下配置文件的内容"><a href="#1-修改对应的conf下配置文件的内容" class="headerlink" title="1.修改对应的conf下配置文件的内容"></a>1.修改对应的conf下配置文件的内容</h2><p>vim /usr/local/application/zookeeper/zookeeper-1/conf/zoo.cfg</p>
<p><em><code>cp zoo_sample.cfg zoo.cfg（这是复制一份新的，原文件保留）</code></em><br><em><code>mv zoo_sample.cfg zoo.cfg（这是直接将原文件改名）</code></em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//修改配置文件</span><br><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">dataDir=/usr/local/application/zookeeper/tmp/zookeeper-1/data</span><br><span class="line">dataLogDir=/usr/local/application/zookeeper/tmp/zookeeper-1/log</span><br><span class="line">//端口，根据实际情况自行修改</span><br><span class="line">clientPort=5601</span><br><span class="line">//服务器IP	主机名	myid的值</span><br><span class="line">server.1=localhost:2287:3387</span><br><span class="line">server.2=localhost:2288:3388</span><br><span class="line">server.3=localhost:2289:3389</span><br></pre></td></tr></table></figure>
<h2 id="2-指定文件的存储位置"><a href="#2-指定文件的存储位置" class="headerlink" title="2.指定文件的存储位置"></a>2.指定文件的存储位置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/local/application/zookeeper/tmp</span><br><span class="line">mkdir -p /usr/local/application/zookeeper/tmp/zookeeper-1</span><br><span class="line">mkdir -p /usr/local/application/zookeeper/tmp/zookeeper-1/data</span><br></pre></td></tr></table></figure>
<h2 id="3-修改log4j-properties配置"><a href="#3-修改log4j-properties配置" class="headerlink" title="3.修改log4j.properties配置"></a>3.修改log4j.properties配置</h2><p>修改日志的配置文件</p>
<p>vim /usr/local/application/zookeeper/zookeeper-1/conf/log4j.properties</p>
<p>只修改两行（文件夹需要自己创建）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zookeeper.log.dir=./usr/local/application/zookeeper/tmp/logs/zookeeper-1</span><br><span class="line">zookeeper.tracelog.dir=./usr/local/application/zookeeper/tmp/logs//zookeeper-1</span><br></pre></td></tr></table></figure>
<h2 id="4-在zoo-cfg文件中的dataDir参数下创建myid文件"><a href="#4-在zoo-cfg文件中的dataDir参数下创建myid文件" class="headerlink" title="4.在zoo.cfg文件中的dataDir参数下创建myid文件"></a>4.在zoo.cfg文件中的dataDir参数下创建myid文件</h2><p>touch /usr/local/application/zookeeper/tmp/zookeeper-1/data/myid</p>
<p>修改其中的内容为1，对应server.1中的1</p>
<h2 id="5-启动zookeeper"><a href="#5-启动zookeeper" class="headerlink" title="5.启动zookeeper"></a>5.启动zookeeper</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#切换到对应的bin目录下</span><br><span class="line">/usr/local/application/zookeeper/zookeeper-1/bin</span><br><span class="line">#查看zookeeper的状态</span><br><span class="line">./zkServer.sh status</span><br><span class="line">#启动</span><br><span class="line">./zkServer.sh start</span><br><span class="line">#关闭</span><br><span class="line">./zkServer.sh stop</span><br></pre></td></tr></table></figure>
<h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><p><img src="/2020/07/11/zookeeper集群/jps.png" alt="jps"></p>
<p>到这里，单服务器上的伪分布式已完成</p>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper sesssion机制</title>
    <url>/2020/07/13/zookeeper-sesssion%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="会话机制session"><a href="#会话机制session" class="headerlink" title="会话机制session"></a>会话机制session</h1><p><img src="/2020/07/13/zookeeper-sesssion机制/E:/blog\source\_posts\zookeeper-sesssion机制\session.png" alt></p>
<p>ZooKeeper的架构图，client跟ZooKeeper集群中的某一台server保持连接，发送读/写请求，读请求直接由当前连接的server处理，写请求由于是事务请求，由当前server转发给leader进行处理。同时，client还能接收来自server端的watcher通知。<br>ZooKeeper对外的服务端口默认是2181，客户端启动时，首先会与服务器建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够通过心跳检测和服务器保持有效的会话，也能够向ZooKeeper服务器发送请求并接受响应，同时还能通过该连接接收来自服务器的Watch事件通知。Session的SessionTimeout值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在SessionTimeout规定的时间内能够重新连接上集群中任意一个那么之前创建的会话仍然有效。</p>
<p>短连接 ：连接-&gt;传输数据-&gt;关闭连接<br>也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。</p>
<p>长连接：连接-&gt;传输数据-&gt;保持连接 -&gt; 传输数据-&gt; 。。。 -&gt;关闭连接。<br>长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。</p>
<p>网络中不同节点使用TCP协议通过SOCKET进行通信，首先需要3次握手建立连接，数据传输，4次握手断开连接，因此如果频繁的创建、关闭，是很耗费系统资源的，就像短连接那样；使用长连接貌似弥补了短连接的缺点，但是，如果并发量过大，会有大量的长连接，同样会耗费大量系统资源，因此具体选用长连接还是短连接，是要根据具体的场景来选择。<br>ZooKeeper中一个client只会跟一个server进行交互(除非与当前server连接失败，会切换到下个server)，不管这种交互有多频繁，只需要一个TCP长连接就足以应对，因选择一个TCP长连接，不失为一种最好的方案。、</p>
<h1 id="会话Session的管理"><a href="#会话Session的管理" class="headerlink" title="会话Session的管理"></a>会话Session的管理</h1><p>首先了解3个基本概念：</p>
<p>sessionID：会话ID，用来唯一标识一个会话，每次客户端创建会话的时候，ZooKeeper都会为其分配一个全局唯一的sessionID<br>TimeOut：会话超时时间，如果客户端与服务器之间因为网络闪断导致断开连接，并在TimeOut时间内未连上其他server，则此次会话失效，此次会话创建的临时节点将被清理<br>ExpirationTime：下次会话超时时间点。ZooKeeper会为每个会话标记一个下次会话超时时间点，便于对会话进行“分桶管理”，同时也是为了搞笑低耗的实现会话的超时检查与清理。其值接近于当前时间+TimeOut，但不完全相等，稍后会介绍。</p>
<h2 id="1-sessionId的初始化"><a href="#1-sessionId的初始化" class="headerlink" title="1.sessionId的初始化"></a>1.sessionId的初始化</h2><p>在每次client向server发起“会话创建”请求时，服务端都会为其分配一个sessionID，现在看下sessionID是如何生成的。</p>
<p>在SessionTrackerImpl初始化的时候，会调用initializeNextSession来生成一个初始化的sessionID，之后在该sessionID的基础上为每个会话进行分配，其初始化算法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//是ZooKeeper服务器的会话管理器，负责会话的创建、管理和清理等工作</span><br><span class="line">public class SessionTrackerImpl extends Thread implements SessionTracker &#123;</span><br><span class="line">   </span><br><span class="line">    &#123;...&#125;</span><br><span class="line"></span><br><span class="line">	//参数id为当前服务器的myid</span><br><span class="line">    public static long initializeNextSession(long id) &#123;</span><br><span class="line">        long nextSid = 0;</span><br><span class="line">        //此处采用无符号右移，是为了防止出现负数的情况</span><br><span class="line">        nextSid = (System.currentTimeMillis() &lt;&lt; 24) &gt;&gt;&gt; 8;</span><br><span class="line">        nextSid =  nextSid | (id &lt;&lt;56);</span><br><span class="line">        return nextSid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>该逻辑计算后得到的sessionID的前8位确定了所在的机器，后56位使用当前时间的毫秒表示进行随机</strong></p>
<h2 id="2-分桶策略"><a href="#2-分桶策略" class="headerlink" title="2.分桶策略"></a>2.分桶策略</h2><p>SessionTrackerImpl通过<strong>“分桶策略”</strong>来进行会话的管理，分桶的原则是将每个会话的<strong>“下次超时时间点”(ExpirationTime)</strong>相同的会话放在同一区块中进行管理，以便于ZooKeeper对会话进行不同区块的隔离处理，以及同一区块的统一处理，</p>
<p><img src="/2020/07/13/zookeeper-sesssion机制/E:/blog\source\_posts\zookeeper-sesssion机制\sessionTimeout.png" alt="sessionTimeout"></p>
<p>每个会话创建完毕后，ZooKeeper就会为其计算ExpirationTime，计算方式大体如下：</p>
<p>ExpirationTime = CurrentTime(当前时间) + SessionTimeOut(会话超时时间)</p>
<h2 id="3-会话激活"><a href="#3-会话激活" class="headerlink" title="3.会话激活"></a>3.会话激活</h2><p>为了保持client会话的有效性，在ZooKeeper运行过程中，client会在会话超时时间过期范围内向server发送PING请求来保持会话的有效性，俗称“心跳检测”。同时server重新激活client对应的会话，这段逻辑是在SessionTrackerImpl的touchSession中实现的。先看下流程，再看源码：<br><img src="/2020/07/13/zookeeper-sesssion机制/E:/blog\source\_posts\zookeeper-sesssion机制\heartCheck.png" alt="heartCheck"></p>
<p>下面再展示激活sessionId的源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//sessionId为发起会话激活的client的sessionId，timeout为会话超时时间</span><br><span class="line">synchronized public boolean touchSession(long sessionId, int timeout) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * sessionsById的结构为 HashMap&lt;Long, SessionImpl&gt;()，每个sessionid都有一个对应的session实现</span><br><span class="line">         * 这里取出对应的session实现</span><br><span class="line">         */</span><br><span class="line">        SessionImpl s = sessionsById.get(sessionId);</span><br><span class="line">        // Return false, if the session doesn&apos;t exists or marked as closing</span><br><span class="line">        if (s == null || s.isClosing()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //计算当前会话的下一个失效时间，可以理解为ExpirationTime_New</span><br><span class="line">        long expireTime = roundToInterval(System.currentTimeMillis() + timeout);</span><br><span class="line">        //tickTime是上一次计算的超时时间，可以理解为ExpirationTime_Old</span><br><span class="line">        if (s.tickTime &gt;= expireTime) &#123;</span><br><span class="line">            // Nothing needs to be done</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        //将ExpirationTime_Old对应的桶中的会话取出，SessionSet 是SessionImpl的集合</span><br><span class="line">        SessionSet set = sessionSets.get(s.tickTime);</span><br><span class="line">        if (set != null) &#123;</span><br><span class="line">        	//将旧桶中的会话移除</span><br><span class="line">            set.sessions.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">        //更新当前会话的下一次超时时间</span><br><span class="line">        s.tickTime = expireTime;</span><br><span class="line">        //从新桶中取出该会话，无则创建，有则更新</span><br><span class="line">        set = sessionSets.get(s.tickTime);</span><br><span class="line">        if (set == null) &#123;</span><br><span class="line">            set = new SessionSet();</span><br><span class="line">            sessionSets.put(expireTime, set);</span><br><span class="line">        &#125;</span><br><span class="line">        set.sessions.add(s);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>那这个方法什么时候会被触发呢？</p>
<ol>
<li>只要client向server发送请求，包括读或写请求，就会触发一次激活；</li>
<li>如果client发现在sessionTimeOut / 3 时间内未尚和server进行任何通信，就会主动发起一次PING请求，进而触发激活；</li>
</ol>
<h1 id="watch触发机制"><a href="#watch触发机制" class="headerlink" title="watch触发机制"></a>watch触发机制</h1><p>zookeeper主要是为了统一分布式系统中各个节点的工作状态，在资源冲突的情况下协调提供节点资源抢占，提供给每个节点了解整个集群所处状态的途径。这一切的实现都依赖于zookeeper中的事件监听和通知机制。</p>
<h2 id="zookeeper中的事件和状态"><a href="#zookeeper中的事件和状态" class="headerlink" title="zookeeper中的事件和状态"></a>zookeeper中的事件和状态</h2><p>zookeeper客户端与zookeeper server连接的状态</p>
<table>
<thead>
<tr>
<th>连接状态</th>
<th>状态含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>KeeperState.Expired</td>
<td>客户端和服务器在ticktime的时间周期内，是要发送心跳通知的。这是租约协议的一个实现。客户端发送request，告诉服务器其上一个租约时间，服务器收到这个请求后，告诉客户端其下一个租约时间是哪个时间点。当客户端时间戳达到最后一个租约时间，而没有收到服务器发来的任何新租约时间，即认为自己下线（此后客户端会废弃这次连接，并试图重新建立连接）。这个过期状态就是Expired状态</td>
</tr>
<tr>
<td>KeeperState.Disconnected</td>
<td>就像上面那个状态所述，当客户端断开一个连接（可能是租约期满，也可能是客户端主动断开）这是客户端和服务器的连接就是Disconnected状态</td>
</tr>
<tr>
<td>KeeperState.SyncConnected</td>
<td>一旦客户端和服务器的某一个节点建立连接（注意，虽然集群有多个节点，但是客户端一次连接到一个节点就行了），并完成一次version、zxid的同步，这时的客户端和服务器的连接状态就是SyncConnected</td>
</tr>
<tr>
<td>KeeperState.AuthFailed</td>
<td>zookeeper客户端进行连接认证失败时，发生该状态</td>
</tr>
</tbody>
</table>
<p><em>需要说明的是，这些状态在触发时，所记录的事件类型都是：EventType.None</em></p>
<table>
<thead>
<tr>
<th>zookeeper事件</th>
<th>事件含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>EventType.NodeCreated</td>
<td>当node-x这个节点被创建时，该事件被触发</td>
</tr>
<tr>
<td>EventType.NodeChildrenChanged</td>
<td>当node-x这个节点的直接子节点被创建、被删除、子节点数据发生变更时，该事件被触发。</td>
</tr>
<tr>
<td>EventType.NodeDataChanged</td>
<td>当node-x这个节点的数据发生变更时，该事件被触发</td>
</tr>
<tr>
<td>EventType.NodeDeleted</td>
<td>当node-x这个节点被删除时，该事件被触发。</td>
</tr>
<tr>
<td>EventType.None</td>
<td>当zookeeper客户端的连接状态发生变更时，即KeeperState.Expired、KeeperState.Disconnected、KeeperState.SyncConnected、KeeperState.AuthFailed状态切换时，描述的事件类型为EventType.None</td>
</tr>
</tbody>
</table>
<h2 id="watch的特性"><a href="#watch的特性" class="headerlink" title="watch的特性"></a>watch的特性</h2><p>Znode发生变化（Znode本身的增加，删除，修改，以及子Znode的变化）可以通过Watch机制通知到客户端。那么要实现Watch，就必须实现org.apache.zookeeper.Watcher接口，并且将实现类的对象传入到可以Watch的方法中。Zookeeper中所有读操作（getData()，getChildren()，exists()）都可以设置Watch选项。Watch事件具有one-time trigger（一次性触发）的特性，如果Watch监视的Znode有变化，那么就会通知设置该Watch的客户端。</p>
<p>在上述说道的所有读操作中，如果需要Watcher，我们可以自定义Watcher，如果是Boolean型变量，当为true时，则使用系统默认的Watcher，系统默认的Watcher是在Zookeeper的构造函数中定义的Watcher。参数中Watcher为空或者false，表示不启用Wather。</p>
<h4 id="watch特性1：一次性触发器"><a href="#watch特性1：一次性触发器" class="headerlink" title="watch特性1：一次性触发器"></a>watch特性1：一次性触发器</h4><p>客户端在Znode设置了Watch时，如果Znode内容发生改变，那么客户端就会获得Watch事件。例如：客户端设置getData(“/znode1”, true)后，如果/znode1发生改变或者删除，那么客户端就会得到一个/znode1的Watch事件，但是/znode1再次发生变化，那客户端是无法收到Watch事件的，除非客户端设置了新的Watch。</p>
<h4 id="watch特性2：发送至客户端"><a href="#watch特性2：发送至客户端" class="headerlink" title="watch特性2：发送至客户端"></a>watch特性2：发送至客户端</h4><p>Watch事件是异步发送到Client。Zookeeper可以保证客户端发送过去的更新顺序是有序的。例如：某个Znode没有设置watcher，那么客户端对这个Znode设置Watcher发送到集群之前，该客户端是感知不到该Znode任何的改变情况的。换个角度来解释：由于Watch有一次性触发的特点，所以在服务器端没有Watcher的情况下，Znode的任何变更就不会通知到客户端。不过，即使某个Znode设置了Watcher，且在Znode有变化的情况下通知到了客户端，但是在客户端接收到这个变化事件，但是还没有再次设置Watcher之前，如果其他客户端对该Znode做了修改，这种情况下，Znode第二次的变化客户端是无法收到通知的。这可能是由于网络延迟或者是其他因素导致，所以我们使用Zookeeper不能期望能够监控到节点每次的变化。Zookeeper只能保证最终的一致性，而无法保证强一致性。</p>
<h4 id="watch特性3：设置watch的数据内容"><a href="#watch特性3：设置watch的数据内容" class="headerlink" title="watch特性3：设置watch的数据内容"></a>watch特性3：设置watch的数据内容</h4><p>Znode改变有很多种方式，例如：节点创建，节点删除，节点改变，子节点改变等等。Zookeeper维护了两个Watch列表，一个节点数据Watch列表，另一个是子节点Watch列表。getData()和exists()设置数据Watch，getChildren()设置子节点Watch。两者选其一，可以让我们根据不同的返回结果选择不同的Watch方式，getData()和exists()返回节点的内容，getChildren()返回子节点列表。因此，setData()触发内容Watch，create()触发当前节点的内容Watch或者是其父节点的子节点Watch。delete()同时触发父节点的子节点Watch和内容Watch，以及子节点的内容Watch。</p>
<h1 id="Watcher的运行机制"><a href="#Watcher的运行机制" class="headerlink" title="Watcher的运行机制"></a>Watcher的运行机制</h1><p>1，Watch是轻量级的，其实就是本地JVM的Callback，服务器端只是存了是否有设置了Watcher的布尔类型。（源码见：org.apache.zookeeper.server.FinalRequestProcessor）</p>
<p>2，在服务端，在FinalRequestProcessor处理对应的Znode操作时，会根据客户端传递的watcher变量，添加到对应的ZKDatabase（org.apache.zookeeper.server.ZKDatabase）中进行持久化存储，同时将自己NIOServerCnxn做为一个Watcher callback，监听服务端事件变化</p>
<p>3，Leader通过投票通过了某次Znode变化的请求后，然后通知对应的Follower，Follower根据自己内存中的zkDataBase信息，发送notification信息给zookeeper客户端。</p>
<p>4，Zookeeper客户端接收到notification信息后，找到对应变化path的watcher列表，挨个进行触发回调。</p>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/04/15/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉树简介"><a href="#二叉树简介" class="headerlink" title="二叉树简介"></a><strong>二叉树简介</strong></h1><p>　二叉树是由n（n&gt;=0）个结点组成的有序集合，集合或者为空，或者是由一个根节点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。</p>
<h3 id="二叉树的特性"><a href="#二叉树的特性" class="headerlink" title="二叉树的特性"></a>二叉树的特性</h3><p>A、在二叉树的第i层上最多有2^(i-1)个结点（i&gt;=1）。<br>B、高度为k的二叉树，最多有2^k-1个结点（k&gt;=0）。<br>C、对任何一棵二叉树，如果其叶结点有n个，度为2的非叶子结点有m个，则<br>n = m + 1。<br>D、具有n个结点的完全二叉树的高度为logn + 1<br>E、对于有n个结点的完全二叉树，按层次对结点进行编号（从上到下，从左到右）</p>
<h1 id="二叉树遍历方法"><a href="#二叉树遍历方法" class="headerlink" title="二叉树遍历方法"></a>二叉树遍历方法</h1><p>java中二叉树的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left, right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的构造方法"><a href="#二叉树的构造方法" class="headerlink" title="二叉树的构造方法"></a>二叉树的构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">constructTree</span><span class="params">(LinkedList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode rootNode = <span class="keyword">new</span> TreeNode(list.get(<span class="number">0</span>));<span class="comment">//根节点</span></span><br><span class="line">    LinkedList&lt;TreeNode&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">// 遍历节点</span></span><br><span class="line">    linkedList.add(rootNode);</span><br><span class="line">    list.removeFirst();</span><br><span class="line">    Boolean nodeFlag = <span class="keyword">false</span>; <span class="comment">//该节点是否完成</span></span><br><span class="line">    TreeNode tempNode = rootNode;</span><br><span class="line">    <span class="keyword">while</span> (!CollectionUtils.isEmpty(linkedList) &amp;&amp; !CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">"#"</span>.equals(list.get(<span class="number">0</span>))) &#123;</span><br><span class="line">            TreeNode node = <span class="keyword">new</span> TreeNode(list.get(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span> (!nodeFlag) &#123;</span><br><span class="line">                tempNode.left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tempNode.right = node;</span><br><span class="line">            &#125;</span><br><span class="line">            linkedList.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        list.removeFirst();</span><br><span class="line">        <span class="keyword">if</span> (nodeFlag) &#123;</span><br><span class="line">            linkedList.removeFirst();</span><br><span class="line">            tempNode = linkedList.getFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        nodeFlag = !nodeFlag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rootNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">path</span><span class="params">(TreeNode rootNode, List&lt;String&gt; beforePath)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!ObjectUtils.isEmpty(rootNode)) &#123;</span><br><span class="line">          beforePath.add(rootNode.val);</span><br><span class="line">          path(rootNode.left, beforePath);</span><br><span class="line">          path(rootNode.right, beforePath);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">beforePath</span><span class="params">(TreeNode rootNode)</span> </span>&#123;</span><br><span class="line">       LinkedList&lt;TreeNode&gt; nodeLinkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (ObjectUtils.isEmpty(rootNode)) &#123;</span><br><span class="line">           <span class="keyword">return</span> path;</span><br><span class="line">       &#125;</span><br><span class="line">       TreeNode temp = rootNode;</span><br><span class="line">       <span class="keyword">while</span> (temp != <span class="keyword">null</span> || !CollectionUtils.isEmpty(nodeLinkedList)) &#123;</span><br><span class="line">           path.add(temp.val);</span><br><span class="line">           nodeLinkedList.add(temp);</span><br><span class="line">           temp=temp.left;</span><br><span class="line">           <span class="keyword">while</span>(temp==<span class="keyword">null</span>&amp;&amp; !CollectionUtils.isEmpty(nodeLinkedList))&#123;</span><br><span class="line">               temp=nodeLinkedList.removeLast().right;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> path;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">midPath</span><span class="params">(TreeNode rootNode, List&lt;String&gt; path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(rootNode)) &#123;</span><br><span class="line">        midPath(rootNode.left, path);</span><br><span class="line">        path.add(rootNode.val);</span><br><span class="line">        midPath(rootNode.right, path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归-1"><a href="#非递归-1" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">middlePath</span><span class="params">(TreeNode rootNode)</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;TreeNode&gt; nodeList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(rootNode!=<span class="keyword">null</span> || !CollectionUtils.isEmpty(nodeList))&#123;</span><br><span class="line">        nodeList.add(rootNode);</span><br><span class="line">        rootNode=rootNode.left;</span><br><span class="line">        <span class="keyword">while</span>(rootNode==<span class="keyword">null</span> &amp;&amp; !CollectionUtils.isEmpty(nodeList))&#123;</span><br><span class="line">            rootNode=nodeList.removeLast();</span><br><span class="line">            path.add(rootNode.val);</span><br><span class="line">            rootNode=rootNode.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void afterPath(TreeNode root, List&lt;String&gt; path) &#123;</span><br><span class="line">    if (root != null) &#123;</span><br><span class="line">        afterPath(root.left, path);</span><br><span class="line">        afterPath(root.right, path);</span><br><span class="line">        path.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归-2"><a href="#非递归-2" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">afterPath2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       LinkedList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       TreeNode flag = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">           nodes.add(root);</span><br><span class="line">           root = root.left;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (!CollectionUtils.isEmpty(nodes)) &#123;</span><br><span class="line">           root = nodes.removeLast();</span><br><span class="line">           <span class="keyword">if</span> (root.right == <span class="keyword">null</span> || root.right == flag) &#123;</span><br><span class="line">               path.add(root.val);</span><br><span class="line">               flag = root;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               nodes.add(root);</span><br><span class="line">               root = root.right;</span><br><span class="line">               <span class="comment">//左节点获取</span></span><br><span class="line">               <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   nodes.add(root);</span><br><span class="line">                   root = root.left;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> path;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; levelPath(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//层级点数</span></span><br><span class="line">    nodes.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!CollectionUtils.isEmpty(nodes)) &#123;</span><br><span class="line">        List&lt;String&gt; p = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        i = nodes.size();</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           root = nodes.removeFirst();</span><br><span class="line">           p.add(root.val);</span><br><span class="line">           i--;</span><br><span class="line">           <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               nodes.add(root.left);</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                nodes.add(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树的最大深度"><a href="#树的最大深度" class="headerlink" title="树的最大深度"></a>树的最大深度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(depth(root.left)+<span class="number">1</span>,depth(root.right)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">     <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> right = minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">    right = right == <span class="number">1</span> ? Integer.MAX_VALUE : right;</span><br><span class="line">    left = left == <span class="number">1</span> ? Integer.MAX_VALUE : left;</span><br><span class="line">    <span class="keyword">return</span> Math.min(right, left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><h3 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode temp = root.left;</span><br><span class="line">    root.left=root.right;</span><br><span class="line">    root.right=temp;</span><br><span class="line">    swap(root.left);</span><br><span class="line">    swap(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归-3"><a href="#非递归-3" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap2</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">      LinkedList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//层级点数</span></span><br><span class="line">      nodes.add(root);</span><br><span class="line">      <span class="keyword">while</span> (!CollectionUtils.isEmpty(nodes)) &#123;</span><br><span class="line">          i = nodes.size();</span><br><span class="line">          <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              root = nodes.removeFirst();</span><br><span class="line">              TreeNode temp = root.left;</span><br><span class="line">              root.left=root.right;</span><br><span class="line">              root.right=temp;</span><br><span class="line">              i--;</span><br><span class="line">              <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  nodes.add(root.left);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  nodes.add(root.right);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>给一个排序数组（从小到大），将其转换为一棵高度最小的二叉搜索树。  分别寻找左右的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">if</span>(A.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = A.length - <span class="number">1</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(A[(len / <span class="number">2</span>)]);</span><br><span class="line">    root.left = searchChild(<span class="number">0</span>, len / <span class="number">2</span>-<span class="number">1</span> , A);</span><br><span class="line">    root.right = searchChild(len / <span class="number">2</span> +<span class="number">1</span>, len, A);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchChild</span><span class="params">(Integer left, Integer right, <span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(A[(right + left) / <span class="number">2</span>]);</span><br><span class="line">    node.left = searchChild(left, (right + left) / <span class="number">2</span> - <span class="number">1</span>, A);</span><br><span class="line">    node.right = searchChild((right + left) / <span class="number">2</span> + <span class="number">1</span>, right, A);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将二叉树按照层级转化为链表"><a href="#将二叉树按照层级转化为链表" class="headerlink" title="将二叉树按照层级转化为链表"></a>将二叉树按照层级转化为链表</h2><p>类似于层级遍历，再构造新的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ListNode&gt; <span class="title">binaryTreeToLists</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    List&lt;ListNode&gt; nodes = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nodes ;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode p = root;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; temp = <span class="keyword">new</span> LinkedList &lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            p=queue.poll();</span><br><span class="line">            temp.add(p);</span><br><span class="line">            <span class="keyword">if</span>(p.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(p.left);</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">if</span>(p.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(p.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(!temp.isEmpty())&#123;</span><br><span class="line">           TreeNode tn = temp.poll();</span><br><span class="line">           <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">               head = <span class="keyword">new</span> ListNode(tn.val);</span><br><span class="line">               next = head;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               ListNode curNode = <span class="keyword">new</span> ListNode(tn.val);</span><br><span class="line">               next.next=curNode;</span><br><span class="line">               next=next.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       nodes.add(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树转换成链表"><a href="#二叉树转换成链表" class="headerlink" title="二叉树转换成链表"></a>二叉树转换成链表</h2><p>先把右节点放入栈，再放左节点，然后该节点的左节点为空，再一次按节点的顺序设置右节点为栈头</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&#123;1,2,5,3,4,#,6&#125;</span><br><span class="line">输出：&#123;1,#,2,#,3,#,4,#,5,#,6&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="comment">// 先压右结点，后压左结点</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// connect</span></span><br><span class="line">            node.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 此处是 if else</span></span><br><span class="line">            <span class="comment">// node.right 在此处等同于 next</span></span><br><span class="line">            <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">                node.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.right = stack.peek();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断是否为等价二叉树"><a href="#判断是否为等价二叉树" class="headerlink" title="判断是否为等价二叉树"></a>判断是否为等价二叉树</h2><p>节点值相同，且儿子的值也相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEqual</span><span class="params">(TreeNode node1, TreeNode node2)</span> </span>&#123;</span><br><span class="line">    Boolean flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="keyword">null</span> &amp;&amp; node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node1 != <span class="keyword">null</span> &amp;&amp; node2 != <span class="keyword">null</span> &amp;&amp; node1.val == node2.val) &#123;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag &amp; isEqual(node1.left, node2.left) &amp; isEqual(node1.right, node2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h2><p>给一棵二叉树和二叉树中的两个节点，找到这两个节点的最近公共祖先<code>LCA</code>。</p>
<p>两个节点的最近公共祖先，是指两个节点的所有父亲节点中（包括这两个节点），离这两个节点最近的公共的节点。</p>
<p>每个节点除了左右儿子指针以外，还包含一个父亲指针<code>parent</code>，指向自己的父亲。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;ParentTreeNode&gt; path1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      List&lt;ParentTreeNode&gt; path2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(A!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          path1.add(A);</span><br><span class="line">          A=A.parent;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(B!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          path2.add(B);</span><br><span class="line">          B=B.parent;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;path1.size();i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(path2.contains(path1.get(i)))&#123;</span><br><span class="line">              <span class="keyword">return</span> path1.get(i);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<h2 id="所有叶子节点和"><a href="#所有叶子节点和" class="headerlink" title="所有叶子节点和"></a>所有叶子节点和</h2><p>需要处理下list的结果和，基本类型传值，除了新写一个类包一下，暂时没别的想法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">allLeaf</span><span class="params">(TreeNode root, List&lt;Integer&gt; leaf)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">          leaf.add(root.val);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      allLeaf(root.left, leaf);</span><br><span class="line">      allLeaf(root.right, leaf);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小子树"><a href="#最小子树" class="headerlink" title="最小子树"></a>最小子树</h2><p>给一棵二叉树, 找到和为最小的子树, 返回其根节点。输入输出数据范围都在int内。有个坑就是节点的左右子节点都要取，不是只招一条分支，例如”1,-5,-2,1,2,-4,-5”。输出的是-12</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root: the root of binary tree</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: the root of the minimum subtree</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TreeNode temp=<span class="keyword">null</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer sum = Integer.MAX_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">findSubtree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        sum=Integer.MAX_VALUE;</span><br><span class="line">        sum=minTree(root);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = minTree(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = minTree(root.right);</span><br><span class="line">        <span class="keyword">if</span>(left+right+root.val&lt;sum)&#123;</span><br><span class="line">            sum = left+right+root.val;</span><br><span class="line">            temp = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left+right+root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2020/08/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划更多的是偏向查找状态的转移，上一步状态于下一步状态的转移公式。比较费头发吧</p>
<h2 id="经典的01背包问题"><a href="#经典的01背包问题" class="headerlink" title="经典的01背包问题"></a>经典的01背包问题</h2><p>在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为V，每个物品的大小为a[i]。</p>
<p>可以推出状态的转移公式</p>
<p><strong>二维数组</strong>  </p>
<p>背包大小v,物品个数为i</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//背包容量不足以放下第i个，直接取i-1的物体的最大重量，如果不存在i-1,默认为0</span><br><span class="line">dp[i][j] = dp[i - 1][j];</span><br><span class="line">//可以放第i个物体，选择放还是不放，取最大值。这里用a[i-1]是为了配合我创建的二位数组，默认了0的边界</span><br><span class="line">dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - a[i - 1]] + a[i - 1]);</span><br></pre></td></tr></table></figure>
<p>解体的思路就是放或则不放第i个物体，所以可以如下解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  public static int maxWeight(Integer[] a, Integer v) &#123;</span><br><span class="line">//越界时的处理，边界默认为0。第一行和第一列默认为0 ，java默认创建的int数组值都为0</span><br><span class="line">      int dp[][] = new int[a.length + 1][v + 1];</span><br><span class="line">      for (int i = 1; i &lt;= a.length; i++) &#123;</span><br><span class="line">          for (int j = 1; j &lt;= v; j++) &#123;</span><br><span class="line">              if (a[i - 1] &gt; j) &#123;</span><br><span class="line">                  dp[i][j] = dp[i - 1][j];</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - a[i - 1]] + a[i - 1]);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return dp[a.length][v];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int dp[][] = new int[a.length + 1][v + 1];</span><br><span class="line">创建的二位数据是物体个数+1，背包大小+1，之所以+1是为了dp[i - 1][] 设置边界值为0</span><br><span class="line">dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - a[i - 1]] + a[i - 1]);</span><br><span class="line"></span><br><span class="line">dp[i - 1][j] 表示的是不装第i个物体，背包容量为j时最大可装数量。向后退一步</span><br><span class="line"></span><br><span class="line">dp[i - 1][j - a[i - 1]] + a[i - 1]</span><br><span class="line">表示的是放入第i个物体，所以在放入第i个物体的时候，只要要空出第i个物体的大小空间（a[i-1]），所以放入的最大值的公式是空出第i个物体的空间后的最大可放的物体总重量加上剩余空间可放物体最大总量。</span><br></pre></td></tr></table></figure>
<p><strong>一维数组的优化</strong></p>
<p>优化为一维数组，可以使用一维数组的下标作为背包的大小v,通关不断的遍历物体，在判断放不放如第i个物体，算出最大包装大小时的累加重量,从最大的包装量向前递推，遍历物体。在能放入第i个物体的包装大小情况下，寻找最大的值，代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int simpleMaxWeight(Integer[] a, Integer v) &#123;</span><br><span class="line">    int dp[] = new int[v + 1];</span><br><span class="line">    for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">        for (int j = v; j &gt;= a[i]; j--)</span><br><span class="line">            dp[j] = Math.max(dp[j - a[i]] + a[i], dp[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[v];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>完全背包于01背包的区别就是每个物体的个数是无线的，所以每种类型的物体放入的个数是不确定的。</p>
<p>例如 ：有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是w[i]，价值是val[i]</p>
<p>所以基本上在01背包的问题上修改就可以实现完全背包的解。唯一的区别就是在判断是否放入第i个物体时，枚举放入多少个。</p>
<p>状态转移公式可以写为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-k*a[i-1]]+k*a[i-1]);</span><br></pre></td></tr></table></figure>
<p>整个问题的代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int completePackage(Integer[] a, Integer v) &#123;</span><br><span class="line">    int dp[][] = new int[a.length + 1][v + 1];</span><br><span class="line">    for (int i = 1; i &lt;= a.length; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= v; j++) &#123;</span><br><span class="line">            if(a[i-1]&gt;j)&#123; // 这个物品背包放不下，继承前i-1个物体的最大重量</span><br><span class="line">                dp[i][j] = dp[i-1][j];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //能放下，但是不知道放多少,k表示i物体最多能放的个数</span><br><span class="line">                for(int k=0;k&lt;=j/a[i-1];k++)&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-k*a[i-1]]+k*a[i-1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[a.length][v];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>知道了上面的状态转移公式，也可以转换成一维的状态公式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[j] = Math.max(dp[j], dp[j - k*a[i]] + k*a[i]);</span><br></pre></td></tr></table></figure>
<p>完整的方法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int simpleCompletePackage(Integer[] a, Integer v) &#123;</span><br><span class="line">    //同样是以背包的容量，循环放入第i个物体，背包的大小倒叙循环遍历累加</span><br><span class="line">    int dp[] = new int[v + 1];</span><br><span class="line">    for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">        for (int j = v; j &gt; a[i]; j--) &#123;</span><br><span class="line">            //这里同样尝试放入k个物体，取其最大值</span><br><span class="line">            for (int k = 0; k &lt;= j / a[i]; k++) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - k*a[i]] + k*a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[v];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小调整代价"><a href="#最小调整代价" class="headerlink" title="最小调整代价"></a>最小调整代价</h2><p>给一个整数数组，调整每个数的大小，使得相邻的两个数的差不大于一个给定的整数target，调整每个数的代价为调整前后的差的绝对值，求调整代价之和最小是多少。你可以假设数组中每个整数都是正整数，且小于等于100。</p>
<p>样例</p>
<p>对于数组[1, 4, 2, 3]和target=1，最小的调整方案是调整为[2, 3, 2, 3]，调整代价之和是2。返回2。</p>
<p>解体的思路是由当前的值指向前递推一步。创建二位的数组dp [i] [j]  ,表示的是第i个数字调整到 j 的总调整代价。K表示的是[i-1] 的数字在选择范围的数字  </p>
<p>可以推测出 dp [i] [j] = Math.min(dp[i] [j], dp [i - 1] [k] + Math.abs(j - data.get(i)));</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int minPrice(List&lt;Integer&gt; data, int target) &#123;</span><br><span class="line">        if (data.size() &lt;= 1) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[][] dp = new int[data.size()][101];</span><br><span class="line">        for (int i = 0; i &lt; data.size(); i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt;= 100; j++) &#123;</span><br><span class="line">                dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; data.size(); i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 100; j++) &#123;</span><br><span class="line">                if (i == 0) &#123;</span><br><span class="line">                    dp[i][j] = Math.abs(j - data.get(i));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    for (int k = Math.max(0, Math.abs(data.get(i) - target)-1); k &lt;= Math.min(100, data.get(i) + target); k++) &#123;</span><br><span class="line">                        dp[i][j] = Math.min(dp[i][j], dp[i - 1][k] + Math.abs(j - data.get(i)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int cost = Integer.MAX_VALUE;</span><br><span class="line">        for (int j = 0; j &lt;= 100; j++) &#123;</span><br><span class="line">            cost = Math.min(cost, dp[data.size() - 1][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        return cost;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="交叉字符串"><a href="#交叉字符串" class="headerlink" title="交叉字符串"></a>交叉字符串</h2><p>给出三个字符串:<em>s1</em>、<em>s2</em>、<em>s3</em>，判断<em>s3</em>是否由<em>s1</em>和<em>s2</em>交叉构成。</p>
<p>最开始想到的的确是暴力破解，遍历所有，但是这个题目的范围是在动态规划，所以只能推算状态转移公式</p>
<p>查看了别人的博客，判断两个字符串是否可以交叉，主要判断的是两个字符串能否字串的比较，</p>
<p>dp[i][j]表示s1的前i个字符与s2的前j个字符,是否可以交叉构成s3的前i+j个字符</p>
<p>dp[i][j]只需要考虑dp[i][j-1]和dp[i-1] [j]，当dp[i][j-1]为true,s1的前i个字符与s2的前j-1个字符交叉构成s3的前i+j-1个字符，此时比较s2的第j个字符和s3的第i+j个字符；当dp[i-1] [j]为true,s1的前i-1个字符与s2的前j个字符交叉构成s3的前i+j-1个字符，此时比较s1的第i个字符和s3的第i+j个字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Boolean isCross(String s1, String s2, String s3) &#123;</span><br><span class="line">    if ((StringUtils.isEmpty(s1) &amp;&amp; StringUtils.isEmpty(s2)) || StringUtils.isEmpty(s3)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    Boolean[][] dp = new Boolean[s1.length()][s2.length()];</span><br><span class="line">    for (int i = 0; i &lt; s1.length(); i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; s2.length(); j++) &#123;</span><br><span class="line">            dp[i][j] = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //考虑边界的情况,设置边界值</span><br><span class="line">    for (int j = 0; j &lt; s2.length(); j++) &#123;</span><br><span class="line">        if (s3.charAt(j) == s2.charAt(j)) &#123;</span><br><span class="line">            dp[0][j] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; s1.length(); i++) &#123;</span><br><span class="line">        if (s1.charAt(i) == s3.charAt(i)) &#123;</span><br><span class="line">            dp[i][0] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //分解子问题</span><br><span class="line">    for (int i = 1; i &lt; s1.length(); ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt; s2.length(); ++j) &#123;</span><br><span class="line">            if (dp[i][j - 1] &amp;&amp; s2.charAt(j-1) == s3.charAt(i + j)) &#123;</span><br><span class="line">                dp[i][j] = true;</span><br><span class="line">            &#125; else if (  dp[i - 1][j] &amp;&amp; s1.charAt(i-1) == s3.charAt(i + j )) &#123;</span><br><span class="line">                dp[i][j] = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[s1.length()-1][s2.length()-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>先解释下子序列和 子串，子序列是可以是不连续的，而字串中的元素必须是连续的。</p>
<p>所以最长公共字串的解题方法灵活运用substrin()方法就可以。这里就不赘述了。</p>
<p>关于最长公共子序列的思路是假设两个字符串 s1,s2。i,j分别是对应的s1,s2的下标位置。</p>
<p>当s1.charAt(i) 与s2.charAt(j)的元素下相同时，dp[i] [j]的递推公式就为 dp[i][j] = dp[i - 1] [j - 1] + 1;</p>
<p>当s1.charAt(i) 与s2.charAt(j)的元素下不相同时，dp[i] [j] = Math.max(dp[i] [j-1],dp[i-1] [j]),取顺位的最大值。</p>
<p><a href="https://blog.csdn.net/hrn1216/article/details/51534607" target="_blank" rel="noopener">更多详细解析可以参考这位大佬的博客</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int longestSerial(String s1, String s2) &#123;</span><br><span class="line">    if (StringUtils.isEmpty(s1) || StringUtils.isEmpty(s2)) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int[][] dp = new int[s1.length() + 1][s2.length() + 1];</span><br><span class="line">    for (int i = 1; i &lt;= s1.length(); ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= s2.length(); ++j) &#123;</span><br><span class="line">            if (s1.charAt(i - 1) == s2.charAt(j - 1)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i][j-1],dp[i-1][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[s1.length()][s2.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>你好，hexo</title>
    <url>/2019/04/07/%E4%BD%A0%E5%A5%BD%EF%BC%8Chexo/</url>
    <content><![CDATA[<p>hexo测试文本</p>
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>npm</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2020/09/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>正则表达式是一种字符串匹配，通常用来检测字符串是否满足定义的规则，字符串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串。</p>
<h1 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h1><table>
<thead>
<tr>
<th>字符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>?</td>
<td>匹配0个或1个字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配0个或多个字符</td>
</tr>
<tr>
<td>^</td>
<td>开始标记，以某规则开始</td>
</tr>
<tr>
<td>$</td>
<td>结束标记，以某规则结束</td>
</tr>
<tr>
<td>( )</td>
<td>标记子表达式子，表达式可以获取供以后使用。要匹配这些字符，请使用 \ ( 和 \ )</td>
</tr>
</tbody>
</table>
<h1 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h1><table>
<thead>
<tr>
<th>匹配字符串</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[ABC]</td>
<td>匹配目标字符串中的 <strong>所有的</strong>  <strong>A B C</strong> 字符</td>
</tr>
<tr>
<td>[^ABC]</td>
<td>匹配目标字符串中的  <strong>除 A B C 以外</strong>的字符</td>
</tr>
<tr>
<td>[A-Z]</td>
<td>匹配区间内的所有字符，[a-zA-Z0-9]等</td>
</tr>
<tr>
<td>[\s\S]</td>
<td>匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，包括换行。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母、数字、下划线。等价于 [A-Za-z0-9_]</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>动态代理原理</title>
    <url>/2020/07/03/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>java中的代理方式常用的有以下几种</p>
<p>静态代理：在编译期间就创建，在代码的编译期间就将接口，被代理类、代理类确定下来</p>
<p>jdk动态代理</p>
<p>cglib动态代理</p>
<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>静态代理的实现一般是通过公共接口和接口继承类，也就是在代码中显式指定的代理。</p>
<p>约束接口 Animal</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Animal &#123;</span><br><span class="line"></span><br><span class="line">    default void doSomeThing()&#123;</span><br><span class="line">        System.out.println(&quot;do nothing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Human implements Animal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doSomeThing() &#123;</span><br><span class="line">        System.out.println(&quot;human &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>委托代理类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HumanProxy implements Animal &#123;</span><br><span class="line"></span><br><span class="line">    private Animal animal;</span><br><span class="line"></span><br><span class="line">    public HumanProxy(Animal animal) &#123;</span><br><span class="line">        this.animal = animal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doSomeThing() &#123;</span><br><span class="line">        System.out.println(&quot;proxy do something&quot;);</span><br><span class="line">         animal.doSomeThing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Human human = new Human();</span><br><span class="line">        Animal animal =  new HumanProxy(human);</span><br><span class="line">        animal.doSomeThing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态代理主要通过公共接口，代理类持有委托类的实例，通过委托的代理类来执行代理类来访要访问的对象。</p>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><ul>
<li>jdk动态代理</li>
<li>cglib动态代理</li>
</ul>
<p>两种代理的比较</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。反射机制在生成类的过程中比较高效，而asm在生成类之后的相关执行过程中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）。</span><br><span class="line">jdk动态代理的应用前提是目标类必须基于统一的接口。因此，jdk动态代理有一定的局限性，cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。</span><br></pre></td></tr></table></figure>
<p>创建一个需要被代理的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface DeveloperInterface &#123;</span><br><span class="line">    void writeCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Developer implements DeveloperInterface &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Developer() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Developer(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void writeCode() &#123;</span><br><span class="line">        System.out.println(&quot;Developer &quot; + name + &quot; writes code&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h2><ul>
<li>类:java.lang.reflect.Proxy(通过该类动态生成代理类)</li>
<li>代理类实现接口:InvocationHandler</li>
<li>jdk代理只能基于接口动态代理(因为生成的proxy class中，继承了Proxy类，实现了需要代理的接口，而Java是单继承，多实现的处理方式)</li>
</ul>
<p>JDK的动态代理需要集成同一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeveloperInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Developer</span> <span class="keyword">implements</span> <span class="title">DeveloperInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Developer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Developer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Developer "</span> + name + <span class="string">" writes code"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvocationHandlerProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用构造器注入目标方法，给我们要代理的真实对象赋初值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvocationHandlerProxy</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射的方法获取代理对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建代理类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取实例对象方法</span></span><br><span class="line">        DeveloperInterface developerInterface = <span class="keyword">new</span> Developer();</span><br><span class="line">        InvocationHandlerProxy&lt;DeveloperInterface&gt; proxy = <span class="keyword">new</span> InvocationHandlerProxy&lt;&gt;(developerInterface);</span><br><span class="line">        DeveloperInterface proxyDevelop = (DeveloperInterface) Proxy.newProxyInstance(DeveloperInterface.class.getClassLoader(), new Class&lt;?&gt;[]&#123;DeveloperInterface.class&#125;, proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InvocationHandler接口:<br>每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。InvocationHandler这个接口的唯一一个方法 invoke 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object invoke(Object proxy, Method method, Object[] args) throws Throwabl</span><br><span class="line"></span><br><span class="line">－proxy:　　指代我们所代理的那个真实对象</span><br><span class="line">－method:　　指代的是我们所要调用真实对象的某个方法的Method对象</span><br><span class="line">－args:　　指代的是调用真实对象某个方法时接受的参数</span><br></pre></td></tr></table></figure>
<h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>相比较于JDK的代理必须要继承InvocationHandler接口，cglib的代理实现就显得简单优雅许多，它的底层使用ASM在内存中动态的生成被代理类的子类，使用CGLIB即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB具有简单易用，它的运行速度要远远快于JDK的Proxy动态代理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CglibProxy implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger log = LoggerFactory.getLogger(CglibProxy.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object obj, Method method, Object</span><br><span class="line">            [] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;before cgplib&quot;);</span><br><span class="line">        Object result = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //利用反射创建代理对象</span><br><span class="line">            result = proxy.invokeSuper(obj, args);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;ex:&quot; + e.getMessage());</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;after cglib&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//测试方法</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 主要的增强类</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        //  目标类 , 设置父类，被增强的类</span><br><span class="line">        enhancer.setSuperclass(Developer.class);</span><br><span class="line">        // 回调对象</span><br><span class="line">        enhancer.setCallback(new CglibProxy());</span><br><span class="line">        //生成代理类对象，用cglibProxy来增强RealSubject</span><br><span class="line">//        Developer subject = (Developer) enhancer.create();</span><br><span class="line">        Developer subject = (Developer) enhancer.create(new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;123&quot;&#125;);</span><br><span class="line">        subject.writeCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java字节码生成开源框架–ASM：<br>ASM 是一个 Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。<br>不过ASM在创建class字节码的过程中，操纵的级别是底层JVM的汇编指令级别，这要求ASM使用者要对class组织结构和JVM汇编指令有一定的了解。</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议-http</title>
    <url>/2020/10/14/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-http/</url>
    <content><![CDATA[<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p><img src="./httpQuest.jpg" width="400" height="350" alt="http" align="center"></p>
<p>​        HTTP（超文本传输协议，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。是用于从WWW服务器传输超文本到本地浏览器的传输协议。默认使用80端口，HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP协议和TCP协议是不冲突的，HTTP定义在七层协议中的应用层，TCP解决的是传输层的逻辑。</p>
<h2 id="HTTP特性（http1-1）"><a href="#HTTP特性（http1-1）" class="headerlink" title="HTTP特性（http1.1）"></a>HTTP特性（http1.1）</h2><h3 id="1-简单"><a href="#1-简单" class="headerlink" title="1.简单"></a>1.简单</h3><p>HTTP 基本的报⽂格式就是 header + body ，头部信息也是 key-value 简单⽂本的形式，易于理解，降低了学习和使⽤的⻔槛。</p>
<h3 id="2-灵活和易于扩展"><a href="#2-灵活和易于扩展" class="headerlink" title="2.灵活和易于扩展"></a>2.灵活和易于扩展</h3><p>HTTP协议⾥的各类请求⽅法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发⼈员⾃定义和扩充。同时 HTTP 由于是⼯作在应⽤层（ OSI 第七层），则它下层可以随意变化。HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚⾄把 TCP 层换成了基于 UDP 的 QUIC。</p>
<h3 id="3-应⽤⼴泛和跨平台"><a href="#3-应⽤⼴泛和跨平台" class="headerlink" title="3.应⽤⼴泛和跨平台"></a>3.应⽤⼴泛和跨平台</h3><p>HTTP 的应⽤范围⾮常的⼴泛，从台式机的浏览器到⼿机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应⽤⽚地开花，同时天然具有跨平台的优越性。</p>
<h3 id="4-无状态"><a href="#4-无状态" class="headerlink" title="4.无状态"></a>4.无状态</h3><p>服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存⽤来对外提供服务。</p>
<h3 id="5-不安全"><a href="#5-不安全" class="headerlink" title="5.不安全"></a>5.不安全</h3><p>HTTP 的安全问题，可以⽤ HTTPS 的⽅式解决，也就是通过引⼊ SSL/TLS 层，使得在安全上达到了极。</p>
<h2 id="HTTP的性能"><a href="#HTTP的性能" class="headerlink" title="HTTP的性能"></a>HTTP的性能</h2><p>HTTP 协议是基于 TCP/IP，并且使⽤了「请求 - 应答」的通信模式</p>
<h3 id="1-长连接"><a href="#1-长连接" class="headerlink" title="1.长连接"></a>1.长连接</h3><p><img src="./httpConnect.jpg" width="400" height="350" alt="http" align="center"></p>
<p>早期 HTTP/1.0 性能上的⼀个很⼤的问题，那就是每发起⼀个请求，都要新建⼀次 TCP 连接（三次握⼿），⽽且是串⾏请求，做了⽆谓的 TCP 连接建⽴和断开，增加了通信开销。</p>
<p>为了解决上述 TCP 连接问题，HTTP/1.1 提出了⻓连接的通信⽅式，也叫持久连接。这种⽅式的好处在于减少了 TCP 连接的᯿复建⽴和断开所造成的额外开销，减轻了服务器端的负载。</p>
<h3 id="2-管道⽹络传输"><a href="#2-管道⽹络传输" class="headerlink" title="2.管道⽹络传输"></a>2.管道⽹络传输</h3><p><img src="./httpPipel.jpg" width="400" height="350" alt="http" align="center"></p>
<p>HTTP/1.1 采⽤了⻓连接的⽅式，这使得管道（pipeline）⽹络传输成为了可能。<br>即可在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。</p>
<h2 id="HTTP的演变"><a href="#HTTP的演变" class="headerlink" title="HTTP的演变"></a>HTTP的演变</h2><h3 id="http1-0"><a href="#http1-0" class="headerlink" title="http1.0"></a>http1.0</h3><p>伴随着计算机网络和浏览器的诞生，HTTP 1.0/1.1 也随之而来，它建立在 TCP 协议之上，处于计算机网络中的应用层，所以 <strong>HTTP 协议的瓶颈及其优化技巧都是基于 TCP 协议本身的特性</strong>，例如 TCP 建立连接的 3 次握手和断开连接的 4 次挥手，以及每次建立连接带来的 RTT 延迟时间等。</p>
<h3 id="htpp1-1"><a href="#htpp1-1" class="headerlink" title="htpp1.1"></a>htpp1.1</h3><p>HTTP 1.1 对比 1.0 的提升：</p>
<p>1.使⽤ TCP ⻓连接的⽅式改善了 HTTP/1.0 短连接造成的性能开销。</p>
<p>2.⽀持管道（pipeline）⽹络传输，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间，但是请求的返回要按照顺序的，如果其中一个请求发生阻塞，会发生头部阻塞。</p>
<p>但是HTTP/1.1 还是有性能瓶颈：</p>
<p>​    请求 / 响应头部（Header）未经压缩就发送，⾸部信息越多延迟越⼤。只能压缩 Body 的部分；<br>​    发送冗⻓的⾸部。每次互相发送相同的⾸部造成的浪费较多；<br>​    服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端⼀直请求不到数据，也就是队头阻塞；<br>​    没有请求优先级控制；请求只能从客户端开始，服务器只能被动响应。</p>
<h3 id="htpp2"><a href="#htpp2" class="headerlink" title="htpp2"></a>htpp2</h3><p><img src="./httpCompare.jpg" width="400" height="350" alt="http" align="center"></p>
<p>HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。</p>
<p>1.头部压缩:</p>
<p>HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是⼀样的或是相似的，那么，协议会帮你消除重复的部分。</p>
<p>2.⼆进制格式</p>
<p>HTTP/2 不再像 HTTP/1.1 ⾥的纯⽂本形式的报⽂，⽽是全⾯采⽤了⼆进制格式，头信息和数据体都是⼆进制，并且统称为帧（frame）：头信息帧和数据帧。</p>
<p>3.数据流</p>
<p>HTTP/2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。每个请求或回应的所有数据包，称为⼀个数据流（ Stream ）。每个数据流都标记着⼀个独⼀⽆⼆的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。</p>
<p>4.多路复⽤</p>
<p>即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面</p>
<p>5.服务器推送</p>
<p>HTTP/2 还在⼀定程度上改善了传统的「请求 - 应答」⼯作模式，服务不再是被动地响应，也可以主动向客户端发送消息。举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会⽤到的 JS、CSS ⽂件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。</p>
<h3 id="http3"><a href="#http3" class="headerlink" title="http3"></a>http3</h3><p>虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，主要是底层支撑的 TCP 协议造成的。上文提到 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。</p>
<p>因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是<strong>对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据</strong>。</p>
<p>基于这个原因，<strong>Google 就自己架起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上</strong>，HTTP/3 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。</p>
<p>UDP 发⽣是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的⼀个丢包阻塞全部。<br>⼤家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。<br>QUIC 有⾃⼰的⼀套机制可以保证传输的可靠性的。当某个流发⽣丢包时，只会阻塞这个流，其他<br>流不会受到影响。<br>TLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack 。<br>HTTPS 要建⽴⼀个连接，要花费 6 次交互，先是建⽴三次握⼿，然后是 TLS/1.3 的三次握⼿。<br>QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp</title>
    <url>/2020/08/03/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-tcp/</url>
    <content><![CDATA[<h1 id="TCP头部结构"><a href="#TCP头部结构" class="headerlink" title="TCP头部结构"></a>TCP头部结构</h1><p>​    TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p>
<p><img src="/2020/08/03/网络协议-tcp/./tcpHeader.png" width="400" height="350" alt="TCP头部" align="center"></p>
<p>​    <strong>16位端口号</strong>：标示该段报文来自哪里（源端口）以及要传给哪个上层协议或应用程序（目的端口）。进行tcp通信时，一般client是通过系统自动选择的临时端口号，而服务器一般是使用知名服务端口号或者自己指定的端口号。</p>
<p>​     <strong>32位序列号</strong>：一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。假设主机A和主机B进行TCP通信，A发送给B的第一个TCP报文段中，序号值被系统初始化为某个随机值ISN（Initial Sequence Number，初始序号值）。那么在该传输方向上（从A到B），后续的TCP报文段中序号值将被系统设置成ISN加上该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个TCP报文段传送的数据是字节流中的第1025~2048字节，那么该报文段的序号值就是ISN+1025.另外一个传输方向（从B到A）的TCP报文段的序号值也具有相同的含义。</p>
<p>​    <strong>确认应答号</strong>：用作对另一方发送来的TCP报文段的响应。其值是收到的TCP报文段的序号值加1</p>
<p>​    <strong>4位头部长度（header length）</strong>：标识该TCP头部有多少个32bit字（4字节）。因为4位最大能标识15，所以TCP头部最长是60字节。</p>
<p>​     <strong>6位标志位包含如下几项</strong></p>
<p>SYN：表示建立一个连接，携带SYN的tcp报文段为同步报文段</p>
<p>ACK：表示确认好是否有效，携带ack标志的报文段也称确认报文段</p>
<p>FIN：表示告知对方本端要关闭连接了。</p>
<p>RST：表示要求对方重建连接。带RST标志的tcp报文段也叫复位报文段</p>
<p>PSH：提示接收端应用程序应该立即从tcp接受缓冲区中读走数据，为后续接收的数据让出空间</p>
<p>URG：紧急指针是否有效</p>
<p><strong>16位窗口大小</strong>：是TCP流量控制的一个手段，这里说的窗口是指接收通告窗口，它告诉对方本端的tcp接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</p>
<p><strong>16位校验和</strong>：由发送端填充，接收端对tcp报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意这个校验不仅包括tcp头部，也包括数据部分。这也是tcp可靠传输的一个重要保障。</p>
<p><strong>16位紧急指针</strong>：是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此这个字段是紧急指针相对当前序号的偏移量。不妨称之为紧急便宜，发送紧急数据时会用到这个。</p>
<p> <strong>TCP头部选项</strong>：TCP头部的最后一个选项字段（options）是可变长的可选信息。这部分最多包含40字节，因为TCP头部最长是60字节</p>
<p><strong>四元组</strong></p>
<p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p>
<ul>
<li>源地址</li>
<li>源端口</li>
<li>目的地址</li>
<li>目的端口</li>
</ul>
<h1 id="TCP的连接数限制"><a href="#TCP的连接数限制" class="headerlink" title="TCP的连接数限制"></a>TCP的连接数限制</h1><h2 id="client最大连接数"><a href="#client最大连接数" class="headerlink" title="client最大连接数"></a>client最大连接数</h2><p>​                client每次发起TCP请求的时候，除非绑定接口，通常会让系统选取一个空闲的本地端口（local port），    该端口是独占的，不能和其他tcp连接共享。这样可用端口最多只有65535，所以在全部作为client端的情况           下，最大tcp连接数为65535，这些连接可以连到不同的server ip。</p>
<h2 id="server最大tcp连接数"><a href="#server最大tcp连接数" class="headerlink" title="server最大tcp连接数"></a>server最大tcp连接数</h2><p>​                server通常<strong>固定在某个本地端口上</strong>监听，等待client的连接请求。<strong>不考虑地址重用</strong>（unix的SO_REUSEADDR选项）的情况下，即使server端有多个ip，本地监听端口也是独占的，因此最大tcp连接为客户端ip数×客户端port数，对IPV4，不考虑ip地址分类等因素，最大tcp连接数约为2的32次方（ip数）×2的16次方（port数），也就是server端单机最大tcp连接数约为2的48次方。</p>
<p>但是在实际情况，收到机器资源和操作系统的限制，并发的tcp数量远远达不到理论的值</p>
<p>1、首先主要是<strong>文件描述符限制</strong>，Socket 都是文件，所以首先要通过 ulimit 配置文件描述符的数目</p>
<p>2、另一个是<strong>内存限制</strong>，每个 TCP 连接都要占用一定内存，操作系统是有限的</p>
<h1 id="TCP连接图解"><a href="#TCP连接图解" class="headerlink" title="TCP连接图解"></a>TCP连接图解</h1><p>​    TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而<strong>建立连接是通过三次握手而进行的。</strong></p>
<h2 id="TCP-三次握手过程和状态变迁"><a href="#TCP-三次握手过程和状态变迁" class="headerlink" title="TCP 三次握手过程和状态变迁"></a><strong>TCP 三次握手过程和状态变迁</strong></h2><p><img src="/2020/08/03/网络协议-tcp/./connect.png" width="400" height="350" alt="TCP头部" align="center"></p>
<p>1、第一次客户端向请求段发送连接请求。携带的信息是初始化的seq产生的一个随机初始化值，标志位为syn。</p>
<p>2、第二个报文是服务端向客户端发送请求，服务端接收到客户端的报文后也初始化自己的序列号seq,确认序列号为客户端的seq+1，并设置标志位为syn和ack.</p>
<p>3、第三次握手是客户端接收到服务端的报文后，向服务端返回最后一个应达报文，该tcp把标志位的ack置为1，确认应答的序号为第二步服务端发送的seq+1。</p>
<h2 id="TCP-四次挥手过程和状态变迁"><a href="#TCP-四次挥手过程和状态变迁" class="headerlink" title="TCP 四次挥手过程和状态变迁"></a><strong>TCP 四次挥手过程和状态变迁</strong></h2><p>TCP 断开连接是通过<strong>四次挥手</strong>方式。双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。</p>
<p><img src="/2020/08/03/网络协议-tcp/./disconnect.png" width="400" height="350" alt="TCP头部" align="center"></p>
<p>1、客户端发起关闭请求的连接，标志位 fin为1，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。</p>
<p>2、服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入CLOSED_WAIT 状态。</p>
<p>3、客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。</p>
<p>4、等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入LAST_ACK 状态。</p>
<p>5、客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入TIME_WAIT 状态</p>
<p>6、服务器收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。</p>
<p>7、客户端在经过 2MSL 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。</p>
<h1 id="UDP和TCP的对比"><a href="#UDP和TCP的对比" class="headerlink" title="UDP和TCP的对比"></a>UDP和TCP的对比</h1><p><img src="/2020/08/03/网络协议-tcp/./udpHeader.png" width="400" height="350" alt="TCP头部" align="center"></p>
<p>udp的头部结构没有那么复杂，</p>
<ul>
<li>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。</li>
<li>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。</li>
<li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计。</li>
</ul>
<p><strong>连接方式不同</strong></p>
<ul>
<li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ul>
<p><strong>服务对象不同</strong></p>
<ul>
<li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li>
<li><p>UDP 支持一对一、一对多、多对多的交互通信</p>
<p><strong>可靠性</strong></p>
</li>
<li><p>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。</p>
</li>
<li>UDP 是尽最大努力交付，不保证可靠交付数据。</li>
</ul>
<p><strong>拥塞控制</strong>、<strong>流量控制</strong></p>
<ul>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
<h1 id="为什么tcp是三次握手"><a href="#为什么tcp是三次握手" class="headerlink" title="为什么tcp是三次握手"></a>为什么tcp是三次握手</h1><p>看了上面的tcp的三次握手的状态变化，很容易答出，三次握手的TCP是保证客户端和服务端两端都具有收发信息的能力。</p>
<p>但是除了上面的原因之外还有其他的一些考虑。</p>
<p>tcp的连接的可靠性是依赖于头部的sequence序列号来确认的，如果只有两次握手，即客户端的发送消息能力和客户端的接收发送能力是正常的（sequence是双方确认了的），但不能保证客户端的接收能力是正常的，在服务端发送tcp包的时候序列号不能保证被客户端正确接收，此时由于tcp的超时重发特性可能会不断重发TCP包到客户端</p>
<p>至于为什么不是四次握手，是因为第二握手的时候，服务端在返回ACK报文的时候同时也发起了建立连接的请求，同时初始化随机的sequence发送到客户端。如果把这一步才成服务端确认和服务端发情和客户端建立连接的请求，理论上也是可行，但是优化成一个请求能减少一次连接，不必要平白对一次连接。</p>
<h1 id="为什么TCP四次挥手"><a href="#为什么TCP四次挥手" class="headerlink" title="为什么TCP四次挥手"></a><strong>为什么TCP四次挥手</strong></h1><p>在客户端和服务端都没有发送数据的时候才能断开tcp连接，而客户端发起fin请求关闭连接的时候，只能说明客户端没有发送数据的请求了，服务端可能仍然存在要发送的消息，所以只能返回一个ACK的请求告诉客户端知道了，但是服务端额数据在发送数据数据完之后才能发送服务端断开连接的请求，然后客户端接收到连接断开的请求之后返回确认断开的ACK。</p>
<h1 id="第四次挥手的为什么要等待2MSL"><a href="#第四次挥手的为什么要等待2MSL" class="headerlink" title="第四次挥手的为什么要等待2MSL"></a>第四次挥手的为什么要等待2MSL</h1><p>这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。</p>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>窗口大小指的是无需等待确认应答就可以继续发送数据的最大值.在窗口范围的TCP不需要确认就可以直接接收，接收到第一个TCP的时候，窗口不断向后滑动, 所以叫做<strong>滑动窗口.</strong></p>
<h1 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h1><p>如果服务端发送报文丢失，发送端主机连续三次收到了同样的应答, 就会将对应的数据重新发送<br>这个时候接收端收到了数据之后, 再次返回的ACK就是正常的ACK了</p>
<h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><p>TCP虽然可以通过滑动窗口设置窗口大小，可靠的传输大量数据，但是如果一开始就传输大量数据或在传输的过程中因为网咯原因服务端接收能力减弱，可能引发一些问题。</p>
<p>因此TCP引入慢启动的机制。 先发少量的数据, 探探路, 摸清当前的网络拥堵状态以后, 再决定按照多大的速度传输数据。慢启动” 只是指初使时慢, 但是增长速度非常快，以指数的倍数上涨。慢启动本身设置了阈值，拥塞窗口的大小超过这个阈值的时候, 不再按照指数方式增长, 而是按照线性方式增长.当窗口大超过阈值，窗口大小乘法减少，重复快重传的过程。</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>自动装箱和拆箱</title>
    <url>/2020/03/30/%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/</url>
    <content><![CDATA[<h1 id="自动拆箱装箱"><a href="#自动拆箱装箱" class="headerlink" title="自动拆箱装箱"></a>自动拆箱装箱</h1><h2 id="1、基本的数据类型"><a href="#1、基本的数据类型" class="headerlink" title="1、基本的数据类型"></a>1、基本的数据类型</h2><p>基本类型，或者叫做内置类型，是Java中不同于类(Class)的特殊类型。它们是我们编程中使用最频繁的类型。</p>
<p>Java是一种强类型语言，第一次申明变量必须说明数据类型，第一次变量赋值称为变量的初始化。</p>
<p>字符类型<code>char</code></p>
<p>布尔类型<code>boolean</code></p>
<p>整数类型<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></p>
<p>浮点数类型<code>float</code>、<code>double</code>。</p>
<p>Java中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者操作系统的改变而改变。</p>
<p>我们都知道在Java语言中，new一个对象是存储在堆里的，我们通过栈中的引用来使用这些对象；所以，对象本身来说是比较消耗资源的。</p>
<p>对于经常用到的类型，如int等，如果我们每次使用这种变量的时候都需要new一个Java对象的话，就会比较笨重。</p>
<p>所以，和C++一样，Java提供了基本数据类型，这种数据的变量不需要使用new创建，他们不会在堆上创建，而是直接在栈内存中存储，因此会更加高效。</p>
<h2 id="2、包装类型"><a href="#2、包装类型" class="headerlink" title="2、包装类型"></a>2、包装类型</h2><p>Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。</p>
<p>包装类均位于java.lang包，因为Java是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型。比如，在集合类中，我们是无法将int 、double等类型放进去的。因为集合的容器要求元素是Object类型。</p>
<p>为了让基本类型也具有对象的特征，就出现了包装类型，它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p>
<h2 id="3、自动包装与拆箱"><a href="#3、自动包装与拆箱" class="headerlink" title="3、自动包装与拆箱"></a>3、自动包装与拆箱</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i =<span class="number">10</span>;  <span class="comment">//自动装箱</span></span><br><span class="line"><span class="keyword">int</span> b= i;     <span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure>
<p>对以上代码进行反编译后可以得到以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer integer=Integer.valueOf(<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">int</span> i=integer.intValue();</span><br></pre></td></tr></table></figure>
<h2 id="4、哪些地方会自动拆装箱"><a href="#4、哪些地方会自动拆装箱" class="headerlink" title="4、哪些地方会自动拆装箱"></a>4、哪些地方会自动拆装箱</h2><h3 id="1、将基本数据类型放入集合类"><a href="#1、将基本数据类型放入集合类" class="headerlink" title="1、将基本数据类型放入集合类"></a>1、将基本数据类型放入集合类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">50</span>; i ++)&#123;</span><br><span class="line">    li.add(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、包装类型和基本类型的比较"><a href="#2、包装类型和基本类型的比较" class="headerlink" title="2、包装类型和基本类型的比较"></a>2、包装类型和基本类型的比较</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Integer a=<span class="number">1</span>;</span><br><span class="line">System.out.println(a==<span class="number">1</span>?<span class="string">"等于"</span>:<span class="string">"不等于"</span>);</span><br><span class="line">Boolean bool=<span class="keyword">false</span>;</span><br><span class="line">System.out.println(bool?<span class="string">"真"</span>:<span class="string">"假"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3、包装类型的运算"><a href="#3、包装类型的运算" class="headerlink" title="3、包装类型的运算"></a>3、包装类型的运算</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;</span><br><span class="line">Integer j = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">System.out.println(i+j);</span><br></pre></td></tr></table></figure>
<h3 id="4、三目运算符的使用"><a href="#4、三目运算符的使用" class="headerlink" title="4、三目运算符的使用"></a>4、三目运算符的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">Integer i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k = flag ? i : j;</span><br></pre></td></tr></table></figure>
<p>这其实是三目运算符的语法规范：当第二，第三位操作数分别为基本类型和对象时，其中的对象就会拆箱为基本类型进行操作。</p>
<p>因为例子中，flag ? i : j;片段中，第二段的i是一个包装类型的对象，而第三段的j是一个基本类型，所以会对包装类进行自动拆箱。如果这个时候i的值为null，那么久会发生NPE。（自动拆箱导致空指针异常）</p>
<h3 id="5、函数参数与返回值"><a href="#5、函数参数与返回值" class="headerlink" title="5、函数参数与返回值"></a>5、函数参数与返回值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum1</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getNum2</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自动拆装箱与缓存"><a href="#自动拆装箱与缓存" class="headerlink" title="自动拆装箱与缓存"></a>自动拆装箱与缓存</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer integer1 = <span class="number">3</span>;s</span><br><span class="line">    Integer integer2 = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (integer1 == integer2)</span><br><span class="line">        System.out.println(<span class="string">"integer1 == integer2"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">"integer1 != integer2"</span>);</span><br><span class="line"> </span><br><span class="line">    Integer integer3 = <span class="number">300</span>;</span><br><span class="line">    Integer integer4 = <span class="number">300</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (integer3 == integer4)</span><br><span class="line">        System.out.println(<span class="string">"integer3 == integer4"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">"integer3 != integer4"</span>);</span><br></pre></td></tr></table></figure>
<p>在Java中，==比较的是对象应用，而equals比较的是值。</p>
<p>所以，在这个例子中，不同的对象有不同的引用，所以在进行比较的时候都将返回false。奇怪的是，这里两个类似的if条件判断返回不同的布尔值。</p>
<p>上面这段代码真正的输出结果：</p>
<p>integer1 == integer2<br>integer3 != integer4<br>原因就和Integer中的缓存机制有关。在Java 5中，在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。适用于整数值区间-128 至 +127。</p>
<p>只适用于自动装箱。使用构造函数创建对象不适用。</p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h1><p>开闭原则（Open Closed Principle，OCP）由勃兰特·梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向对象软件构造》（Object Oriented Software Construction）中提出：软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义。</p>
<p>这里的软件实体包括以下几个部分：</p>
<ol>
<li>项目中划分出的模块</li>
<li>类与接口</li>
<li>方法</li>
</ol>
<p>开闭原则的含义是：<em>当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</em></p>
<h1 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h1><p>迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p>
<p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p>
<h1 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式是<a href="http://c.biancheng.net/design_pattern/" target="_blank" rel="noopener">设计模式</a>中最简单的模式之一。通常，普通类的构造函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。主要用于保证一个类只有一个实例，并且提供一个全局访问点</p>
<p>1、懒汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SinglenStyle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SinglenStyle singlenStyle = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//private 避免在类外部被实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SinglenStyle</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="comment">//提供静态的公有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SinglenStyle <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//getInstance 方法前加同步</span></span><br><span class="line">        <span class="keyword">if</span>(singlenStyle==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            singlenStyle=<span class="keyword">new</span> SinglenStyle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singlenStyle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、饿汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SinglenStyle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SinglenStyle singlenStyle = <span class="keyword">new</span> SinglenStyle();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SinglenStyle</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SinglenStyle <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//getInstance 方法前加同步</span></span><br><span class="line">        <span class="keyword">return</span> singlenStyle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。在生活中复制的例子非常多，这里不一一列举了。</p>
<p>由于 <a href="http://c.biancheng.net/java/" target="_blank" rel="noopener">Java</a> 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。利用clone的方法获取一个类似的对象。</p>
<p>原型模式包含以下主要角色。</p>
<ol>
<li>抽象原型类：规定了具体原型对象必须实现的接口。</li>
<li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li>
<li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Realizetype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String val=<span class="string">"0"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVal</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Realizetype()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"具体原型创建成功！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体原型复制成功！"</span>);</span><br><span class="line">       <span class="keyword">return</span>(Realizetype)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Realizetype obj1=<span class="keyword">new</span> Realizetype();</span><br><span class="line">        Realizetype obj2=(Realizetype)obj1.clone();</span><br><span class="line">        obj1.setVal(<span class="string">"1"</span>);</span><br><span class="line">        obj2.setVal(<span class="string">"2"</span>);</span><br><span class="line">        System.out.println(<span class="string">"obj1==obj2?"</span>+(obj1==obj2));</span><br><span class="line">        System.out.println(obj1.getVal());</span><br><span class="line">        System.out.println(obj2.getVal());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<p>工厂方法模式的主要角色如下。</p>
<ol>
<li><p>抽象工厂：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 来创建产品。</p>
</li>
<li><p>具体工厂：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</p>
</li>
<li><p>抽象产品：定义了产品的规范，描述了产品的主要特性和功能。</p>
</li>
<li><p>具体产品：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</p>
</li>
</ol>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际工厂1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体工厂1生成--&gt;具体产品1..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体工厂2生成--&gt;具体产品1..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品一</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体产品1显示..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///产品二</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体产品2显示..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Product a;</span><br><span class="line">            AbstractFactory af;</span><br><span class="line">            Class&lt;?&gt; c = Class.forName(<span class="string">"com.example.design_style.ConcreteFactory1"</span>);</span><br><span class="line">            Object obj = c.newInstance();</span><br><span class="line">            af = (AbstractFactory) obj;</span><br><span class="line">            a = af.newProduct();</span><br><span class="line">            a.show();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"eror msg"</span>+e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的<a href="http://c.biancheng.net/design_pattern/" target="_blank" rel="noopener">设计模式</a>被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p>
<p>该模式的主要优点如下：</p>
<ol>
<li>各个具体的建造者相互独立，有利于系统的扩展。</li>
<li>客户端不必知道产品内部组成的细节，便于控制细节风险。</li>
</ol>
<p>其缺点如下：</p>
<ol>
<li>产品的组成部分必须相同，这限制了其使用范围。</li>
<li>如果产品的内部变化复杂，该模式会增加很多的建造者类。</li>
</ol>
<p>建造者（Builder）模式由产品、抽象建造者、具体建造者、指挥者等 4 个要素构成，现在我们来分析其基本结构和实现方法。</p>
<ol>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实际产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String partA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String partB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String partC;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPartA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> partA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartA</span><span class="params">(String partA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partA = partA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPartB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> partB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartB</span><span class="params">(String partB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partB = partB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPartC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> partC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartC</span><span class="params">(String partC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partC = partC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//显示产品的特性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认构建产品实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Product product=<span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  构建方法A</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  构建方法B</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  构建方法C</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//属性构造方法 具体建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">BaseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">"建造 PartA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">"建造 PartB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">"建造 PartC"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指挥者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BaseBuilder builder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(BaseBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        builder.buildPartA();</span><br><span class="line">        builder.buildPartB();</span><br><span class="line">        builder.buildPartC();</span><br><span class="line">        <span class="keyword">return</span> builder.getResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        BaseBuilder builder=<span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director=<span class="keyword">new</span> Director(builder);</span><br><span class="line">        Product product=director.construct();</span><br><span class="line">        product.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p>
<p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<p>类适配器模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要调用的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"适配者中的业务代码被调用！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//包装过后，调用目标接口来调用需要调用的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAdapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类适配器模式测试："</span>);</span><br><span class="line">        Target target = <span class="keyword">new</span> ClassAdapter();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象适配模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectAdapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对象适配器模式测试："</span>);</span><br><span class="line">        Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line">        Target target = <span class="keyword">new</span> ObjectAdapter(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<p>桥接（Bridge）模式的优点是：</p>
<ul>
<li>由于抽象与实现分离，所以扩展能力强；</li>
<li>其实现细节对客户透明。</li>
</ul>
<p>缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现话角色接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口实现方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体实现化(Concrete Implementor)角色被访问"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象类接口，内部适配角色接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Implementor imple;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Abstraction</span><span class="params">(Implementor imple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.imple = imple;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展角色实现，继承类调用角色接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor imple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(imple);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"扩展抽象化(Refined Abstraction)角色被访问"</span>);</span><br><span class="line">        imple.operationImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Implementor imple=<span class="keyword">new</span> ConcreteImplementorA();</span><br><span class="line">        Abstraction abs=<span class="keyword">new</span> RefinedAbstraction(imple);</span><br><span class="line">        abs.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式的结构不是很复杂，下面对它的结构和实现进行分析。</p>
<ol>
<li>模式的结构</li>
</ol>
<p>组合模式包含以下主要角色。</p>
<ol>
<li>抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。</li>
<li>树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。</li>
<li>树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。</li>
</ol>
<p>组合模式分为透明式的组合模式和安全式的组合模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象构建  通用方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span>  <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树叶</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"树叶"</span> + name + <span class="string">"：被访问！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树枝</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; children = <span class="keyword">new</span> ArrayList&lt;Component&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span> </span>&#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span> </span>&#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj : children) &#123;</span><br><span class="line">            ((Component) obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Component c0=<span class="keyword">new</span> Composite();</span><br><span class="line">        Component c1=<span class="keyword">new</span> Composite();</span><br><span class="line">        Component leaf1=<span class="keyword">new</span> Leaf(<span class="string">"1"</span>);</span><br><span class="line">        Component leaf2=<span class="keyword">new</span> Leaf(<span class="string">"2"</span>);</span><br><span class="line">        Component leaf3=<span class="keyword">new</span> Leaf(<span class="string">"3"</span>);</span><br><span class="line">        c0.add(leaf1);</span><br><span class="line">        c0.add(c1);</span><br><span class="line">        c1.add(leaf2);</span><br><span class="line">        c1.add(leaf3);</span><br><span class="line">        c0.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>装饰（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p>
<p>装饰（Decorator）模式的主要优点有：</p>
<ul>
<li>采用装饰模式扩展对象的功能比采用继承方式更加灵活。</li>
<li>可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。</li>
</ul>
<p>其主要缺点是：装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Component p=<span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        p.operation();</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">        Component d=<span class="keyword">new</span> ConcreteDecorator(p);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span>  <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteComponent</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建具体构件角色"</span>);       </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用具体构件角色的方法operation()"</span>);           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component=component;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator</span><span class="params">(Component component)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addedFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"为具体构件角色增加额外的功能addedFunction()"</span>);           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法。</p>
<ol>
<li>模式的结构</li>
</ol>
<p>代理模式的主要角色如下。</p>
<ol>
<li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Proxy proxy=<span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题方法..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            realSubject=<span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.Request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题之前的预处理。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题之后的后续处理。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观（Facade）模式的定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FacadePattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Facade f=new Facade();</span><br><span class="line">        f.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//外观角色</span><br><span class="line">class Facade</span><br><span class="line">&#123;</span><br><span class="line">    private SubSystem01 obj1=new SubSystem01();</span><br><span class="line">    private SubSystem02 obj2=new SubSystem02();</span><br><span class="line">    private SubSystem03 obj3=new SubSystem03();</span><br><span class="line">    public void method()</span><br><span class="line">    &#123;</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">        obj3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem01</span><br><span class="line">&#123;</span><br><span class="line">    public  void method1()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;子系统01的method1()被调用！&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem02</span><br><span class="line">&#123;</span><br><span class="line">    public  void method2()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;子系统02的method2()被调用！&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem03</span><br><span class="line">&#123;</span><br><span class="line">    public  void method3()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;子系统03的method3()被调用！&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="亨元模式"><a href="#亨元模式" class="headerlink" title="亨元模式"></a>亨元模式</h2><p>享元（Flyweight）模式的定义：运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FlyweightFactory factory=<span class="keyword">new</span> FlyweightFactory();</span><br><span class="line">        Flyweight f01=factory.getFlyweight(<span class="string">"a"</span>);</span><br><span class="line">        Flyweight f02=factory.getFlyweight(<span class="string">"a"</span>);</span><br><span class="line">        Flyweight f03=factory.getFlyweight(<span class="string">"a"</span>);</span><br><span class="line">        Flyweight f11=factory.getFlyweight(<span class="string">"b"</span>);</span><br><span class="line">        Flyweight f12=factory.getFlyweight(<span class="string">"b"</span>);       </span><br><span class="line">        f01.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第1次调用a。"</span>));       </span><br><span class="line">        f02.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第2次调用a。"</span>));       </span><br><span class="line">        f03.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第3次调用a。"</span>));       </span><br><span class="line">        f11.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第1次调用b。"</span>));       </span><br><span class="line">        f12.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第2次调用b。"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非享元角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsharedConcreteFlyweight</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line">    UnsharedConcreteFlyweight(String info)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.info=info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(String info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info=info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象享元角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyweight</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(UnsharedConcreteFlyweight state)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体享元角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">implements</span> <span class="title">Flyweight</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    ConcreteFlyweight(String key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.key=key;</span><br><span class="line">        System.out.println(<span class="string">"具体享元"</span>+key+<span class="string">"被创建！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(UnsharedConcreteFlyweight outState)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"具体享元"</span>+key+<span class="string">"被调用，"</span>);</span><br><span class="line">        System.out.println(<span class="string">"非享元信息是:"</span>+outState.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//享元工厂角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Flyweight&gt; flyweights=<span class="keyword">new</span> HashMap&lt;String, Flyweight&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Flyweight flyweight=(Flyweight)flyweights.get(key);</span><br><span class="line">        <span class="keyword">if</span>(flyweight!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"具体享元"</span>+key+<span class="string">"已经存在，被成功获取！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            flyweight=<span class="keyword">new</span> ConcreteFlyweight(key);</span><br><span class="line">            flyweights.put(key, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ObserverPattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Subject subject=new ConcreteSubject();</span><br><span class="line">        Observer obs1=new ConcreteObserver1();</span><br><span class="line">        Observer obs2=new ConcreteObserver2();</span><br><span class="line">        subject.add(obs1);</span><br><span class="line">        subject.add(obs2);</span><br><span class="line">        subject.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象目标</span><br><span class="line">abstract class Subject</span><br><span class="line">&#123;</span><br><span class="line">    protected List&lt;Observer&gt; observers=new ArrayList&lt;Observer&gt;();   </span><br><span class="line">    //增加观察者方法</span><br><span class="line">    public void add(Observer observer)</span><br><span class="line">    &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;    </span><br><span class="line">    //删除观察者方法</span><br><span class="line">    public void remove(Observer observer)</span><br><span class="line">    &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;   </span><br><span class="line">    public abstract void notifyObserver(); //通知观察者方法</span><br><span class="line">&#125;</span><br><span class="line">//具体目标</span><br><span class="line">class ConcreteSubject extends Subject</span><br><span class="line">&#123;</span><br><span class="line">    public void notifyObserver()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体目标发生改变...&quot;);</span><br><span class="line">        System.out.println(&quot;--------------&quot;);       </span><br><span class="line">       </span><br><span class="line">        for(Object obs:observers)</span><br><span class="line">        &#123;</span><br><span class="line">            ((Observer)obs).response();</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;          </span><br><span class="line">&#125;</span><br><span class="line">//抽象观察者</span><br><span class="line">interface Observer</span><br><span class="line">&#123;</span><br><span class="line">    void response(); //反应</span><br><span class="line">&#125;</span><br><span class="line">//具体观察者1</span><br><span class="line">class ConcreteObserver1 implements Observer</span><br><span class="line">&#123;</span><br><span class="line">    public void response()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体观察者1作出反应！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//具体观察者1</span><br><span class="line">class ConcreteObserver2 implements Observer</span><br><span class="line">&#123;</span><br><span class="line">    public void response()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体观察者2作出反应！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式是通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据。现在我们来分析其基本结构与实现方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Aggregate ag=<span class="keyword">new</span> ConcreteAggregate(); </span><br><span class="line">        ag.add(<span class="string">"中山大学"</span>); </span><br><span class="line">        ag.add(<span class="string">"华南理工"</span>); </span><br><span class="line">        ag.add(<span class="string">"韶关学院"</span>);</span><br><span class="line">        System.out.print(<span class="string">"聚合的内容有："</span>);</span><br><span class="line">        Iterator it=ag.getIterator(); </span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        &#123; </span><br><span class="line">            Object ob=it.next(); </span><br><span class="line">            System.out.print(ob.toString()+<span class="string">"\t"</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        Object ob=it.first();</span><br><span class="line">        System.out.println(<span class="string">"\nFirst："</span>+ob.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象聚合</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体聚合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list=<span class="keyword">new</span> ArrayList&lt;Object&gt;(); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        list.add(obj); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        list.remove(obj); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span>(<span class="keyword">new</span> ConcreteIterator(list)); </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list=<span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index=-<span class="number">1</span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(List&lt;Object&gt; list)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.list=list; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(index&lt;list.size()-<span class="number">1</span>)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">first</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        index=<span class="number">0</span>;</span><br><span class="line">        Object obj=list.get(index);;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        Object obj=<span class="keyword">null</span>; </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.hasNext())</span><br><span class="line">        &#123; </span><br><span class="line">            obj=list.get(++index); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> obj; </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Context c=<span class="keyword">new</span> Context();</span><br><span class="line">        Strategy s=<span class="keyword">new</span> ConcreteStrategyA();</span><br><span class="line">        c.setStrategy(s);</span><br><span class="line">        c.strategyMethod();</span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line">        s=<span class="keyword">new</span> ConcreteStrategyB();</span><br><span class="line">        c.setStrategy(s);</span><br><span class="line">        c.strategyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象策略类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span></span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span></span>;    <span class="comment">//策略方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体策略A的策略方法被访问！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"具体策略B的策略方法被访问！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Strategy <span class="title">getStrategy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(Strategy strategy)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy=strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        strategy.strategyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者（Mediator）模式的定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。</p>
<p>中介者模式是一种对象行为型模式，其主要优点如下。</p>
<ol>
<li>降低了对象之间的耦合性，使得对象易于独立地被复用。</li>
<li>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</li>
</ol>
<p>其主要缺点是：当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MediatorPattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Mediator md=new ConcreteMediator();</span><br><span class="line">        Colleague c1,c2;</span><br><span class="line">        c1=new ConcreteColleague1();</span><br><span class="line">        c2=new ConcreteColleague2();</span><br><span class="line">        md.register(c1);</span><br><span class="line">        md.register(c2);</span><br><span class="line">        c1.send();</span><br><span class="line">        System.out.println(&quot;-------------&quot;);</span><br><span class="line">        c2.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象中介者</span><br><span class="line">abstract class Mediator</span><br><span class="line">&#123;</span><br><span class="line">    public abstract void register(Colleague colleague);</span><br><span class="line">    public abstract void relay(Colleague cl); //转发</span><br><span class="line">&#125;</span><br><span class="line">//具体中介者</span><br><span class="line">class ConcreteMediator extends Mediator</span><br><span class="line">&#123;</span><br><span class="line">    private List&lt;Colleague&gt; colleagues=new ArrayList&lt;Colleague&gt;();</span><br><span class="line">    public void register(Colleague colleague)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!colleagues.contains(colleague))</span><br><span class="line">        &#123;</span><br><span class="line">            colleagues.add(colleague);</span><br><span class="line">            colleague.setMedium(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void relay(Colleague cl)</span><br><span class="line">    &#123;</span><br><span class="line">        for(Colleague ob:colleagues)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!ob.equals(cl))</span><br><span class="line">            &#123;</span><br><span class="line">                ((Colleague)ob).receive();</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象同事类</span><br><span class="line">abstract class Colleague</span><br><span class="line">&#123;</span><br><span class="line">    protected Mediator mediator;</span><br><span class="line">    public void setMedium(Mediator mediator)</span><br><span class="line">    &#123;</span><br><span class="line">        this.mediator=mediator;</span><br><span class="line">    &#125;   </span><br><span class="line">    public abstract void receive();   </span><br><span class="line">    public abstract void send();</span><br><span class="line">&#125;</span><br><span class="line">//具体同事类</span><br><span class="line">class ConcreteColleague1 extends Colleague</span><br><span class="line">&#123;</span><br><span class="line">    public void receive()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体同事类1收到请求。&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">    public void send()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体同事类1发出请求。&quot;);</span><br><span class="line">        mediator.relay(this); //请中介者转发</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//具体同事类</span><br><span class="line">class ConcreteColleague2 extends Colleague</span><br><span class="line">&#123;</span><br><span class="line">    public void receive()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体同事类2收到请求。&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">    public void send()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体同事类2发出请求。&quot;);</span><br><span class="line">        mediator.relay(this); //请中介者转发</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录（Memento）模式的定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。</p>
<p>备忘录模式是一种对象行为型模式，其主要优点如下。</p>
<ul>
<li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li>
<li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li>
<li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li>
</ul>
<p>其主要缺点是：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MementoPattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Originator or=new Originator();</span><br><span class="line">        Caretaker cr=new Caretaker();       </span><br><span class="line">        or.setState(&quot;S0&quot;); </span><br><span class="line">        System.out.println(&quot;初始状态:&quot;+or.getState());           </span><br><span class="line">        cr.setMemento(or.createMemento()); //保存状态      </span><br><span class="line">        or.setState(&quot;S1&quot;); </span><br><span class="line">        System.out.println(&quot;新的状态:&quot;+or.getState());        </span><br><span class="line">        or.restoreMemento(cr.getMemento()); //恢复状态</span><br><span class="line">        System.out.println(&quot;恢复状态:&quot;+or.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//备忘录</span><br><span class="line">class Memento</span><br><span class="line">&#123; </span><br><span class="line">    private String state; </span><br><span class="line">    public Memento(String state)</span><br><span class="line">    &#123; </span><br><span class="line">        this.state=state; </span><br><span class="line">    &#125;     </span><br><span class="line">    public void setState(String state)</span><br><span class="line">    &#123; </span><br><span class="line">        this.state=state; </span><br><span class="line">    &#125;</span><br><span class="line">    public String getState()</span><br><span class="line">    &#123; </span><br><span class="line">        return state; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//发起人</span><br><span class="line">class Originator</span><br><span class="line">&#123; </span><br><span class="line">    private String state;     </span><br><span class="line">    public void setState(String state)</span><br><span class="line">    &#123; </span><br><span class="line">        this.state=state; </span><br><span class="line">    &#125;</span><br><span class="line">    public String getState()</span><br><span class="line">    &#123; </span><br><span class="line">        return state; </span><br><span class="line">    &#125;</span><br><span class="line">    public Memento createMemento()</span><br><span class="line">    &#123; </span><br><span class="line">        return new Memento(state); </span><br><span class="line">    &#125; </span><br><span class="line">    public void restoreMemento(Memento m)</span><br><span class="line">    &#123; </span><br><span class="line">        this.setState(m.getState()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">//管理者</span><br><span class="line">class Caretaker</span><br><span class="line">&#123; </span><br><span class="line">    private Memento memento;       </span><br><span class="line">    public void setMemento(Memento m)</span><br><span class="line">    &#123; </span><br><span class="line">        memento=m; </span><br><span class="line">    &#125;</span><br><span class="line">    public Memento getMemento()</span><br><span class="line">    &#123; </span><br><span class="line">        return memento; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="访问者模式-1"><a href="#访问者模式-1" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>问者（Visitor）模式的定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。</p>
<p>访问者（Visitor）模式是一种对象行为型模式，其主要优点如下。</p>
<ol>
<li>扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li>
<li>复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</li>
<li>灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</li>
<li>符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</li>
</ol>
<p>访问者（Visitor）模式的主要缺点如下。</p>
<ol>
<li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</li>
<li>破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。</li>
<li>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisitorPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ObjectStructure os=<span class="keyword">new</span> ObjectStructure();</span><br><span class="line">        os.add(<span class="keyword">new</span> ConcreteElementA());</span><br><span class="line">        os.add(<span class="keyword">new</span> ConcreteElementB());</span><br><span class="line">        Visitor visitor=<span class="keyword">new</span> ConcreteVisitorA();</span><br><span class="line">        os.accept(visitor);</span><br><span class="line">        System.out.println(<span class="string">"------------------------"</span>);</span><br><span class="line">        visitor=<span class="keyword">new</span> ConcreteVisitorB();</span><br><span class="line">        os.accept(visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象访问者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体访问者A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorA</span> <span class="keyword">implements</span> <span class="title">Visitor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体访问者A访问--&gt;"</span>+element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体访问者A访问--&gt;"</span>+element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体访问者B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorB</span> <span class="keyword">implements</span> <span class="title">Visitor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体访问者B访问--&gt;"</span>+element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体访问者B访问--&gt;"</span>+element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象元素类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Element</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体元素A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementA</span> <span class="keyword">implements</span> <span class="title">Element</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operationA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"具体元素A的操作。"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体元素B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementB</span> <span class="keyword">implements</span> <span class="title">Element</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operationB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"具体元素B的操作。"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象结构角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span></span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> List&lt;Element&gt; list=<span class="keyword">new</span> ArrayList&lt;Element&gt;();   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Iterator&lt;Element&gt; i=list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(i.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            ((Element) i.next()).accept(visitor);</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Element element)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        list.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Element element)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        list.remove(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题整理</title>
    <url>/2020/02/15/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="private的问题"><a href="#private的问题" class="headerlink" title="private的问题"></a>private的问题</h3><p>private修饰的方法属性可以通过反射访问，那么private的意义是什么？</p>
<p>简单来说，private并不是解决“安全”问题的。 安全是指不让代码被非法看到/访问。但是只要人能拿到代码，总会有办法去查看和改变代码。可以用SecurityManager来防止private被访问，但是任然有其他各种方式拿到java的bytecode，并做任意修改。比如有asm这样的lib，也有instrument api这种东西。c++这种语言还能通过指针跳过private</p>
<p>回答：1：private并不是保证安全性的关键字。 是对开发的一种约束，强调的是OOP的封装概念，</p>
<p>​            2：从外部对对象进行常规调用时，不能够看到清晰的类结构和属性。</p>
<h3 id="类初始化顺序"><a href="#类初始化顺序" class="headerlink" title="类初始化顺序"></a>类初始化顺序</h3><p>类的初始化顺序，我以前只知道先初始化基类在初始化派生类，忽略了代码块儿的问题，正确的顺序应该是</p>
<p>基类的静态：正确的顺序是</p>
<p>基类静态代码块，基类静态成员字段（并列优先级，按照代码中出现的先后顺序执行，且只有第一次加载时执行）——&gt;派生类静态代码块，派生类静态成员字段（并列优先级，按照代码中出现的先后顺序执行，且只有第一次加载时执行）——&gt;基类普通代码块，基类普通成员字段（并列优点级，按代码中出现先后顺序执行）——&gt;基类构造函数——&gt;派生类普通代码块，派生类普通成员字段（并列优点级，按代码中出现先后顺序执行）——&gt;派生类构造函数</p>
<p>基本上写个例子就可以测试出结果</p>
<h3 id="clone方法"><a href="#clone方法" class="headerlink" title="clone方法"></a>clone方法</h3><p>基本数据类型(char ,short,int,long,float,double,byte,boolean)在传递的时候是按值传递，对象类型是按引用传递，（java在new 语句之后返回的是对象的指引用）,实际过程中经常会遇见复制一个已有的对象A到另一个具有相同状态的对象B,而且对B的修改不影响A。实现clone方法的实体需要继承Cloneable接口。深拷贝和浅拷贝最根本的区别在于是否真正获取一个对象的复制实体，而不是引用。假设B复制了A，修改A的时候，看B是否发生变化：</p>
<p>如果B跟着也变了，说明是浅拷贝，拿人手短！（修改堆内存中的同一个值）</p>
<p>如果B没有改变，说明是深拷贝，自食其力！（修改堆内存中的不同的值）</p>
<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>反射及智能在运行时对类进行装载，能够增加程序的灵活性，反射主要用来得到一个对象所属的类，获取类的成员方法和变量，在运行时创建对象，调用对象的方法。java创建对象的方法  new,反射，clone,反序列化</p>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>在C++中有一个概念-函数指针，其中最重要的功能是函数回调，利用函数的回调函数来编写程序，传递一个函数的指针参数来调用下一个函数，java中没有指针的概念，但是可以通过接口和类实现相同 的功能。在接口参数接受一个interface参数，来执行回调方法。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象是将数据和对数据的操作方法集中放在一起，作为一个相互依赖的整体，即对象，对象通过接口与外部发生交流。</p>
<p>面向对象主要有三个特征，继承、封装、多态</p>
<p>封装是将数据和方法抽象成 类，在对自身的数据方法进行保护，可以把自己的数据和方法让可信的类或对象进行操作，对不可信的数据方法进行隐藏。</p>
<p>继承是一种联结类的层次模型，允许和鼓励类的重用，提供了明确的表达共性的方法。派生类可以从基类中获取继承的方法和变量 </p>
<p>多态 允许不同类的对象对统一消息做出响应，包含参数化多态和包含多态。</p>
<h3 id="多态的实现机制"><a href="#多态的实现机制" class="headerlink" title="多态的实现机制"></a>多态的实现机制</h3><p>编译时多态和运行时多态。编译时通过方法的重载实现，运行时多态是通过方法的覆盖，继承方法是重写</p>
<p>Java实现多态有三个必要条件：继承、重写、向上转型。</p>
<p>继承：在多态中必须存在有继承关系的子类和父类。</p>
<p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p>
<p>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程是指程序在运行过程中，能够执行代码的一个执行单元。进程是一段正在执行程序的抽象。 java中线程的状态：<em>就绪、运行、挂起、结束</em></p>
<h2 id="java-实现线程的方式"><a href="#java-实现线程的方式" class="headerlink" title="java 实现线程的方式"></a>java 实现线程的方式</h2><p>1：类继承Thread  2：实现Runnable接口  3.继承Callable<t>接口</t></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest3</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"有返回值的线程"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ExecutorService threadPool = Executors.newSingleThreadExecutor();</span><br><span class="line">            Future&lt;String&gt; future = threadPool.submit(<span class="keyword">new</span> ThreadTest3());</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="run-与start-方法的区别"><a href="#run-与start-方法的区别" class="headerlink" title="run()与start()方法的区别"></a>run()与start()方法的区别</h2><p>一般系统通过调用start()方法来启用一个线程，此时该线程处于就绪的状态，而非运行状态，此时这个线程可以被JVM调用，调用的时候在通过run()方法来完成实际的操作。方法结束后该线程终止。</p>
<p>如果直接调用run()方法，这会被当成普通函数调用，程序中仍然只有主线程。程序是同步的，达不到多线程的目的。</p>
<h2 id="多线程同步的方法"><a href="#多线程同步的方法" class="headerlink" title="多线程同步的方法"></a>多线程同步的方法</h2><p>在多线程环境中，访问数据是一个很危险的事情，很容易出现数据的安全问题。因此java提供了几种实现同步机制的方法。</p>
<h3 id="1synchronzied关键字"><a href="#1synchronzied关键字" class="headerlink" title="1synchronzied关键字"></a>1synchronzied关键字</h3><p>主要有两种用法 synchronzied方法和synchronzied代码块</p>
<p>java中synchronzied的实现与Monitor相关，java中的所有对象都拥有一个私有线程锁或则成为Monitor锁，Monitor中的Owner字段表明该对象是否被线程拥有Monitor record。</p>
<h3 id="notify-与wait-方法"><a href="#notify-与wait-方法" class="headerlink" title="notify()与wait()方法"></a>notify()与wait()方法</h3><p>synchronzied锁住某个对象或者资源的时候，线程A1在执行synchronzied代码，线程A2也在执行synchronzied代码，线程A2要等待A1执行完成之后才能执行，这种情况下就可以使用wait()和notif()。synchronzied在执行期间，可以使用wait()方法释放对象锁，进入等待状态，并可以调用notif()提醒其他等待的线程。fei</p>
<h3 id="2重入锁ReentrantLock"><a href="#2重入锁ReentrantLock" class="headerlink" title="2重入锁ReentrantLock"></a>2重入锁ReentrantLock</h3><p>jdk 5添加了Lock接口和她的实现类，Lock也可以用来实现同步。</p>
<p>Lock()方法。以阻塞的方式获取锁，如果获取到锁，立刻返回，没有获取锁则继续等待。</p>
<p>tryLock()非阻塞的方式获取锁，获取到锁立刻返回true,未获取到锁返回false</p>
<p>lockInterruptibly() 如果获取到了锁，立刻返回，没有获取到锁，当前线程处于休眠状态，直到获取到锁，或者当前线程被别的线程中断。</p>
<h3 id="sleep-和wait-方法的区别"><a href="#sleep-和wait-方法的区别" class="headerlink" title="sleep()和wait()方法的区别"></a>sleep()和wait()方法的区别</h3><p>sleep()方法是Thread类的静态方法，是线程用来控制自身的，他会使线程暂停一段时间，等时间一到，该线程会自动苏醒。而wwait()方法是Object类的方法，这个方法会使拥有该对象锁的进程等待，知道其他线程调用notify()方法来唤醒</p>
<p>对锁的处理机制不同：sleep()方法的主要作用是线程暂停一段时间，时间到了会自动恢复，所以sleep()不会释放锁，而wait()主要应用于线程间的通信，当线程调用wait()方法后，线程会释放掉他拥有的锁。</p>
<h2 id="终止线程的方法"><a href="#终止线程的方法" class="headerlink" title="终止线程的方法"></a>终止线程的方法</h2><p>java语言中可以使用stop()和suspend()方法来终止线程的执行。stop()方法会释放已经锁定的所有监视资源。</p>
<p>而suspend()方法不会释放锁，这就会导致，如果使用suspend()挂起一个线程，那么在锁恢复之前不会被释放，这就很容易导致死锁。所以Java语言不建议上述两种方法来终止线程。一般建议是让线程自行结束进入Dead，即执行完Run()方法。提供某种方式能使线程跑完run()方法。例如可以通过interrupt()等异常</p>
<h2 id="synchronized和lock"><a href="#synchronized和lock" class="headerlink" title="synchronized和lock"></a>synchronized和lock</h2><p>用法不同：在需要同步的对象中加入synchronized控制，既可以加在方法上，也可以加在代码块儿中,而Lock需要显示的指定起始位置和结束位置。</p>
<p>性能不同：synchronized在资源竞争不激烈的时候，性能优于ReetrantLock,竞争激烈的时候，synchronized的性能下降的非常快，而ReetrantLock的性能基本保持不变</p>
<p>锁机制不同：synchronized获取锁和释放都在块结构中。获取多个锁时，必须以相反的顺序释放，而且是自动释放，而Lock需要开发人员手动释放，一般在finally里卖弄释放，否则可能会引起死锁 的问题。</p>
<p>当一个线程进入了synchronized方法里面，其他线程能否访问其他方法取决于这个方法。如果访问的其他方法是非synchronized的，其他线程可以访问。如果其他方法是静态的synchronized方法，静态synchronized方法仍然可以被调用。</p>
<h2 id="join-方法的作用"><a href="#join-方法的作用" class="headerlink" title="join()方法的作用"></a>join()方法的作用</h2><p>join()方法是让调用该方法的线程在执行完run()方法滞后，再执行join()方法，主要用于线程同步。或者使用该线程的join(2000)方法来等待该线程，设置等待时间。</p>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h1 id="虚拟机（JVM）"><a href="#虚拟机（JVM）" class="headerlink" title="虚拟机（JVM）"></a>虚拟机（JVM）</h1><h2 id="方法区和永久区的理解"><a href="#方法区和永久区的理解" class="headerlink" title="方法区和永久区的理解"></a>方法区和永久区的理解</h2><h1 id="spring-IOC和AOP"><a href="#spring-IOC和AOP" class="headerlink" title="spring IOC和AOP"></a>spring IOC和AOP</h1><p>先解释一下IOC和AOP, </p>
<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>许多应用都是通过彼此间的相互合作来实现业务逻辑的，如类A要调用类B的方法，以前我们都是在类A中，通过自身<strong><em>new</em></strong>一个类B，然后在调用类B的方法，现在我们把new类B的事情交给spring来做，在我们调用的时候，容器会为我们实例化。 IOC容器的初始化过程资源定位，即定义bean的xml——-》载入——–》IOC容器注册，注册beanDefinition,现在的常用方式是基于注解，bean的创建方式是通过<strong>工厂模式</strong>，数据通过<strong>反射</strong>的方式注入</p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p> 面向切面编程，在我们的应用中，经常需要做一些事情，但是这些事情与核心业务无关，比如，要记录所有update*方法的执行时间时间，操作人等等信息。AOP的实现原理就代理方式 有两只，动态代理和静态代理</p>
]]></content>
      <categories>
        <category>java面试</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
