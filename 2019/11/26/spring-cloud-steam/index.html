<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="stream,spring cloud,">










<meta name="description" content="我们通过简单的配置和注解就能实现向RabbitMQ中生产和消费消息。实际上我们使用的对RabbitMQ的starter就是通过Spring Cloud Stream中对RabbitMQ的支持来实现的。下面我们就通过本文来了解一下Spring Cloud Stream。   Spring Cloud Stream是一个用来为微服务应用构建消息驱动能力的框架。它可以基于Spring Boot来创建独">
<meta name="keywords" content="stream,spring cloud">
<meta property="og:type" content="article">
<meta property="og:title" content="spring-cloud steam">
<meta property="og:url" content="http://yoursite.com/2019/11/26/spring-cloud-steam/index.html">
<meta property="og:site_name" content="放空">
<meta property="og:description" content="我们通过简单的配置和注解就能实现向RabbitMQ中生产和消费消息。实际上我们使用的对RabbitMQ的starter就是通过Spring Cloud Stream中对RabbitMQ的支持来实现的。下面我们就通过本文来了解一下Spring Cloud Stream。   Spring Cloud Stream是一个用来为微服务应用构建消息驱动能力的框架。它可以基于Spring Boot来创建独">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/11/26/spring-cloud-steam/rabbitMQ-start.png">
<meta property="og:image" content="http://yoursite.com/2019/11/26/spring-cloud-steam/rabbitMQ-connect.png">
<meta property="og:image" content="http://yoursite.com/2019/11/26/spring-cloud-steam/rabbitMQ-send.png">
<meta property="og:image" content="http://yoursite.com/2019/11/26/spring-cloud-steam/rabbitMQ-receive.png">
<meta property="og:image" content="http://yoursite.com/2019/11/26/spring-cloud-steam/rabbitMQ-customer.png">
<meta property="og:updated_time" content="2019-12-01T09:21:00.427Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="spring-cloud steam">
<meta name="twitter:description" content="我们通过简单的配置和注解就能实现向RabbitMQ中生产和消费消息。实际上我们使用的对RabbitMQ的starter就是通过Spring Cloud Stream中对RabbitMQ的支持来实现的。下面我们就通过本文来了解一下Spring Cloud Stream。   Spring Cloud Stream是一个用来为微服务应用构建消息驱动能力的框架。它可以基于Spring Boot来创建独">
<meta name="twitter:image" content="http://yoursite.com/2019/11/26/spring-cloud-steam/rabbitMQ-start.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/11/26/spring-cloud-steam/">





  <title>spring-cloud steam | 放空</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
	<a href="https://github.com/pignum1/pignum1.github.io.git"><img style="position: absolute; top: 0; right: 0;border: 0;" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_darkblue_121621.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">放空</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-categories" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/26/spring-cloud-steam/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wei xy">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/sliver.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="放空">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">spring-cloud steam</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-26T21:23:17+08:00">
                2019-11-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring-cloud/" itemprop="url" rel="index">
                    <span itemprop="name">spring cloud</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p> 我们通过简单的配置和注解就能实现向RabbitMQ中生产和消费消息。实际上我们使用的对RabbitMQ的starter就是通过Spring Cloud Stream中对RabbitMQ的支持来实现的。下面我们就通过本文来了解一下Spring Cloud Stream。 </p>
<p> Spring Cloud Stream是一个用来为微服务应用构建消息驱动能力的框架。它可以基于Spring Boot来创建独立的、可用于生产的Spring应用程序。它通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动的微服务应用。Spring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，并且引入了发布-订阅、消费组以及消息分区这三个核心概念。简单的说，Spring Cloud Stream本质上就是整合了Spring Boot和Spring Integration，实现了一套轻量级的消息驱动的微服务框架。通过使用Spring Cloud Stream，可以有效地简化开发人员对消息中间件的使用复杂度，让系统开发人员可以有更多的精力关注于核心业务逻辑的处理。由于Spring Cloud Stream基于Spring Boot实现，所以它秉承了Spring Boot的优点，实现了自动化配置的功能帮忙我们可以快速的上手使用，但是目前为止Spring Cloud Stream只支持下面两个著名的消息中间件的自动化配置： </p>
<ul>
<li><code>RabbitMQ</code></li>
<li><code>Kafka</code></li>
</ul>
<h1 id="构建一个Spring-Cloud-Stream消费者"><a href="#构建一个Spring-Cloud-Stream消费者" class="headerlink" title="构建一个Spring Cloud Stream消费者"></a>构建一个Spring Cloud Stream消费者</h1><p>创建一个消费者 stream-hello </p>
<p>添加 Spring Cloud Stream对RabbitMQ的支持，</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rabbit -steam依赖</span></span><br><span class="line">	compile <span class="string">group:</span> <span class="string">'org.springframework.cloud'</span>, <span class="string">name:</span> <span class="string">'spring-cloud-starter-stream-rabbit'</span>, <span class="string">version:</span> <span class="string">'2.1.3.RELEASE'</span></span><br></pre></td></tr></table></figure>
<p> 创建用于接收来自RabbitMQ消息的消费者<code>SinkReceiver</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(Sink<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SinkReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SinkReceiver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener</span>(Sink.INPUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Object payload)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Received: "</span> + payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>@EnableBinding</strong> :实现了对消息通道（channel）的绑定 </p>
<p> <strong>@EnableBinding (Sink.class)</strong> ：绑定了Sink接口，该接口是Spring cloud Stream中默认实现的对输入消息通道绑定的定义 </p>
<p> 从代码中可以看到通过注解的方式绑定了一个名字为input的通道  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sink</span> </span>&#123;</span><br><span class="line">    String INPUT = <span class="string">"input"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Input</span>(<span class="string">"input"</span>)</span><br><span class="line">    <span class="function">SubscribableChannel <span class="title">input</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然有输入就会有输出 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    String OUTPUT = <span class="string">"output"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Output</span>(<span class="string">"output"</span>)</span><br><span class="line">    <span class="function">MessageChannel <span class="title">output</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 当需要绑定多个接口的时候，只需要用逗号隔开，添加类即可 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(&#123;Sink<span class="class">.<span class="keyword">class</span>,<span class="title">Source</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SinkReceiver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger=LoggerFactory.getLogger(StreamHelloApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@StreamListener</span>(Sink.INPUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Object payload)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Receive---------------------------------------:"</span>+payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@StreamListener</strong>将方法作为消息的监听器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@StreamListener</span>(Sink.INPUT)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Object payload)</span> </span>&#123;</span><br><span class="line">     logger.info(<span class="string">"Received: "</span> + payload);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>启动类与正常相同，启动服务并开启rabbitMQ的本地服务，默认的配置就是请求本地的rabbitMQ，不需要额外配置，服务启动后，控制台上打印出</p>
<p><img src="/2019/11/26/spring-cloud-steam/rabbitMQ-start.png" alt></p>
<p>这个时候点开rabbitMQ的控制台，在页面上输入 <a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a></p>
<p><img src="/2019/11/26/spring-cloud-steam/rabbitMQ-connect.png" alt></p>
<p>点击连接信息并查看消息，输入“send message” 并点击publish</p>
<p><img src="/2019/11/26/spring-cloud-steam/rabbitMQ-send.png" alt></p>
<p>此时这个控制台打印出</p>
<p><img src="/2019/11/26/spring-cloud-steam/rabbitMQ-receive.png" alt></p>
<p>完成上示简单的示例后， 引入<code>spring-cloud-starter-stream-rabbit</code>依赖，该依赖包是Spring Cloud Stream对RabbitMQ支持的封装，其中包含了对RabbitMQ的自动化配置等内容。从下面它定义的依赖关系中，我们还可以知道它等价于<code>spring-cloud-stream-binder-rabbit</code>依赖。 </p>
<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="绑定器"><a href="#绑定器" class="headerlink" title="绑定器"></a>绑定器</h2><p> 这里的Binder是指Stream的Binde,如果没有Binder,那么spring boot 在使用消息中间件的时候，由于每个消息中间件都不太相同，一旦切换将会使代码重构。而使用了Binder之后，最终暴露给用户的只有Channel </p>
<h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h2><p> Stream的消息通讯方式遵循了发布-订阅模式，当一条消息发送到消息中间件后，它会通过共享的Topic主题进行广播，消息消费者在订阅的主题中收到它并触发相关事务。对于Topic只是一个抽象概念，在MQ中是Exchange,在Kafaka中则是Topic </p>
<p>相对于点对点队列实现的消息通信来说，Spring Cloud Stream 采用的发布-订阅模式可以有效降低消息生产者与消费者之间的耦合。当需要对同一类消息增加一种处理方式时，只需要增加一个应用程序并将输入通道绑定到既有的Topic中就可以实现功能的扩展，而不需要改变原来已经实现的任何内容</p>
<h2 id="消费组"><a href="#消费组" class="headerlink" title="消费组"></a>消费组</h2><p>由于我们的每一个微服务应用都会有多个实例，但是我们只希望消息只被其中一个实例消费一次，所以有了消费组的概念。当多个实例在同一组的时候，也就是设置spring.cloud.stream.bindings.input.group属性的时候，那么消息只会被其中一个实例消费一次。默认情况下，Stream默认分配了一个独立的匿名消费组。所以，如果不是必须像刷新配置一样，最好是指定消费组。</p>
<h2 id="消息分区"><a href="#消息分区" class="headerlink" title="消息分区"></a>消息分区</h2><p>指定某一个实例消费信息。Stream为分区提供了抽象实现，所以它不在乎消息中间件是否有分区功能。</p>
<h1 id="使用详解"><a href="#使用详解" class="headerlink" title="使用详解"></a>使用详解</h1><h2 id="开启绑定功能-EnableBinding"><a href="#开启绑定功能-EnableBinding" class="headerlink" title="开启绑定功能@EnableBinding"></a>开启绑定功能@EnableBinding</h2><p>它只有唯一一个属性：value。上面已经介绍过，由于该注解已经被@Import了BindingBeansRegistrar实现，所以在加载了基本配置内容之后，它会回调来读取value中的类，以创建消息通道的绑定。另外，由于value是一个Class类型的数组，所以我们可以通过value属性一次性指定多个关于消息通道的配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;BindingServiceConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">BindingBeansRegistrar</span>.<span class="title">class</span>, <span class="title">BinderFactoryConfiguration</span>.<span class="title">class</span>, <span class="title">SpelExpressionConverterConfiguration</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">EnableIntegration</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableBinding</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="绑定消息通道"><a href="#绑定消息通道" class="headerlink" title="绑定消息通道"></a>绑定消息通道</h2><p> value里面填的接口对象，里面有消息通道的定义，通过接口对象进行通道绑定 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(&#123;Sink<span class="class">.<span class="keyword">class</span>,<span class="title">Source</span>.<span class="title">class</span>&#125;)</span></span><br></pre></td></tr></table></figure>
<p>其中Sink、Source分别是默认的输入、输出管道</p>
<p> 也可以通过继承直接定义输入和输出通道  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span> <span class="keyword">extends</span> <span class="title">Source</span>, <span class="title">Sink</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置相同的主题Topic </p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.stream.bindings.input.destination</span>=<span class="string">sink-channel</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.output.destination</span>=<span class="string">sink-channel</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.input-1.destination</span>=<span class="string">sink-channel</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.output-1.destination</span>=<span class="string">sink-channel</span></span><br></pre></td></tr></table></figure>
<p>创建消息生产者</p>
<p>通过结合 @EnableBinding结合@InboundChannelAdapter注解实现消息的发送 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@EnableBinding</span>(value = &#123;Source<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SinkSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Source source;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(SinkSender<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicInteger NUM = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InboundChannelAdapter</span>(value = Source.OUTPUT,poller = <span class="meta">@Poller</span>(fixedRate = <span class="string">"3000"</span>))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">timerMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">        log.info(NUM.getAndIncrement() + <span class="string">" Send message : "</span> + format);</span><br><span class="line">        <span class="keyword">return</span> format;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        source.output().send(org.springframework.integration.support.MessageBuilder.withPayload(message).build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动服务，控制台打印出</p>
<p><img src="/2019/11/26/spring-cloud-steam/rabbitMQ-customer.png" alt></p>
<h2 id="消息的生产与消费"><a href="#消息的生产与消费" class="headerlink" title="消息的生产与消费"></a>消息的生产与消费</h2><p> 由于Stream 是由 Spring Integration 构建起来的， 支持Integration原生实现 所以可以使用Integration提供相同服务 </p>
<p> @ServiceActivator类比于@StreanListener,实现了对Sink.INPUT通道的监听处理，而该通道绑定了名为input的主题，这个主题就是我们在配置文件上配置的，必须确保input和output为同一个主题Topic. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">@StreamListener(SinkSender.INPUT)</span><br><span class="line">public void receives(Object payload)&#123;</span><br><span class="line">    logger.info(&quot;Receive---------------------------------------:&quot;+payload.toString());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@ServiceActivator(inputChannel = SinkSender.INPUT)</span><br><span class="line">public void receivess(Object payload)&#123;</span><br><span class="line">    logger.info(&quot;Receive---------------------------------------:&quot;+payload.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息发送和消息接收要在同一个 同一个主题Topic </p>
<p> 共用一个主题Topic，构成了一组生产者与消费者 。 @InboundChannelAdapter是对通道的输出绑定，同时使用Poller轮询的方式执行 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">    @InboundChannelAdapter(value=Source.OUTPUT,poller = @Poller(fixedDelay = &quot;2000&quot;))</span><br><span class="line">    public MessageSource&lt;Date&gt; timerMessageSource()&#123;</span><br><span class="line">        return ()-&gt;new GenericMessage&lt;&gt;(new Date());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 消息转换  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transformer</span>(inputChannel = SinkSender.INPUT,outputChannel = SinkSender.OUTPUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Date message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="StreamListener详解"><a href="#StreamListener详解" class="headerlink" title="@StreamListener详解"></a>@StreamListener详解</h2><p> @StreamListener虽然同@ServiceActivator功能相似，但是功能更加强大 </p>
<p>上文中的注解可以替换为@ServiceActivator(inputChannel =Sink.INPUT)</p>
<p>消息转换 </p>
<p>例如将json字符串转换成java对象 </p>
<p> 使用@Transformer注解实现，通过上面的例子，我们可以通过代码的方式去实现消息的转化。 </p>
<p> 使用@StreamListener注解实现,只需要指定传输过来的数据格式即可，因为Stream已经有了内置的消息转换机制，我们无需重复编写。所以说对于此注解来说，只是多写了一个配置信息而已。 </p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.stream.bindings.input-1.content-type</span>=<span class="string">application/json</span></span><br></pre></td></tr></table></figure>
<h3 id="消息反馈"><a href="#消息反馈" class="headerlink" title="消息反馈"></a>消息反馈</h3><p> 处理完消息之后，需要反馈一个消息给对方，这时候可以通过@SendTo注解来指定返回内容的输出通道 ， 使用sendto注解即可搞定.对于配置信息，要确保绑定的topic也就是destination是同一个在可以实现订阅，因为通道名字会默认为交换机exchange也就是topic的名字，所以在测试的时候例如在一个应用里面要记得配置相同的交换机。 </p>
<p>修改receive方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@StreamListener</span>(Sink.INPUT)</span><br><span class="line">  <span class="meta">@SendTo</span>(Source.OUTPUT)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">receives</span><span class="params">(Object payload)</span></span>&#123;</span><br><span class="line">      logger.info(<span class="string">"Receive---------------------------------------:"</span>+payload.toString());</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"From llg Channe Return"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>除了 @SendTo(Source.OUTPUT)，也可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@ServiceActivator(inputChannel = Sink.INPUT,outputChannel = Source.OUTPUT)</span><br><span class="line">    public Object receivess(Object payload)&#123;</span><br><span class="line">        logger.info(&quot;Receive---------------------------------------:&quot;+payload.toString());</span><br><span class="line">        return &quot;返回&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费组-1"><a href="#消费组-1" class="headerlink" title="消费组"></a>消费组</h3><p>消费组的概念上文说过，其实就是如果出现需要让服务中多个实例的其中一个消费消息的话，就需要设置消费组进行隔离标记。</p>
<p>不难理解，最主要还是因为是订阅模式，所以会统一发送消息，并且默认组名是匿名组，所以也就自然而然的对服务的所有实例发送了，下面我们来设置消费组。</p>
<p>可以看到配置一个组名Service ,那么开启多个实例的时候自然而然的所有实例的组名都是Service.所以消费组的意思就是把一个服务按一个组划分，每次只传递一个消息到这个组来，再随机给其中的一个实例消费。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.input.group</span>=<span class="string">Service</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.input.destination</span>=<span class="string">input</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.output.destination</span>=<span class="string">input</span></span><br></pre></td></tr></table></figure>
<h3 id="消息分区-1"><a href="#消息分区-1" class="headerlink" title="消息分区"></a>消息分区</h3><p> 为了将某些特定的消息给特定的实例消费，所以需要设置消息分区 </p>
<p>首先需要在消费者应用配置信息</p>
<p>spring.cloud.stream.bindings.input.consumer.partitioned=true :开启消费者分区功能<br>spring.cloud.stream.instance-count=2 ：指定了消费者的实例总数<br>spring.cloud.stream.instance-index=0 ：索引号，从0开始。必须每个实例按索引为0开始递增</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.input.group</span>=<span class="string">Service</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.input.destination</span>=<span class="string">input</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.output.destination</span>=<span class="string">input</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.input.consumer.partitioned</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.cloud.stream.instance-count</span>=<span class="string">2</span></span><br><span class="line"><span class="meta">spring.cloud.stream.instance-index</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure>
<p> 接着配置生产者 </p>
<p>spring.cloud.stream.bindings.output.producer.partition-key-expression=payload   指定了分区键的表达式规则</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.stream.bindings.output.producer.partition-count</span>=<span class="string">2  指定了消息分区的数量</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.output.producer.partition-key-expression</span>=<span class="string">payload</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.output.producer.partition-count</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure>
<h3 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h3><p>类似于springmvc的消息转换器等等，Stream允许使用sprinc.cloud.stream.bindings.<channelname>.content-type 属性以声明式的配置方式为绑定的输入和输出通道设置消息内容的类型。</channelname></p>
<p>json——pojo</p>
<p>json——org.springframework.tuple.Tuple</p>
<p>object——-byte[]  传输序列化数据</p>
<p>string——–byte[]</p>
<p>object—–纯文本</p>
<h1 id="绑定器详解"><a href="#绑定器详解" class="headerlink" title="绑定器详解"></a>绑定器详解</h1><p> 最为关键的接口是Binder接口，它是用来将输入和输出连接到外部中间件的抽象。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Binder</span>&lt;<span class="title">T</span>, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">ConsumerProperties</span>, <span class="title">P</span> <span class="keyword">extends</span> <span class="title">ProducerProperties</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Binding&lt;T&gt; <span class="title">bindConsumer</span><span class="params">(String var1, String var2, T var3, C var4)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Binding&lt;T&gt; <span class="title">bindProducer</span><span class="params">(String var1, T var2, P var3)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用程序对输入和输出通道进行绑定的时候，实际上就是通过该接口的实现来完成的。</p>
<p>向消息通道发送数据的生产者调用bindProducer方法来绑定输出通道时，第一个参数代表了发往消息中间件的目标名称，第二个参数代表了发送消息的本地通道实例，第三个参数是用来创建通道时使用的属性配置（比如分区键的表达式等）。<br>从消息通道接受数据的消费者调用bindConsumer方法来绑定输入通道时，第一个参数代表了接受消息中间件的目标名称，第二个参数代表了消费组的名称（如果多个消费者实例使用相同的组名，则消息将对这些消费者实例实现负载均衡，每个生产者发出的消息只会被组内一个消费者实例接受接受和处理），第三个参数代表了接受消息的本地通道实例，第四个参数是用来创建通道时使用的属性配置。<br>一个典型的Binder绑定器实现一般包含以下内容。</p>
<p>一个实现Binder接口的类<br>一个Spring配置加载类，用来创建连接消息中间件的基础结构使用的实例。<br>一个或多个能够在classpath下的META-INF/spring.binders路径找到的绑定器定义文件。比如我们可以再spring-cloud-starter-stream-rabbit中找到该文件，该文件中存储了当前绑定器要使用的自动化配置类的路径：</p>
<h1 id="自动化配置"><a href="#自动化配置" class="headerlink" title="自动化配置"></a>自动化配置</h1><p>Spring Cloud Stream 通过绑定器SPI的实现应用程序逻辑上的输入输出通道连接到物理上的消息中间件。为了适应多个消息中间件的差异，所以需要实现各自的绑定器</p>
<p>下面的依赖包括了rabbitmq的binder依赖</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>多绑定器配置<br>就是说可以同时用多种消息中间件</p>
<p>首先如果我们需要默认为某种绑定器的时候，比如默认为rabbit的绑定器</p>
<p>spring.cloud.stream.default-binder=rabbit<br>对于一些少数的消息通道需要单独设置绑定器,通过上面的配置我们可以发现我们是直接写rabbit和kafka，但是这不是代表名字，而是某个配置文件的别名。</p>
<p>spring.cloud.stream.bindings.input.binder=kafka<br>对需要使用多个消息中间件，例如消息输入通道和消息输出通道使用不同的消息中间件.显示指定配置别名后会自动禁用默认的绑定器配置，所以我们需要使用spring.cloud.stream.binders.<configurationname>属性来进行设置</configurationname></p>
<p>spring.cloud.stream.bindings.input.binder=rabbit1<br>spring.cloud.stream.bindings.output.binder=rabbit2</p>
<p>spring.cloud.stream.binders.rabbit1.type=rabbit<br>spring.cloud.stream.binders.rabbit1.environment.spring.rabbitmq.host=localhost<br>spring.cloud.stream.binders.rabbit1.environment.spring.rabbitmq.port=5672<br>spring.cloud.stream.binders.rabbit1.environment.spring.rabbitmq.username=guest<br>spring.cloud.stream.binders.rabbit1.environment.spring.rabbitmq.password=guest</p>
<p>spring.cloud.stream.binders.rabbit2.type=rabbit<br>spring.cloud.stream.binders.rabbit2.environment.spring.rabbitmq.host=192.168.88.8<br>spring.cloud.stream.binders.rabbit2.environment.spring.rabbitmq.port=5672<br>spring.cloud.stream.binders.rabbit2.environment.spring.rabbitmq.username=guest<br>spring.cloud.stream.binders.rabbit2.environment.spring.rabbitmq.password=guest<br>以下是对绑定器的一些属性配置 </p>
<p>spring.cloud.stream.binders.<configurationname>.type 指定了绑定器类型<br>spring.cloud.stream.binders.<configurationname>.environment 用来设置各种绑定器属性<br>spring.cloud.stream.binders.<configurationname>.inheritEnvironment=true 当前绑定器是否继承应用程序自身额环境配置<br>spring.cloud.stream.binders.<configurationname>.defaultCandidate=true 设置当前绑定器配置是否被视为默认绑定器的候选项  </configurationname></configurationname></configurationname></configurationname></p>
<h1 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h1><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>下面是spring cloud stream 应用级别的通用基础属性，这些属性都以spring.cloud.stream 为前缀</p>
<p>instanceCount=1 应用程序部署的实例数量。当使用Kafka的时候需要设置分区<br>instanceIndex  应用程序实例的索引，该值从0开始，最大值设置为-1.当使用分区和kafka的时候使用<br>dynamicDestinations 动态绑定的目标列表，该列表默认为空，当设置了具体列表之后，只有列表中的目标才能发现<br>defaultBinder 默认绑定器配置，在应用程序中有多个绑定器时使用<br>绑定通道配置<br>绑定通道分别为输入通道和输出通道，所以在绑定通道的配置中包含了三类面向不同通道类型的配置：通用配置、消费者配置、生产者配置</p>
<h2 id="通用配置"><a href="#通用配置" class="headerlink" title="通用配置"></a>通用配置</h2><p>下面省略spring.cloud.stream.bindings.<channelname>.前缀</channelname></p>
<p>destination  配置Topic名称，也就是exchange名称 ，如果是消费者可以配置多个并且用逗号隔开<br>group  消费组<br>contentType 消息类型<br>binder 指定那个具体的绑定器</p>
<h2 id="消费者配置"><a href="#消费者配置" class="headerlink" title="消费者配置"></a>消费者配置</h2><p>仅对消费者有效，下面省略spring.cloud.stream.bindings.<channelname>.consumer 前缀</channelname></p>
<p>concurrency 输入通道消费者的并发数，默认为1<br>partitioned 是否采用分区，默认false<br>headerMode 当设置为raw的时候将禁用对消息头的解析。该属性只有在使用不支持消息头功能的中间件时有效，因为Spring Cloud Stream 默认会解析嵌入的头部信息 ，默认值embeddedHeaders<br>maxAttempts 对输入通道消息处理的最大重试次数，默认值3<br>backOffInitialInterval  重试消息处理的初始间隔时间 ，默认1000<br>backOffMaxInterval 重试消息处理的最大间隔时间，默认为10000<br>backOffMultiplier 重试消息处理时间间隔的递增乘数 2.0</p>
<h2 id="生产者配置"><a href="#生产者配置" class="headerlink" title="生产者配置"></a>生产者配置</h2><p>仅对生产者者有效，下面省略spring.cloud.stream.bindings.<channelname>.producer 前缀</channelname></p>
<p>partitionKeyExpression 配置输出通道数据分区键的SpEL表达式。当设置该属性后，将对绑定通道的输出数据进行分区处理。同时，partitionCount参数必须大于1才能生效。<br>partitionKeyExtractorClass 配置分区键提取策略接口PartitionKeyExtractionStrategy 的实现。当设置该属性之后，将对当前绑定通道的输出数据进行分区处理。同时，partitionCount参数必须大于1才能生效，该参数与partitionKeyExpression互斥，不能同时使用<br>partitionSelectorClass 该参数用来指定分区选择器的接口PartitionSelectorStrategy的实现，如果两者都没设置，那么默认计算规则为hashCode(key)%partitionCount，这里的key根据上面的配置得到<br>partitionSelectorExpression  该参数用来设置自定义分区的选择器的SpEL表达式<br>headerMode  当设置为raw的时候将禁用对消息头的解析。该属性只有在使用不支持消息头功能的中间件时有效，因为Spring Cloud Stream 默认会解析嵌入的头部信息 ，默认值embeddedHeaders<br>绑定器配置<br>由于Stream只实现了kafka和rabbitmq的实现，所以下面只讲这两种实现</p>
<h2 id="RabbitMQ配置"><a href="#RabbitMQ配置" class="headerlink" title="RabbitMQ配置"></a>RabbitMQ配置</h2><h3 id="通用配置-1"><a href="#通用配置-1" class="headerlink" title="通用配置"></a>通用配置</h3><p>由于rabbitmq默认使用了spring boot 的ConnectFactory，所以Rabbitmq绑定器支持在Spring boot 中的配置选项，他们以spring.rabbitmq为前缀</p>
<p>在Spring Cloud Stream 对RabbitMQ时下的绑定器中，以spring.cloud.stream.rabbit.binder 为前缀</p>
<p>adminAddresses 该参数用来配置RabbitMQ管理插件的URL,当需要配置多个时用逗号分隔。该参数只有在nodes参数包含多个时使用，并且这里配置的内容必须在spring.rabbitmq.address 中存在<br>nodes 该参数用来配置RabbitMQ的节点名称，用逗号隔开，并且这里配置的内容必须在spring.rabbitmq.address 中存在。<br>compressinLevel 绑定通道的压缩级别，它的具体可选值及含义可见java.util.zip.Deflater的定义</p>
<h3 id="消费者配置-1"><a href="#消费者配置-1" class="headerlink" title="消费者配置"></a>消费者配置</h3><p>仅对消费者有效，下面省略spring.cloud.stream.rabbit.bindings.<channelname>.consumer 前缀</channelname></p>
<p>acknowledgeMode  用来设置消息的确认模式，可写：NONE、MANUAL、AUTO，默认值为AUTO<br>autoBindDlq 用来设置是否自动声明DLQ（queue），并绑定到DLX(exchange)上<br>durableSubScription 用来设置订阅是否被持久化，该参数被设置时有效。默认为true<br>maxConcurrency 用来设置消费者的最大并发数 ，默认为1<br>prefetch 用来设置预取数量，它表示在一次会话中从消息中间件中获取的消息数量，该值越大消息处理越快，但是会导致非顺序处理的风险。默认为1<br>prefix 用来设置统一的目标和队列名称前缀<br>recoveryInterval 用来设置恢复连接的尝试时间间隔，默认为5000<br>requeueRejected 用来设置消息传递失败时重传，默认为true<br>requestHeaderPatterns 用来设置需要被传递的请求头信息<br>replyHeaderPatterns 用来设置需要被传递的响应头信息<br>republishToDlq 默认情况下，消息在重试也失败之后会被拒绝。如果DLQ被配置的时候，RabbitMQ会将失败的消息路由到DLQ中。如果该参数被设置为true ,总线会将失败的消息附加一些头信息（包括异常信息，引入失败的跟踪堆栈）之后重新发布到DLQ中<br>transacted 用来设置是否启用channeltransacted 是否在消息中使用事务 ，默认false<br>txSize 用来设置transaction-size 的数量，当acknowledgeMode被设置为AUTO时候，容器会在处理txSize 数目消息之后才开始应答，默认为1</p>
<h3 id="生产者配置-1"><a href="#生产者配置-1" class="headerlink" title="生产者配置"></a>生产者配置</h3><p>仅对生产者者有效，下面省略spring.cloud.stream.rabbit.bindings.<channelname>.producer 前缀</channelname></p>
<p>autoBindDlq 用来设置是否自动声明DLQ（queue），并绑定到DLX(exchange)上<br>batchindEnabled 是否启用消息批处理 ，默认false<br>batchSize 当批处理开启时，用在设置缓存的批处理消息数量，默认为100<br>batchBufferLimit 批处理缓存限制 ，默认为10000<br>batchTimeout 批处理超时时间，默认5000<br>compress 消息发送时是否启用压缩 ，默认false<br>deliveryMode 消息发送模式 ,默认PERSISTENT<br>prefix 用来设置统一的目标前缀<br>requestHeaderPatterns 用来设置需要被传递的请求头信息<br>replyHeaderPatterns 用来设置需要被传递的响应头信息 </p>
<h2 id="KafKa配置"><a href="#KafKa配置" class="headerlink" title="KafKa配置"></a>KafKa配置</h2><h3 id="通用配置-2"><a href="#通用配置-2" class="headerlink" title="通用配置"></a>通用配置</h3><p>在Spring Cloud Stream 对kafka时下的绑定器中，以spring.cloud.stream.kafka.binder 为前缀</p>
<p>brokers =localhost：Kafka绑定器连接的消息中间件列表。需要配置多个时用逗号分隔，每个地址可以是单独的host,也可以是host:port 的形式<br>defaultBrokerPort=9092 ：用来设置默认的消息中间件端口号。当brokers中的配置地址没有包含端口信息时，将使用该参数配置的默认端口进行连接<br>zkNodes=localhost ：kakfa绑定器使用的Zookeeper端口号，当brokers中的配置地址没有包含端口信息时，将使用该参数配置的默认端口进行配置<br>defaultZKport=2181 : 用来设置默认的Zookeeper端口号。当zKNodes 中的配置地址没有包含端口信息时，将使用该参数配置的默认端口进行连接<br>headers : 用来设置会被传输的自定义头信息<br>offsetUpdateCountTImeout =10000: 用来设置offset的更新频率，以毫秒为单位，如果设置为0则忽略<br>offsetUpdateCount=0 : 用来设置offset以次数表示的更新频率，如果为0则忽略，该参数与offsetUpdateCountTImeout互斥<br>requireAcks =1：用来设置确认消息的数量<br>minParttitionCount 该参数仅在设置了autoCreateTopics和autoAddParttions时生效，用来设置该绑定器所使用主题的全局分区最小数量。如果当生产者的parttionCount的参数或instanceCount*concurrency 设置大于该参数配置时，该参数值将被覆盖<br>replicationFactor=1 当autoCreateTopics 参数为true时候，用来配置自动创建主题的副本数量<br>autoCreateTopics=true 该参数默认为true,绑定器会自动地创建新主题。如果设置为false,那么绑定器将使用已经配置的主题，但是在这种情况下，如果需要使用的主题不存在，绑定器会启动失败<br>huautoAddPartition=false 该参数默认为false,绑定器会根据已经配置的主题分区来实现，如果目标主题的分区数小于预期值，那么绑定器会启动失败。如果该参数设置为true,绑定器将在需要的时候自动创建新的分区<br>socketBufferSize =2097152 该参数用来设置KafKa 的Socket的缓存大小</p>
<h3 id="消费者配置-2"><a href="#消费者配置-2" class="headerlink" title="消费者配置"></a>消费者配置</h3><p>仅对消费者有效，下面省略spring.cloud.stream.kafka.bindings.<channelname>.consumer 前缀</channelname></p>
<p>autoCommitOffset=true ：用来设置是否在处理消息时自动提交offset。如果设置为false,在消息头 中会加入ACK头消息以实现延迟确认。<br>autoCommitOnError ：该参数只有在autoCommitOffset设置为true时才有效。当设置为false的时候，引起错误消息不会自动提交offset,仅提交成功消息的offset。如果设置为true,不论消息是否成功，都会自动提交。当不设置该值时，它实际上具有与enabledDlq相同配置<br>reconveryInterval =5000 ：尝试恢复连接的时间间隔，以毫秒为单位<br>resetOffsets =false ：是否使用提供的startOffset 值来重置消费者的offset值<br>startOffset =null : 用来设置新建组的起始offset,该值也会在resetOffsets开始时被使用<br>enableDlq =false : 该参数设置为true时，将为消费者启用DLQ行为，引起错误的消息将被发送到名为error.<destination>.<group>的主题去</group></destination></p>
<h3 id="生产者配置-2"><a href="#生产者配置-2" class="headerlink" title="生产者配置"></a>生产者配置</h3><p>仅对生产者者有效，下面省略spring.cloud.stream.kafka.bindings.<channelname>.producer 前缀</channelname></p>
<p>bufferSize = 16384 Kafka批量发送前的缓存数据上限，以字节为单位<br>sync=false 该参数用来设置Kafka消息生产者的发送模式，默认为false,即采用async配置，允许批量发送数据。当设置为true时，将采用sync配置，消息将不会被批量发送，而是一条一条发送<br>batchTimeout=0 消息生产者批量发送时，为了积累更多发送数据而设置的等待时间。通常情况下，生产者基本不会等待，而是直接发送所有在前一批此发送时基类的消息数据。当我们设置一个非0值时，可以以延迟为代价来增加系统的吞吐量</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/stream/" rel="tag"># stream</a>
          
            <a href="/tags/spring-cloud/" rel="tag"># spring cloud</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/26/spring-cloud-服务网关/" rel="next" title="spring-cloud 服务网关">
                <i class="fa fa-chevron-left"></i> spring-cloud 服务网关
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/03/spring-cloud-aliba-服务注册/" rel="prev" title="spring-cloud-aliba 服务注册">
                spring-cloud-aliba 服务注册 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  <div>
    
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">------ 本文结束------</div>
    
</div>
    
 </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/sliver.jpg" alt="wei xy">
            
              <p class="site-author-name" itemprop="name">wei xy</p>
              <p class="site-description motion-element" itemprop="description">一步一步似爪牙</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
		  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28285910&auto=1&height=66"></iframe>
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#构建一个Spring-Cloud-Stream消费者"><span class="nav-number">1.</span> <span class="nav-text">构建一个Spring Cloud Stream消费者</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#核心概念"><span class="nav-number">2.</span> <span class="nav-text">核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#绑定器"><span class="nav-number">2.1.</span> <span class="nav-text">绑定器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发布-订阅模式"><span class="nav-number">2.2.</span> <span class="nav-text">发布-订阅模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消费组"><span class="nav-number">2.3.</span> <span class="nav-text">消费组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息分区"><span class="nav-number">2.4.</span> <span class="nav-text">消息分区</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用详解"><span class="nav-number">3.</span> <span class="nav-text">使用详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#开启绑定功能-EnableBinding"><span class="nav-number">3.1.</span> <span class="nav-text">开启绑定功能@EnableBinding</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绑定消息通道"><span class="nav-number">3.2.</span> <span class="nav-text">绑定消息通道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息的生产与消费"><span class="nav-number">3.3.</span> <span class="nav-text">消息的生产与消费</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StreamListener详解"><span class="nav-number">3.4.</span> <span class="nav-text">@StreamListener详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#消息反馈"><span class="nav-number">3.4.1.</span> <span class="nav-text">消息反馈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消费组-1"><span class="nav-number">3.4.2.</span> <span class="nav-text">消费组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息分区-1"><span class="nav-number">3.4.3.</span> <span class="nav-text">消息分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息类型"><span class="nav-number">3.4.4.</span> <span class="nav-text">消息类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#绑定器详解"><span class="nav-number">4.</span> <span class="nav-text">绑定器详解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自动化配置"><span class="nav-number">5.</span> <span class="nav-text">自动化配置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#配置详解"><span class="nav-number">6.</span> <span class="nav-text">配置详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础配置"><span class="nav-number">6.1.</span> <span class="nav-text">基础配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通用配置"><span class="nav-number">6.2.</span> <span class="nav-text">通用配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消费者配置"><span class="nav-number">6.3.</span> <span class="nav-text">消费者配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生产者配置"><span class="nav-number">6.4.</span> <span class="nav-text">生产者配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ配置"><span class="nav-number">6.5.</span> <span class="nav-text">RabbitMQ配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通用配置-1"><span class="nav-number">6.5.1.</span> <span class="nav-text">通用配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消费者配置-1"><span class="nav-number">6.5.2.</span> <span class="nav-text">消费者配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生产者配置-1"><span class="nav-number">6.5.3.</span> <span class="nav-text">生产者配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KafKa配置"><span class="nav-number">6.6.</span> <span class="nav-text">KafKa配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通用配置-2"><span class="nav-number">6.6.1.</span> <span class="nav-text">通用配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消费者配置-2"><span class="nav-number">6.6.2.</span> <span class="nav-text">消费者配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生产者配置-2"><span class="nav-number">6.6.3.</span> <span class="nav-text">生产者配置</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        
<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wei xy</span>

  
</div>

<!-- 
  <div class="powered-by">由  强力驱动</div>


  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash;  v5.1.4</div>

-->



        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  <!--动态标题-->
<script type="text/javascript" src="/js/src/dytitle.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"live2d-widget-model-miku"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false,"symbols_count_time":null},"symbols":true,"time":true,"total_symbols":true,"total_time":true,"log":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
