<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Hexo</title><meta name="author" content="david"><meta name="copyright" content="david"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:author" content="david">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "WebSite",
  "name": "Hexo",
  "url": "http://example.com/"
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Hexo',
  isHighlightShrink: false,
  isToc: false,
  pageType: 'home'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="page" id="body-wrap"><header class="full_page" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hexo</span></a></span><div id="menus"></div></nav><div id="site-info"><h1 id="site-title">Hexo</h1></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts nc" id="recent-posts"><div class="recent-post-items"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" title="JVM-内存模型">JVM-内存模型</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/JVM%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/">JVM内部原理</a></span></div><div class="content">JVM - 内存模型 (Runtime Data Areas)理解 JVM 内存模型是深入理解 Java 程序运行机制、排查内存问题、进行性能优化的基础。JVM 在执行 Java 程序时，会将其管理的内存划分为不同的数据区域。这些区域有各自的用途、创建和销毁时机，以及可能遇到的错误。 1. JVM 运行时数据区域概述JVM 内存主要分为两大类：线程私有和线程共享。      %%{init: {&#39;theme&#39;: &#39;neutral&#39;}}%% graph TD     A[JVM 内存区域] --&gt; B[线程私有]     A --&gt; C[线程共享]      B --&gt; B1[程序计数器]     B --&gt; B2[Java 虚拟机栈]     B --&gt; B3[本地方法栈]      C --&gt; C1[Java 堆]     C --&gt; C2[方法区]     C2 --&gt; C2_1[运行时常量池]     1.1 线程私有区域这些区域的生命周期与线程相同，随线程的创建而创建，随线程的销毁而销毁。  ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" title="JVM-垃圾回收">JVM-垃圾回收</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/JVM%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/">JVM内部原理</a></span></div><div class="content">JVM - 垃圾回收 (Garbage Collection, GC)垃圾回收（GC）是 Java 语言的一大特性，它自动管理内存，使得程序员无需手动释放对象，从而专注于业务逻辑。理解 GC 的工作原理，对于编写高性能、低延迟的 Java 应用，以及排查线上内存问题至关重要。 GC 的核心任务是回答三个问题：  哪些内存需要回收？ 什么时候回收？ 如何回收？  1. 如何判断对象已“死”？1.1 引用计数法 (Reference Counting) 原理: 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1；当引用失效时，计数器值就减 1。任何时刻计数器为 0 的对象就是不可能再被使用的。 优点: 实现简单，判定效率高。 缺点: 无法解决对象之间循环引用的问题。例如，对象 A 和 B 相互引用，但没有其他任何外部引用指向它们，此时它们的引用计数都不为 0，导致无法被回收。主流的 Java 虚拟机都没有选用引用计数法来管理内存。  1.2 可达性分析算法 (Reachability Analysis)这是主流商用程序语言（如 Java、C#）所采用的方法。  原理...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/JVM-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/" title="JVM-性能调优">JVM-性能调优</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/JVM%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/">JVM内部原理</a></span></div><div class="content">JVM - 性能调优 (JVM Performance Tuning)JVM 性能调优是 Java 高级工程师必备的技能之一。它涉及通过调整 JVM 参数、优化代码和监控工具来提升 Java 应用程序的性能、稳定性和响应速度。调优是一个系统性的工程，需要结合具体的应用场景和业务需求。 1. JVM 调优的目标在开始调优之前，首先要明确目标，因为不同的目标可能需要不同的调优策略。  降低延迟 (Latency): 减少 GC 停顿时间，提高响应速度。这对于用户交互频繁的应用（如 Web 应用、GUI 应用）至关重要。 提高吞吐量 (Throughput): 提高单位时间内处理的请求数量。这对于后台批处理、数据分析等任务密集型应用更重要。 减少内存占用: 优化内存使用，降低 OutOfMemoryError (OOM) 风险，尤其是在内存受限的环境中。 提高稳定性: 减少 GC 频率，避免频繁 Full GC 导致的长时间停顿。  2. JVM 调优的步骤与策略调优不是一蹴而就的，通常遵循以下步骤：  明确目标: 根据应用类型和业务需求，确定是追求低延迟还是高吞吐量。 监控与分析: ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" title="JVM-类加载机制">JVM-类加载机制</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/JVM%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/">JVM内部原理</a></span></div><div class="content">JVM - 类加载机制 (Class Loading Mechanism)类加载机制是 Java 程序运行的第一个环节，它负责将 .class 文件中的二进制数据加载到内存中，并对其进行验证、准备、解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。理解类加载机制是理解 Java 动态性、排查类加载问题（如 ClassNotFoundException, NoClassDefFoundError）以及进行热部署、代码加密等高级操作的基础。 1. 类加载的生命周期一个类从被加载到 JVM 中到卸载出内存，会经历以下七个阶段：      %%{init: {&#39;theme&#39;: &#39;neutral&#39;}}%% graph LR     A[加载] --&gt; B[验证]     B --&gt; C[准备]     C --&gt; D[解析]     D --&gt; E[初始化]     E --&gt; F[使用]     F --&gt; G[卸载]     1.1 加载 (Loading) 作用: 将 .class 文件（或其他来源的二进...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/JavaSE-%E5%85%A8%E9%9D%A2%E6%8E%8C%E6%8F%A1/" title="JavaSE-全面掌握">JavaSE-全面掌握</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">Java语言基础与高级特性</a></span></div><div class="content">JavaSE 全面掌握Java SE (Standard Edition) 是 Java 语言的核心和基础。精通 Java SE 是学习 Java EE、Android 开发以及各种高级框架（如 Spring、MyBatis）的前提。本部分旨在全面、系统地巩固 Java 的核心知识体系，为后续深入学习 JVM、并发编程和框架源码打下坚实的基础。 学习路径我们将遵循一条从基础到进阶的路径，逐步深入 Java 的世界：  基础语法: 回顾变量、数据类型、运算符、流程控制等基础知识 面向对象编程 (OOP): 深入理解封装、继承、多态三大特性，以及类、对象、接口、抽象类的设计与实现 常用 API: 掌握 &#96;String&#96;、&#96;StringBuilder&#96;、&#96;Math&#96;、日期时间 API (&#96;LocalDate&#96;, &#96;LocalDateTime&#96;) 等核心类的使用 集合框架 (Collections Framework): 这是 JavaSE 的重中之重。我们将深入学习 &#96;List&#96;, &#96...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/JavaSE-Java8%E6%96%B0%E7%89%B9%E6%80%A7/" title="JavaSE-Java 8+ 新特性">JavaSE-Java 8+ 新特性</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">Java语言基础与高级特性</a></span></div><div class="content">JavaSE - Java 8+ 新特性Java 8 是自 Java 5 以来最重要的一次版本更新，它引入了函数式编程的思想，极大地改变了 Java 的编程风格，使代码更简洁、更具表达力。本笔记将重点介绍其最核心的几个新特性。 1. Lambda 表达式Lambda 表达式是 Java 8 的核心特性之一，它允许我们将函数作为方法的参数，或者说，将代码块视为数据。其本质是一个匿名函数。  作用: 极大地简化了匿名内部类的写法，尤其是在使用函数式接口时。 语法: (parameters) -&gt; expression 或 (parameters) -&gt; &#123; statements; &#125;  12345678910// Java 8 之前：使用匿名内部类new Thread(new Runnable() &#123;    @Override    public void run() &#123;        System.out.println(&quot;Hello from old Thread!&quot;);    &#125;&#125;).s...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/JavaSE-IO%E4%B8%8ENIO/" title="JavaSE-IO与NIO">JavaSE-IO与NIO</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">Java语言基础与高级特性</a></span></div><div class="content">JavaSE - I&#x2F;O 与 NIOJava 的 I&#x2F;O (Input&#x2F;Output) 机制是程序与外部世界进行数据交换的桥梁。它允许程序从各种来源（如文件、网络、内存）读取数据，并将数据写入到各种目的地。随着技术的发展，Java 引入了 NIO (New I&#x2F;O) 来提供更高效、非阻塞的 I&#x2F;O 操作。 1. 传统 I&#x2F;O (BIO - Blocking I&#x2F;O)传统 I&#x2F;O 基于流 (Stream) 的概念，其主要特点是阻塞式 (Blocking)。当程序调用一个 I&#x2F;O 操作（如 read()）时，如果数据尚未准备好，线程就会被阻塞，直到操作完成。这种模式在连接数少时简单易用，但在高并发场景下，一个线程对应一个连接的方式会因大量线程阻塞和上下文切换而导致性能瓶颈。 2. NIO (New I&#x2F;O - Non-Blocking I&#x2F;O)Java NIO 是在 JDK 1.4 中引入的，它基于通道 (Channel)、缓冲区 (Buffer) 和选择器 (Selecto...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/JavaSE-%E5%8F%8D%E5%B0%84/" title="JavaSE-反射">JavaSE-反射</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">Java语言基础与高级特性</a></span></div><div class="content">JavaSE - 反射 (Reflection)反射（Reflection）是 Java 语言在运行时动态地获取类信息并操作对象的能力。它允许程序在运行时检查类、接口、字段和方法，而无需在编译时知道这些信息。这是 Java 语言非常强大和灵活的特性，也是许多高级框架（如 Spring、Hibernate、JUnit）实现其核心功能的基石。 1. 反射的基石：Class 类java.lang.Class 类是反射的入口。每个类在 JVM 中都有一个对应的 Class 对象，这个对象包含了该类的所有结构信息（构造器、方法、字段等）。 获取 Class 对象的三种方式 Class.forName(&quot;全限定类名&quot;): 最常用，通过类的全限定名获取。1Class&lt;?&gt; c1 = Class.forName(&quot;java.lang.String&quot;); 类名.class: 通过类本身的 class 属性获取。1Class&lt;?&gt; c2 = String.class; 对象.getClass(): 通过对象的 getClass() 方法...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/JavaSE-%E6%B3%9B%E5%9E%8B/" title="JavaSE-泛型">JavaSE-泛型</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">Java语言基础与高级特性</a></span></div><div class="content">JavaSE - 泛型 (Generics)泛型（Generics）是 Java 5 引入的一个重要特性，它允许在定义类、接口和方法时使用类型参数。泛型的核心目标是提高代码的类型安全性和消除强制类型转换，同时增强代码的可重用性。 1. 为什么需要泛型？在泛型出现之前，Java 集合框架（如 ArrayList）只能存储 Object 类型的对象。这意味着：  类型不安全: 任何类型的对象都可以被添加到集合中，导致运行时可能出现 ClassCastException。 需要强制类型转换: 从集合中取出元素时，必须进行强制类型转换，代码冗余且容易出错。  123456789// 泛型出现之前List list = new ArrayList();list.add(&quot;hello&quot;);list.add(123); // 编译时不会报错String s = (String) list.get(0); // 需要强制类型转换Integer i = (Integer) list.get(1); // 需要强制类型转换// String s2 = (String) list....</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/JavaSE-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" title="JavaSE-异常处理">JavaSE-异常处理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">Java语言基础与高级特性</a></span></div><div class="content">JavaSE - 异常处理 (Exception Handling)异常处理是 Java 语言中一个强大的机制，它提供了一种结构化的方式来处理程序在运行时可能出现的错误或“异常”情况，从而增强程序的健壮性和容错性。 1. 异常体系结构Java 中所有的异常都派生自 java.lang.Throwable 类。Throwable 有两个主要的子类：Error 和 Exception。      graph TD     A(Throwable) --&gt; B(Error)     A --&gt; C(Exception)      B --&gt; D[OutOfMemoryError]     B --&gt; E[StackOverflowError]      C --&gt; F(Checked Exception)     C --&gt; G(RuntimeException)      F --&gt; H[IOException]     F --&gt; I[SQLException]     G --&gt; J[NullPointerException]...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/JavaSE-%E6%B3%A8%E8%A7%A3/" title="JavaSE-注解">JavaSE-注解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">Java语言基础与高级特性</a></span></div><div class="content">JavaSE - 注解 (Annotations)注解（Annotations）是 Java 5 引入的一种元数据（metadata）机制。它提供了一种不影响程序逻辑的方式，为代码添加额外的信息。这些信息可以在编译时、类加载时或运行时被读取和处理，从而实现代码的自动化处理、检查或配置。 1. 注解的本质与作用 本质: 注解是一种特殊的接口，继承自 java.lang.annotation.Annotation 接口。 作用: 编译检查: 告诉编译器如何检查代码（如 @Override, @Deprecated）。 代码生成: 通过注解处理器在编译时生成新的代码（如 Lombok）。 运行时处理: 在运行时通过反射读取注解信息，进行动态配置或行为修改（如 Spring 的 @Autowired, @Transactional）。    2. Java 内置注解Java 提供了几个标准的内置注解，它们在日常开发中非常常见。  @Override:  作用: 标记一个方法是重写父类或实现接口的方法。 目的: 帮助编译器检查方法签名是否正确，如果父类中没有对应方法，则编译报错。   @D...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/JavaSE-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" title="JavaSE-集合框架(索引)">JavaSE-集合框架(索引)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">Java语言基础与高级特性</a></span></div><div class="content">JavaSE - 集合框架 (Collections Framework)Java 集合框架（JCF）是一个用来存储和操作对象集合的统一架构。它包含了一系列的接口、实现类和算法，极大地简化了对数据集合的处理。这是 JavaSE 中最核心、最重要的部分之一。 本篇笔记将作为集合框架学习的索引和枢纽，您可以点击以下链接，跳转到各个核心接口的详细学习笔记中。 1. 集合框架核心接口     %%{init: {&#39;theme&#39;: &#39;neutral&#39;}}%% graph TD     subgraph Collection 接口         A[Iterable] --&gt; B(Collection)         B --&gt; C{List}         B --&gt; D{Set}         B --&gt; E{Queue}     end     subgraph Map 接口         F(Map)     end      C --&gt; G[ArrayList]     C --&gt; H[LinkedLis...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/Java%E5%9F%BA%E7%A1%80-Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" title="Java基础-Java基本语法">Java基础-Java基本语法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">Java语言基础与高级特性</a></span></div><div class="content">Java 基础语法Java 语言作为一门面向对象的编程语言，其基础语法是构建一切复杂应用的基础。本章将系统回顾 Java 的核心语法要素。 1. 关键字与标识符 关键字 (Keywords): Java 语言预先定义并赋予特殊含义的单词，如 public, class, static, void, int, if, else, for, while 等。关键字不能作为标识符使用。 标识符 (Identifiers): 程序员在程序中自定义的名称，用于命名变量、类、方法、包等。命名规则： 由字母、下划线 _ 或美元符号 $ 开头。 后续字符可以是字母、数字、下划线 _ 或美元符号 $。 不能是 Java 关键字。 区分大小写。 建议遵循“驼峰命名法”：类名首字母大写，变量名和方法名首字母小写，常量全大写并用下划线分隔。    2. 变量与数据类型2.1 变量 (Variables)变量是程序中存储数据的基本单元。在使用前必须先声明后赋值。  声明: 数据类型 变量名; (例如: int age;) 赋值: 变量名 = 值; (例如: age = 25;) 声明并赋值: 数据类型 变...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/JavaSE-%E5%B8%B8%E7%94%A8API/" title="JavaSE-常用API">JavaSE-常用API</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">Java语言基础与高级特性</a></span></div><div class="content">JavaSE - 常用 APIJava Development Kit (JDK) 提供了大量功能强大的 API (Application Programming Interface)，这些 API 是我们日常开发的基础工具。熟练掌握常用 API 能极大地提高开发效率和代码质量。 1. String 类String 是 Java 中最重要、最常用的类之一，用于表示字符串。String 对象是不可变的 (immutable)，一旦创建，其内容就不能被修改。 1.1 String 的不可变性 优点:  线程安全: 因为不可变，所以可以在多线程环境中安全共享，无需同步。 可作为 HashMap 的键: String 的 hashCode() 是缓存的，因为字符串内容不变，所以哈希码也不变，提高了 HashMap 的性能。 字符串常量池 (String Pool): 不可变性是字符串常量池实现的基础，可以节省大量内存。   缺点: 每次对 String 对象进行修改（如拼接、替换），都会创建一个新的 String 对象，这在大量操作时会产生性能开销和内存垃圾。  1.2 常用方法 int...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" title="JavaSE-面向对象编程">JavaSE-面向对象编程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">Java语言基础与高级特性</a></span></div><div class="content">JavaSE - 面向对象编程 (OOP)面向对象编程（Object-Oriented Programming, OOP）是 Java 语言的核心思想。它是一种程序设计范式，将程序组织为“对象”的集合，每个对象都包含数据（属性）和操作数据的方法（行为）。OOP 的核心优势在于其模块化、可重用性和易于维护性。 1. 类与对象 (Class and Object) 类 (Class): 类是对象的模板或蓝图，它定义了对象的属性（数据）和行为（方法）。类是抽象的，不占用内存空间。 1234567891011121314public class Dog &#123;    // 属性 (成员变量)    String name;    int age;    // 行为 (成员方法)    public void bark() &#123;        System.out.println(name + &quot;汪汪叫！&quot;);    &#125;    public void eat() &#123;        System.out.println(name + &q...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/Web%E6%8A%80%E6%9C%AF%E6%A0%88-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/" title="Web技术栈-核心概念">Web技术栈-核心概念</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%AB%98%E7%BA%A7Java%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%A1%86%E6%9E%B6/">高级Java生态系统与框架</a></span></div><div class="content">Web技术栈 - 核心概念本篇笔记将聚焦于 Java 后端 Web 开发的基石，包括 Servlet 规范、HTTP 协议、Web 服务器以及 RESTful API 设计。 1. Servlet&#x2F;JSP 核心概念1.1 什么是 Servlet？ 定义: Servlet (Server Applet) 是运行在 Web 服务器（如 Tomcat）中的小型 Java 程序。它接收来自客户端的 HTTP 请求，进行处理，然后生成 HTTP 响应并将其发送回客户端。 本质: Servlet 是 Java EE (现为 Jakarta EE) 提供的一套 API 规范。 生命周期 (单例): init() -&gt; service() (每次请求) -&gt; destroy()。 线程安全: Servlet 实例是单例的，应避免在其中使用可变的成员变量。  1.2 Filter (过滤器) 定义: 一个可以拦截和处理请求和响应的对象，位于客户端和目标 Servlet 之间，形成“过滤器链”。 核心方法: doFilter(request, response, chain)。...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/java-p7%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/" title="Java P7 工程师学习路线图 (最终版)">Java P7 工程师学习路线图 (最终版)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/">学习计划</a></span></div><div class="content">Java P7 工程师学习路线图 (最终版)这份学习路线图旨在提供一个全面、深入的路径，帮助您达到阿里P7级别Java工程师的要求。它涵盖了从核心Java到分布式系统、云原生、大数据、AI大模型以及软技能等多个关键领域。 学习路径概览     %%{init: {&#39;theme&#39;: &#39;neutral&#39;}}%% graph TD     classDef phase1 fill:#f9f,stroke:#333,stroke-width:2px;     classDef phase2 fill:#bbf,stroke:#333,stroke-width:2px;     classDef phase3 fill:#bfb,stroke:#333,stroke-width:2px;     classDef phase4 fill:#ffb,stroke:#333,stroke-width:2px;     classDef phase5 fill:#fbb,stroke:#333,stroke-width:2px;     classDef phas...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7/" title="并发编程-JUC核心工具">并发编程-JUC核心工具</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/">并发编程与多线程</a></span></div><div class="content">并发编程 - java.util.concurrent (JUC) 核心工具java.util.concurrent 包（简称 JUC）是 Java 并发编程的核心，由并发大师 Doug Lea 设计，提供了比 synchronized 和 volatile 更高级、更丰富的并发工具。掌握 JUC 是成为 Java 高级工程师的必备技能。 1. 线程池 (ExecutorService)线程池用于统一管理和复用线程，避免因频繁创建和销毁线程而带来的性能开销。  核心实现: ThreadPoolExecutor。 7大核心参数: corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler。 工作原理: 核心线程 -&gt; 任务队列 -&gt; 最大线程 -&gt; 拒绝策略。 Executors 风险: newFixedThreadPool 和 newCachedThreadPool 等预设线程池可能因使用无界队列或无界最大线程数而导致 OOM，生产环境建议手动创建 T...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E6%A0%B8%E5%BF%83%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/" title="并发编程-核心面试知识点汇总">并发编程-核心面试知识点汇总</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/">并发编程与多线程</a></span></div><div class="content">并发编程 - 核心面试知识点汇总本篇笔记旨在高度浓缩“并发编程与多线程”模块的核心知识点，以便于快速复习，加深理解，并从容应对面试。 Part 1: 线程基础与 JMM (Java 内存模型)1. 线程的 6 种状态及其转换 NEW (新建): 线程已创建但未启动。 RUNNABLE (可运行): 调用 start() 后进入此状态。它包含了 Ready (就绪, 等待CPU调度) 和 Running (运行中) 两个子状态。 BLOCKED (阻塞): 等待进入 synchronized 同步块&#x2F;方法时。 WAITING (无限期等待): 调用 Object.wait(), Thread.join(), LockSupport.park()。 TIMED_WAITING (有时限等待): 调用 Thread.sleep(long), Object.wait(long) 等。 TERMINATED (终止): run() 方法执行完毕或因异常退出。  2. volatile 关键字 两大作用: 保证可见性: 对 volatile 变量的写操作会立即刷新到主内存，读操作会...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8EJMM/" title="并发编程-线程基础与JMM">并发编程-线程基础与JMM</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/">并发编程与多线程</a></span></div><div class="content">并发编程 - 线程基础与 JMM并发编程是 Java 高级开发中不可或缺的一部分。理解线程的生命周期、状态转换以及 Java 内存模型（JMM）是进行高效、安全并发编程的基础。 1. 线程与进程 进程 (Process): 操作系统资源分配的最小单位。每个进程都有自己独立的内存空间、文件句柄等资源。 线程 (Thread): CPU 调度的最小单位，是进程中的一个执行流。一个进程可以包含多个线程，这些线程共享进程的内存空间和资源。  2. Java 中线程的创建方式2.1 implements Runnable vs extends Thread   特性 implements Runnable (推荐) extends Thread    本质 任务 (Task) 线程 (Worker)   耦合度 低 (任务与线程解耦) 高 (任务与线程耦合)   继承限制 无 (类可以继承其他类) 有 (Java 单继承限制)   资源共享 容易 (多个线程可共享一个 Runnable 实例) 复杂 (需要将共享资源设为 static)   设计思想 面向接口编程 面向实现编程   2.2...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E9%94%81%E6%9C%BA%E5%88%B6/" title="并发编程-锁机制">并发编程-锁机制</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/">并发编程与多线程</a></span></div><div class="content">并发编程 - 锁机制 (synchronized, Lock)锁机制是 Java 并发编程中用于保证线程安全、实现数据同步的关键手段。理解 synchronized 关键字和 java.util.concurrent.locks.Lock 接口的原理和使用，对于编写正确、高效的并发程序至关重要。 1. 为什么需要锁？在多线程环境下，当多个线程同时访问和修改共享资源时，如果没有适当的同步机制，就可能导致数据不一致、逻辑错误等并发问题。  并发问题示例: i++ 操作i++ 看起来是一个简单的操作，但它实际上包含三个步骤： 读取 i 的值。 将 i 的值加 1。 将新值写回 i。在多线程环境下，如果线程 A 读取 i 的值为 0，正准备加 1，此时线程 B 也读取 i 的值为 0。然后线程 A 将 i 更新为 1，线程 B 也将 i 更新为 1。最终 i 的值是 1，而不是期望的 2。这就是线程不安全。    锁的作用就是保证在同一时刻，只有一个线程能够访问被保护的共享资源，从而避免并发问题，实现线程安全。 2. synchronized 关键字synchronized 是 Java...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-CPU%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/" title="计算机基础-计算机组成原理-CPU的功能和基本结构">计算机基础-计算机组成原理-CPU的功能和基本结构</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">CPU 的功能和基本结构中央处理器（Central Processing Unit, CPU）是计算机的运算和控制核心。它的主要功能是解释计算机指令以及处理计算机软件中的数据。CPU 的工作可以概括为：取指令、分析指令、执行指令。 1. CPU 的两大核心功能 指令控制: 控制程序的执行顺序。CPU 通过程序计数器（PC）来确定下一条指令的地址，实现程序的顺序执行、分支、循环和跳转。 操作控制: 一条指令可以分解为多个微操作。CPU 的控制器负责产生每个微操作所需的控制命令，并将它们发送到相应的部件，以控制这些部件执行相应的操作。  2. CPU 的基本结构CPU 主要由运算器 (ALU) 和控制器 (Control Unit) 两大部分组成。 2.1 运算器 (Arithmetic Logic Unit, ALU)运算器是 CPU 中负责执行数据处理的部分，即执行算术运算和逻辑运算。  功能:  算术运算: 加、减、乘、除等。 逻辑运算: 与、或、非、异或等。   核心组成: 算术逻辑单元 (ALU): 是运算器的核心，负责执行具体的算术和逻辑操作。 累加寄存器 (Accumu...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-IO%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F/" title="计算机基础-计算机组成原理-IO控制方式">计算机基础-计算机组成原理-IO控制方式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">I&#x2F;O 控制方式I&#x2F;O 控制方式是指 CPU 如何管理和控制与外部设备（如硬盘、键盘、网络接口）之间的数据交换。由于 I&#x2F;O 设备的速度远远慢于 CPU，因此采用高效的 I&#x2F;O 控制方式对于提升整个计算机系统的性能至关重要。主要有以下三种方式，它们是逐步演进的。 1. 程序查询方式 (Programmed I&#x2F;O)这是最早期、最简单的一种 I&#x2F;O 控制方式。  工作流程:  CPU 向 I&#x2F;O 控制器发出一个 I&#x2F;O 请求（例如，读数据）。 CPU 进入一个循环，不断地查询 I&#x2F;O 控制器中的状态寄存器，检查 I&#x2F;O 操作是否已经完成。 如果操作完成，CPU 从 I&#x2F;O 控制器的数据寄存器中取出数据。 CPU 继续执行后续指令。   图示: 12345678910CPU                                I/O 设备 | -- 发出读指令 --&gt;                  | |                          ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="计算机基础-操作系统">计算机基础-操作系统</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">计算机操作系统核心知识操作系统（Operating System, OS）是管理计算机硬件与软件资源的系统软件，同时也是计算机系统的内核与基石。它为用户和其他软件提供了与硬件交互的接口。理解操作系统的核心概念，对于编写高性能、高可靠性的应用程序至关重要。 1. 进程与线程 (Process &amp; Thread)这是操作系统中最核心、最基本的概念，也是理解并发编程的基础。 进程 (Process) 定义: 进程是程序的一次执行过程，是系统进行资源分配和调度的基本单位。每个进程都有自己独立的内存空间。 组成: 主要由程序代码、数据、进程控制块 (PCB) 组成。PCB 是进程存在的唯一标识。 特性:  动态性: 进程是程序的一次执行，有生命周期。 独立性: 作为资源分配的基本单位，各进程的地址空间相互独立。 并发性: 多个进程可以在单个处理器上并发执行。   状态: 创建 (New)、就绪 (Ready)、运行 (Running)、阻塞 (Blocked)、终止 (Terminated)。  线程 (Thread) 定义: 线程是进程的一个执行实体，是 CPU 调度和分派的基本...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8/" title="计算机基础-计算机组成原理-主存储器">计算机基础-计算机组成原理-主存储器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">主存储器 (Main Memory)主存储器（简称主存或内存）是计算机存储器层次结构中的核心组成部分，位于高速缓存（Cache）和辅助存储器（硬盘）之间。它用于存放 CPU 当前正在执行的程序和处理的数据。CPU 可以直接对主存进行读写访问。 现代计算机的主存主要由半导体存储器构成，根据其工作原理的不同，主要分为两大类：静态随机存取存储器 (SRAM) 和动态随机存取存储器 (DRAM)。 1. 静态随机存取存储器 (SRAM - Static RAM) 工作原理: SRAM 使用触发器 (Flip-flop) 来存储每一位（bit）的数据。一个触发器通常由 6 个晶体管构成。只要有持续的电源供应，触发器就能一直保持其状态（0 或 1），无需刷新。  特点:  速度快: 由于其结构简单，无需刷新操作，SRAM 的存取速度非常快，接近 CPU 的速度。 价格昂贵: 每个 bit 需要多个晶体管，集成度低，单位容量的成本非常高。 功耗较大: 在保持数据时，触发器一直处于工作状态，因此功耗相对较高。   主要用途: 因其高速特性，SRAM 主要用于制造高速缓存 (Cache) 和 CP...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/" title="计算机基础-计算机组成原理-存储器层次结构">计算机基础-计算机组成原理-存储器层次结构</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">存储器层次结构 (Memory Hierarchy)在计算机系统中，我们对存储器的期望是：速度快、容量大、价格便宜。然而，这三个目标在物理上是相互矛盾的。速度越快的存储器，通常价格越贵，容量也越小。为了解决这个矛盾，现代计算机系统采用了存储器层次结构 (Memory Hierarchy) 的设计。 1. 为什么需要层次结构？存储器层次结构的基本思想是，在 CPU 和主存之间，以及主存和辅存之间，设置不同速度、容量和价格的存储层次，并将数据在这些层次之间进行调度，以尽可能地达到高速、大容量和低成本的统一。 这种设计的有效性，主要依赖于一个重要的程序行为特性——局部性原理 (Principle of Locality)。  时间局部性 (Temporal Locality): 如果一个数据项被访问了，那么在不久的将来，它很可能再次被访问。例如，循环中的变量、函数中的局部变量。 空间局部性 (Spatial Locality): 如果一个数据项被访问了，那么与它地址相邻的数据项也很可能很快被访问。例如，数组的顺序访问、指令的顺序执行。  正是因为局部性原理的存在，我们可以将 CPU 当...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F/" title="计算机基础-计算机组成原理-多处理器系统">计算机基础-计算机组成原理-多处理器系统</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">多处理器系统 (Multiprocessor Systems)随着单个处理器性能提升遭遇物理瓶颈，通过集成多个处理器（核心）来提升计算能力成为主流，这就是多处理器系统。这类系统通过并行处理来显著提高计算机的吞吐率和性能。 1. 并行处理概念：Flynn 分类法Flynn 分类法是基于指令流 (Instruction Stream) 和数据流 (Data Stream) 的数量，对计算机体系结构进行分类的一种经典方法。  指令流: 机器执行的指令序列。 数据流: 由指令流调用的数据序列。  根据此分类，计算机体系结构可以分为四类：  SISD (Single Instruction, Single Data Stream) - 单指令流单数据流  描述: 传统的单处理器计算机，一个时刻只执行一条指令，处理一个数据。 示例: 早期的冯·诺依曼体系计算机。   SIMD (Single Instruction, Multiple Data Stream) - 单指令流多数据流  描述: 用一条指令同时对多个不同的数据执行相同的操作。这种并行方式也称为数据级并行。 示例: 现代 CPU ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/" title="计算机基础-计算机组成原理-指令流水线">计算机基础-计算机组成原理-指令流水线</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">指令流水线 (Instruction Pipelining)指令流水线是现代处理器中用于提升性能的一项关键技术。它的核心思想类似于工厂里的“流水线”，将一条指令的执行过程分解为多个相互独立的阶段（Stage），并让这些阶段可以并行处理不同指令的不同部分，从而提高指令的吞吐率。 1. 流水线的基本概念假设一条指令的执行需要 3 个时钟周期，如果不使用流水线，执行 3 条指令就需要 3 * 3 = 9 个时钟周期。 现在，我们将一条指令的执行过程分解为 3 个阶段，每个阶段耗时 1 个时钟周期：  取指 (Fetch, IF): 从内存中取出指令。 译码 (Decode, ID): 分析指令，确定操作类型和操作数。 执行 (Execute, EX): 执行指令所规定的操作。  通过流水线技术，CPU 可以在第一个时钟周期取第一条指令，在第二个时钟周期取第二条指令并同时译码第一条指令，在第三个时钟周期取第三条指令、译码第二条指令并同时执行第一条指令。此后，每个时钟周期都能完成一条指令的执行。 非流水线 vs. 流水线对比:  非流水线 (9个周期): 123指令1: | IF | ID...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/" title="计算机基础-计算机组成原理-数据的表示与运算">计算机基础-计算机组成原理-数据的表示与运算</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">数据的表示与运算计算机内部的所有信息——无论是数字、字符还是指令——都以二进制的形式进行存储和处理。理解计算机如何表示和运算数据，是深入学习计算机科学的基础。 1. 数值数据1.1 定点数 (Fixed-point Number)定点数是指小数点位置固定的数。通常，我们用它来表示整数或纯小数。 原码、反码、补码 这三种表示法主要用于解决带符号整数的存储和运算问题。在计算机中，通常用最高位作为符号位（0 表示正数，1 表示负数）。 以 8 位二进制数为例：    数值 原码 (Sign-Magnitude) 反码 (1’s Complement) 补码 (2’s Complement)    +7 0000 0111 0000 0111 0000 0111   -7 1000 0111 1111 1000 1111 1001    原码: 简单直观，但有两个零（+0 和 -0），且加减法运算复杂。 反码: 负数的反码是其原码除符号位外，按位取反。它同样有两个零，运算也不够方便。 补码: 现代计算机普遍采用补码来表示和运算整数。 正数的补码就是其原码。 负数的补码是其反码加 1。 优...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/" title="计算机基础-计算机组成原理-控制器设计">计算机基础-计算机组成原理-控制器设计</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">控制器设计控制器（Control Unit, CU）是 CPU 的决策机构，其核心功能是根据指令寄存器（IR）中的指令，生成一系列的控制信号，发送给计算机的各个部件，以指挥它们完成指令所规定的操作。控制器设计的优劣直接影响 CPU 的性能。 设计控制器主要有两种方式：硬布线控制器和微程序控制器。 1. 硬布线控制器 (Hardwired Controller)硬布线控制器是基于组合逻辑电路来设计和实现的。它的基本思想是，对于每条机器指令，都用一个专门的、复杂的逻辑电路来产生其执行所需的控制信号。  实现原理: 控制信号是指令操作码、时钟信号以及各种状态标志的逻辑函数。一旦确定了这些逻辑关系，就可以用门电路（与门、或门、非门）和触发器等逻辑元件将它们“硬生生”地连接起来，形成一个固定的控制单元。 控制信号 = f(操作码, 时钟, 状态标志)  优点:  速度快: 由于是纯硬件的组合逻辑电路，指令执行速度非常快。   缺点:  设计和实现复杂: 对于一个复杂的指令系统，设计出对应的组合逻辑电路非常困难和繁琐。 难以修改和扩展: 一旦设计完成，电路就固定了。如果需要增加一条新的指令，...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%A6%82%E8%AE%BA/" title="计算机基础-计算机组成原理-概论">计算机基础-计算机组成原理-概论</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">计算机系统概论计算机组成原理研究的是计算机硬件系统的基本组成部分以及它们之间如何协同工作。理解这些底层概念是编写高效代码、进行系统性能分析和优化的基础。 1. 冯·诺依曼体系结构 (Von Neumann Architecture)冯·诺依曼体系结构是现代计算机的基础。它由美籍匈牙利数学家冯·诺依曼于1945年提出，其核心思想是**“存储程序” (Stored-Program Computer)**。 五大核心组成部分 运算器 (Arithmetic Logic Unit, ALU): 负责执行算术运算（加、减、乘、除）和逻辑运算（与、或、非、异或）。 控制器 (Control Unit, CU): 计算机的指挥中心。它负责从内存中取出指令、分析指令并发出控制信号，协调其他所有组件的工作。 存储器 (Memory): 用于存放程序（指令）和数据。冯·诺依曼结构的关键在于，指令和数据以同等地位存放在同一存储器中，并可按地址寻访。 输入设备 (Input Device): 将外部世界的信息（如键盘敲击、鼠标移动）转换成计算机能识别的二进制代码。例如：键盘、鼠标、扫描仪。 输出设备 (...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" title="计算机基础-计算机组成原理-指令系统">计算机基础-计算机组成原理-指令系统</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">指令系统 (Instruction Set Architecture - ISA)指令系统（ISA）是计算机体系结构中与程序设计有关的部分，它是软件和硬件之间的关键接口。它定义了 CPU 能识别和执行的指令集合，规定了指令的格式、寻址方式以及指令的功能。 1. 指令格式一条指令就是机器语言的一个语句，它规定了计算机要执行的某种操作。一条指令通常由两部分组成：  操作码 (Opcode): 指明该指令要执行的操作，如加、减、取数、存数等。操作码的位数决定了计算机的指令集大小（例如，n 位操作码最多可以表示 2^n 条指令）。 地址码 (Address Code): 指明操作的对象（操作数）的地址。根据地址码的数量，指令可以分为零地址、一地址、二地址、三地址指令。     操作码 (Opcode) 地址码 1 (A1) 地址码 2 (A2) …     三地址指令: OP A1, A2, A3 -&gt; (A1) OP (A2) -&gt; A3 (例如，ADD R1, R2, R3) 二地址指令: OP A1, A2 -&gt; (A1) OP (A2) -&gt; A1 (例如...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/" title="计算机基础-计算机组成原理-虚拟存储器">计算机基础-计算机组成原理-虚拟存储器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">虚拟存储器 (Virtual Memory)虚拟存储器是现代计算机系统内存管理的一项核心技术。它为每个进程提供了一个独立的、连续的、巨大的逻辑地址空间，而无需关心物理内存的实际大小和碎片化情况。这使得程序员可以编写和运行远大于实际物理内存的程序。 虚拟存储器的实现主要依赖于主存-辅存这一层次的数据交换，并由硬件和操作系统共同完成。 1. 基本概念 逻辑地址 (Logical Address) &#x2F; 虚拟地址 (Virtual Address): CPU 生成的、程序员视角下的地址。它位于虚拟地址空间中。 物理地址 (Physical Address): 物理内存中真实的地址。 内存管理单元 (Memory Management Unit, MMU): CPU 内部的一个硬件单元，负责将逻辑地址实时地转换为物理地址。  2. 虚拟存储器的实现方式主要有三种方式：页式、段式和段页式。其中，页式虚拟存储是目前最主流的方式。 2.1 页式存储管理 (Paging) 基本思想:   将进程的逻辑地址空间划分为大小相等的页 (Page)。 将物理内存划分为与页大小相等的页框 (Pag...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP%E5%8D%8F%E8%AE%AE/" title="计算机基础-计算机网络-HTTP协议">计算机基础-计算机网络-HTTP协议</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">HTTP&#x2F;HTTPS 协议HTTP (HyperText Transfer Protocol, 超文本传输协议) 是一个用于分布式、协作式和超媒体信息系统的应用层协议。它是万维网（World Wide Web）数据通信的基础。 1. HTTP 的特点 基于 TCP&#x2F;IP: HTTP 协议构建在 TCP 协议之上，利用 TCP 提供的可靠数据传输服务。 请求-响应模型 (Request-Response): 通信由客户端发起，服务器进行响应。客户端发送一个 HTTP 请求，服务器返回一个 HTTP 响应。 无状态 (Stateless): 服务器不保存任何关于客户端过去请求的信息。每个请求都被视为独立的事务。这简化了服务器的设计，但为了在不同请求间维持状态（如用户登录），需要引入 Cookie 和 Session 机制。  2. HTTP 请求报文 (Request)一个 HTTP 请求由三部分组成：请求行、请求头、请求体。 123456GET /index.html HTTP/1.1        &lt;-- 请求行Host: www.example.com...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8/" title="计算机基础-计算机组成原理-高速缓冲存储器">计算机基础-计算机组成原理-高速缓冲存储器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">高速缓冲存储器 (Cache)高速缓冲存储器（Cache）是位于 CPU 和主存之间的一种容量小、速度快的高速存储器。它的存在是为了缓解 CPU 与主存之间巨大的速度差异。Cache 的设计和性能是现代计算机体系结构中的核心问题之一。 1. 工作原理：局部性原理Cache 的有效性完全建立在局部性原理之上：  时间局部性: 最近被访问的数据很可能在不久的将来再次被访问。 空间局部性: 一个数据被访问时，其地址相邻的数据也很可能即将被访问。  基于此，当 CPU 访问内存时，它会先在 Cache 中查找。如果找到（缓存命中, Cache Hit），则直接从 Cache 中获取数据，速度极快。如果未找到（缓存未命中, Cache Miss），则需要从主存中读取数据，同时会将该数据及其相邻数据组成一个数据块 (Cache Line) 加载到 Cache 中，以备将来使用。 2. 映射方式 (Mapping)映射方式规定了主存中的一个数据块可以被放置到 Cache 中的哪个位置。主要有三种映射方式： 2.1 直接映射 (Direct Mapped) 规则: 主存中的每一个块只能映射到 C...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/" title="计算机基础-计算机网络-网络协议分层模型">计算机基础-计算机网络-网络协议分层模型</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">计算机网络 - 网络协议分层模型为了设计和实现复杂的计算机网络，人们提出了分层（Layering）的思想。分层将一个复杂的问题分解为多个更小、更易于管理的部分。每一层都建立在它的下层之上，并为它的上层提供特定的服务，同时隐藏下层实现的细节。网络协议分层模型主要有两种：OSI 七层模型和 TCP&#x2F;IP 四层&#x2F;五层模型。 1. OSI 七层参考模型 (Open Systems Interconnection)OSI 模型是一个理论上的、非常完善的模型，由国际标准化组织（ISO）提出。它旨在为所有计算机网络提供一个标准的参考框架。    层次 名称 功能描述 常见协议&#x2F;设备    第7层 应用层 (Application) 为应用程序提供网络服务，是用户直接接触的一层。 HTTP, FTP, SMTP, DNS   第6层 表示层 (Presentation) 负责数据的格式化、加密&#x2F;解密、压缩&#x2F;解压缩。 JPEG, ASCII, TLS&#x2F;SSL   第5层 会话层 (Session) 建立、管理和终止会话（连接）。 NetB...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/" title="设计模式-中介者模式">设计模式-中介者模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B/">设计模式-行为型</a></span></div><div class="content">什么是中介者模式？中介者模式 (Mediator Pattern) 是一种行为型设计模式，它提供了一个中介对象来封装一系列对象（同事类）之间的交互。中介者模式使得这些对象不需要显式地相互引用，从而使它们的耦合松散，并且可以独立地改变它们之间的交互。 通俗地讲，中介者模式就像是机场的控制塔。每架飞机（同事类）都无需与其他飞机直接通信来协调起飞和降落。相反，所有飞机都只与控制塔（中介者）通信。控制塔负责协调所有飞机的行动，避免冲突。如果没有控制塔，每架飞机都需要知道其他所有飞机的位置和状态，这将形成一个极其复杂的网状通信结构，非常混乱且危险。 模式结构中介者模式主要包含以下角色：  Mediator (中介者接口): 定义了同事类对象之间进行通信的接口。 ConcreteMediator (具体中介者): 实现了中介者接口。它了解并维护所有的同事类，并负责协调它们之间的交互关系。 Colleague (同事类接口): 定义了每个同事类的接口，它通常持有一个中介者对象的引用。 ConcreteColleague (具体同事类): 实现了同事类接口。每个同事类只知道自己的行为，它不与其他...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/" title="设计模式-享元模式">设计模式-享元模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/">设计模式-结构型</a></span></div><div class="content">什么是享元模式？享元模式 (Flyweight Pattern) 是一种结构型设计模式，它旨在通过共享尽可能多的相似对象来最小化内存使用或计算开销。当程序需要创建大量相似的对象，而这些对象的大部分状态都可以被外部化和共享时，此模式尤其有效。 享元模式的核心在于区分对象的内部状态 (Intrinsic State) 和外部状态 (Extrinsic State)。  内部状态: 存储在享元对象内部，并且不随环境改变，可以被多个对象共享。例如，一个字符的字形、颜色。 外部状态: 由客户端计算或存储，在使用享元对象时才传递给它，并且会随环境改变。例如，一个字符在文档中的位置坐标。  享元模式通过只存储内部状态，并将外部状态作为方法参数传入，从而实现对象的共享。 模式结构享元模式主要包含以下角色：  Flyweight (享元接口): 定义了享元对象的接口，通过这个接口，享元可以接收并作用于外部状态。 ConcreteFlyweight (具体享元): 实现了享元接口，并为内部状态增加存储空间。该类的对象必须是可共享的。 UnsharedConcreteFlyweight (非共享具体享...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" title="设计模式-代理模式">设计模式-代理模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/">设计模式-结构型</a></span></div><div class="content">什么是代理模式？代理模式 (Proxy Pattern) 是一种结构型设计模式，它为你提供了一个对象的替代品或占位符，以便控制对该对象的访问。使用代理，你可以在将请求传递给实际服务对象之前或之后，执行某些操作。 通俗地讲，代理就像一个“中介”或“经纪人”。比如，你想买一套国外的房子（目标对象），但你对当地的法律、市场都不了解，直接去买会很麻烦。于是你找到了一个当地的房产中介（代理）。你所有的购房请求都先发给中介，中介会帮你处理各种琐事（如验证房源、办理手续），然后再去和房主进行实际的交易。这个中介就控制和管理了你对房子的直接访问。 模式结构代理模式主要包含以下角色：  Subject (主题接口): 定义了真实对象和代理对象的共同接口。这样，任何使用真实对象的地方都可以使用代理对象。 RealSubject (真实主题): 实现了主题接口，是代理所代表的真实对象，是最终执行业务逻辑的实体。 Proxy (代理): 实现了主题接口，并持有一个真实主题的引用。它可以在将请求委派给真实主题之前或之后，执行额外的操作。  结构图     %%{init: {&#39;theme&#39;...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E5%8D%8F%E8%AE%AE/" title="计算机基础-计算机网络-TCP协议">计算机基础-计算机网络-TCP协议</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">TCP 协议 (Transmission Control Protocol)TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议。它旨在为应用程序提供一个稳定、有序的数据传输通道，屏蔽了底层网络（如 IP 层）的不可靠性。 1. TCP 头部报文格式一个 TCP 报文段由头部和数据两部分组成。其头部包含了实现可靠传输所需的各种控制信息，通常为 20 字节。 12345678910111213141516171819 0                   1                   2                   3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|          源端口 (16)          |         目的端口 (16)         |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/" title="设计模式-备忘录模式">设计模式-备忘录模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B/">设计模式-行为型</a></span></div><div class="content">什么是备忘录模式？备忘录模式 (Memento Pattern) 是一种行为型设计模式，它能在不破坏对象封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样一来，你就可以在将来将该对象恢复到原先保存的状态。这个模式常被用来实现“撤销&#x2F;回滚”（Undo&#x2F;Rollback）功能。 通俗地讲，备忘录模式就像游戏中的“存档”功能。你在玩游戏时（操作一个对象），可以在某个时间点（如打 Boss 前）创建一个存档（备忘录）。这个存档记录了你当前的所有状态（等级、装备、位置等）。如果你打 Boss 失败了，就可以读取这个存档，将游戏恢复到打 Boss 之前的状态，而无需从头再来。游戏本身（原发器）负责创建和读取存档，但存档文件由一个“历史记录”管理者（负责人）来保管。 模式结构备忘录模式主要包含以下三个角色：  Originator (原发器): 这是一个状态可能会发生改变的类。它知道如何创建备忘录来保存自己的状态，也知道如何从备忘录中恢复自己的状态。 Memento (备忘录): 这是一个值对象，用于存储原发器对象的内部状态。为了保护原发器的封装性，备...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式-原型模式">设计模式-原型模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B/">设计模式-创建型</a></span></div><div class="content">什么是原型模式？原型模式 (Prototype Pattern) 是一种创建型设计模式，它允许你通过复制现有对象来创建新对象，而不是通过实例化类。这种模式适用于创建成本较高或过程复杂的对象，通过克隆现有对象可以提高效率。 原型模式的核心思想是“克隆”或“复制”一个已有的对象来生成新的对象。Java 中通过实现 Cloneable 接口并重写 clone() 方法来支持原型模式。 模式结构原型模式包含以下核心角色：  Prototype (抽象原型): 声明一个克隆自身的接口。 ConcretePrototype (具体原型): 实现抽象原型接口，并实现克隆操作。 Client (客户端): 使用抽象原型接口来克隆对象。  结构图下面是原型模式的结构图：      %%{init: {&#39;theme&#39;: &#39;neutral&#39;}}%% classDiagram     direction LR      class Prototype {         &lt;&lt;Interface&gt;&gt;         +clone() Prototyp...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/" title="设计模式-建造者模式">设计模式-建造者模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B/">设计模式-创建型</a></span></div><div class="content">什么是建造者模式？建造者模式 (Builder Pattern) 是一种创建型设计模式，它允许你分步骤创建复杂对象。该模式可以将复杂对象的构造过程与其表示分离，使得同样的构造过程可以创建不同的表示。 当一个对象的构造函数参数过多，或者构造过程复杂且包含多个可选步骤时，建造者模式就显得非常有用。它提供了一种更清晰、更可读的方式来构建对象，避免了“ Telescoping Constructor ”（望远镜式构造函数）的出现。 模式结构建造者模式包含以下核心角色：  Builder (抽象建造者): 定义创建产品各个部件的抽象接口。 ConcreteBuilder (具体建造者): 实现 Builder 接口，构建和装配产品的各个部件，并提供一个方法返回最终产品。 Product (产品): 表示被构造的复杂对象。它通常包含多个部件，这些部件由建造者创建。 Director (指挥者): 负责安排复杂对象的建造次序，它与 Builder 接口交互，指导建造者完成产品的建造。  结构图下面是建造者模式的结构图：      %%{init: {&#39;theme&#39;: &#39;...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/" title="设计模式-命令模式">设计模式-命令模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B/">设计模式-行为型</a></span></div><div class="content">什么是命令模式？命令模式 (Command Pattern) 是一种行为型设计模式，它将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。 通俗地讲，命令模式就像你去餐厅吃饭。你（客户端）看好菜单后，告诉服务员（调用者）你要点什么菜（比如“一份宫保鸡丁”）。服务员将你的点单写在订单（命令对象）上，然后把订单交给后厨的厨师（接收者）。 在这个过程中：  你无需关心厨师是谁，也不用关心宫保鸡丁具体怎么做。 服务员无需知道如何做菜，他只负责传递订单。 厨师无需知道是谁点的菜，他只负责根据订单做菜。 订单本身（命令）成为了一个独立的对象，它包含了所有必要信息（“做一份宫保鸡丁”）。这个订单可以被排队、记录，甚至在厨师还没开始做之前被取消（撤销）。  模式结构命令模式主要包含以下角色：  Command (命令接口): 定义了所有具体命令的统一接口，通常包含一个 execute() 方法。 ConcreteCommand (具体命令): 实现了命令接口。它持有一个 Receiver (接收者) 的引用，并调用接收者的相应方法来完...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" title="设计模式-抽象工厂模式">设计模式-抽象工厂模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B/">设计模式-创建型</a></span></div><div class="content">什么是抽象工厂模式？抽象工厂模式 (Abstract Factory Pattern) 是一种创建型设计模式，它提供一个接口，用于创建相关或依赖对象的家族，而无需指定它们的具体类。 简单来说，抽象工厂模式是工厂方法模式的升级版。工厂方法模式负责生产一类产品（例如，一个日志记录器），而抽象工厂模式则负责生产一个“产品家族”（例如，一个日志记录器家族，包含文件日志记录器和数据库日志记录器，以及它们各自的解析器）。 模式结构抽象工厂模式包含以下核心角色：  AbstractFactory (抽象工厂): 声明了一组用于创建抽象产品对象的工厂方法。 ConcreteFactory (具体工厂): 实现了抽象工厂接口中声明的工厂方法，负责创建具体产品对象。 AbstractProduct (抽象产品): 声明了一组产品对象的接口。 ConcreteProduct (具体产品): 实现了抽象产品接口，由具体工厂创建。 Client (客户端): 使用抽象工厂和抽象产品接口来操作产品，而无需知道具体工厂和具体产品的类。  结构图下面是抽象工厂模式的结构图：      %%{init: {&#3...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" title="设计模式-工厂方法模式">设计模式-工厂方法模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B/">设计模式-创建型</a></span></div><div class="content">什么是工厂方法模式？工厂方法模式 (Factory Method Pattern) 是一种创建型设计模式，它定义了一个用于创建对象的接口，但让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 这听起来可能有点抽象，简单来说，就是将创建具体“产品”的责任从“主工厂”下放到“子工厂”中。每个“子工厂”都只负责生产一种特定的“产品”。 模式结构工厂方法模式包含以下四个核心角色：  Product (抽象产品): 定义了工厂方法所创建的对象的接口。 ConcreteProduct (具体产品): 实现了抽象产品接口，是工厂方法创建的目标。 Creator (抽象创建者&#x2F;工厂): 声明了工厂方法 factoryMethod()，其返回类型是 Product 接口。它也可以包含依赖于抽象产品的业务逻辑。 ConcreteCreator (具体创建者&#x2F;工厂): 重写了工厂方法，以返回一个 ConcreteProduct 的实例。  结构图下面是基于日志记录器 (Logger) 示例的类图，直观地展示了工厂方法模式的结构：      %%{init: {&#39...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/" title="设计模式-外观模式">设计模式-外观模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/">设计模式-结构型</a></span></div><div class="content">什么是外观模式？外观模式 (Facade Pattern) 是一种结构型设计模式，它为复杂子系统中的一组接口提供了一个简化的、统一的入口。外观模式定义了一个高层接口，这个接口使得子系统更加容易使用。 通俗地讲，外观模式就像一个“一键启动”的按钮。想象一下，启动一个家庭影院系统（子系统），你需要按顺序打开投影仪、放下幕布、调暗灯光、打开音响、打开 DVD 播放器。这个过程非常繁琐。现在，你买了一个智能遥控器（外观），它上面只有一个“观影模式”按钮。当你按下这个按钮，遥控器会自动帮你完成上述所有操作。这个智能遥控器就是外观，它简化了你与复杂家庭影院系统的交互。 模式结构外观模式的结构非常简单，主要包含两个角色：  Facade (外观): 知道哪些子系统类负责处理请求，并将客户端的请求代理给适当的子系统对象。它为子系统提供了一个简化的接口。 Subsystem (子系统): 实现子系统的功能，处理由外观对象指派的任务。子系统对外观一无所知。  结构图     %%{init: {&#39;theme&#39;: &#39;neutral&#39;}}%% classDiagram  ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/" title="设计模式-桥接模式">设计模式-桥接模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/">设计模式-结构型</a></span></div><div class="content">什么是桥接模式？桥接模式 (Bridge Pattern) 是一种结构型设计模式，它旨在将抽象部分（Abstraction）与它的实现部分（Implementation）分离，使它们都可以独立地变化。通过提供抽象和实现之间的桥梁结构，来实现这种解耦。 这个定义比较抽象，让我们用一个例子来理解。假设你要画不同颜色（如红色、蓝色）的形状（如圆形、方形）。如果使用继承，你可能需要创建 RedCircle, BlueCircle, RedSquare, BlueSquare 等大量的类。这里有两个变化的维度：形状和颜色。桥接模式就是用来处理这种多维度变化的场景的。它会将“形状”这个抽象概念和“颜色”这个实现概念分离开，让它们可以自由组合，而不是通过继承绑定在一起。 模式结构桥接模式包含以下核心角色：  Abstraction (抽象部分): 定义了抽象类的接口，并持有一个 Implementor (实现部分) 的引用。它通常是抽象类，而不是接口。 RefinedAbstraction (精确抽象): 继承或实现了 Abstraction，并可以添加自己独特的业务逻辑。 Implement...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/" title="设计模式-状态模式">设计模式-状态模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B/">设计模式-行为型</a></span></div><div class="content">什么是状态模式？状态模式 (State Pattern) 是一种行为型设计模式，它允许一个对象在其内部状态改变时改变它的行为。该对象看起来就像是改变了它的类。状态模式将与特定状态相关的行为局部化，并将不同状态的行为分割开来。 通俗地讲，状态模式就像一个自动售货机。这个售货机（上下文）有多种状态：“无币状态”、“有币状态”、“售罄状态”。  在“无币状态”下，你投币，它会进入“有币状态”。你按购买按钮，它会提示你投币。 在“有币状态”下，你投币，它会退还多余的币。你按购买按钮，它会出货并可能进入“无币状态”或“售罄状态”。 在“售罄状态”下，无论你做什么，它都不会出货。  对象（售货机）的行为完全取决于它当前所处的状态。状态模式就是将每种状态下的行为封装在各自独立的类中，使得对象在状态切换时，其行为也随之切换。 模式结构状态模式主要包含以下角色：  Context (上下文): 定义了客户端感兴趣的接口。它维护一个 State 子类的实例，这个实例定义了对象的当前状态。 State (状态接口): 定义了一个接口，用于封装与上下文的特定状态相关的行为。 ConcreteState ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/" title="设计模式-组合模式">设计模式-组合模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/">设计模式-结构型</a></span></div><div class="content">什么是组合模式？组合模式 (Composite Pattern) 是一种结构型设计模式，它允许你将对象组合成树形结构，以表示“部分-整体”的层次关系。组合模式使得客户端可以统一地处理单个对象（叶子节点）和由多个对象组成的组合对象（容器节点）。 通俗地讲，组合模式就像电脑里的文件系统。一个文件夹（容器）里面可以包含文件（叶子），也可以包含其他文件夹（容器）。对于用户来说，无论是文件还是文件夹，都可以执行类似的操作，比如查看属性、移动、删除等。你无需关心你操作的究竟是一个单独的文件，还是一个包含了成百上千个文件和子文件夹的复杂文件夹，你的操作方式是统一的。 模式结构组合模式主要包含以下角色：  Component (组件): 是组合中对象的抽象，为组合中的所有对象（叶子和容器）定义了统一的接口。它声明了用于访问和管理子组件的接口（对于容器是具体实现，对于叶子则是空实现）。 Leaf (叶子): 表示组合中的叶子节点对象，它没有子节点。它实现了组件接口。 Composite (容器&#x2F;组合): 表示组合中的容器节点对象，它可以包含子节点（叶子或其他容器）。它实现了组件接口，并实...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" title="设计模式-模板方法模式">设计模式-模板方法模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B/">设计模式-行为型</a></span></div><div class="content">什么是模板方法模式？模板方法模式 (Template Method Pattern) 是一种行为型设计模式，它在一个抽象类中定义了一个操作的算法骨架，并将一些步骤的实现延迟到子类中。模板方法使得子类可以在不改变算法整体结构的情况下，重新定义算法的某些特定步骤。 通俗地讲，模板方法模式就像是去银行办业务。无论你办什么业务（存款、取款、转账），基本流程（算法骨架）是固定的：取号、排队、叫号、去柜台办理。这个固定流程就是模板方法。而“去柜台办理”这一步的具体内容，则根据你办理的业务（子类）不同而不同。 模式结构模板方法模式的结构非常简单，主要包含两个角色：  AbstractClass (抽象类): 定义了一个或多个抽象方法，供子类实现。同时，它实现了一个模板方法，该方法定义了算法的骨架，并调用了那些抽象方法以及其他具体方法。 ConcreteClass (具体类): 继承了抽象类，并实现了父类中定义的抽象方法，以完成算法中与子类相关的步骤。  结构图     %%{init: {&#39;theme&#39;: &#39;neutral&#39;}}%% classDiagram  ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" title="设计模式-策略模式">设计模式-策略模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B/">设计模式-行为型</a></span></div><div class="content">什么是策略模式？策略模式 (Strategy Pattern) 是一种行为型设计模式，它定义了一系列算法，将每个算法都封装起来，并使它们可以相互替换。策略模式使得算法可以独立于使用它的客户端而变化。 通俗地讲，策略模式就像是解决“条条大路通罗马”的问题。你去罗马（目标），可以选择多种交通方式（策略），比如可以坐飞机、坐火车、或者骑自行车。每种交通方式都是一个独立的策略。你可以根据你的具体情况（如时间、预算）在运行时自由选择和切换策略，而你“去罗马”这个行为本身（客户端）并不需要关心每种交通方式的具体实现细节。 模式结构策略模式主要包含以下角色：  Context (上下文): 维护一个对 Strategy 对象的引用。它不执行具体策略，而是将工作委派给所引用的策略对象。它提供一个方法让客户端设置策略。 Strategy (策略接口): 定义了所有支持的算法的公共接口。上下文使用这个接口来调用由具体策略定义的算法。 ConcreteStrategy (具体策略): 实现了策略接口，封装了具体的算法或行为。  结构图     %%{init: {&#39;theme&#39;: &#...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/" title="设计模式-解释器模式">设计模式-解释器模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B/">设计模式-行为型</a></span></div><div class="content">什么是解释器模式？解释器模式 (Interpreter Pattern) 是一种行为型设计模式，它为一种语言定义其文法的表示，并提供一个解释器来处理这种文法。简单来说，就是定义一套规则，然后用这些规则来解释和执行特定的输入。 通俗地讲，解释器模式就像是音乐家看乐谱。乐谱（语言）有一套自己的文法规则（如音符、节拍、休止符）。音乐家（解释器）在看到乐谱时，会根据这些规则来理解并演奏出相应的音乐（执行操作）。 这个模式通常在需要构建一个简单的语言解释器时使用，例如处理正则表达式、SQL 解析等。 模式结构解释器模式主要包含以下角色：  AbstractExpression (抽象表达式): 声明一个 interpret() (解释) 操作，它是所有具体表达式节点的公共父类。 TerminalExpression (终结符表达式): 实现了抽象表达式接口，代表文法中的终结符（最基本的元素，如数字、变量）。它没有子表达式。 NonterminalExpression (非终结符表达式): 实现了抽象表达式接口，代表文法中的非终结符（如加、减、乘、除等操作）。它通常包含对其他抽象表达式的引用...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" title="设计模式-观察者模式">设计模式-观察者模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B/">设计模式-行为型</a></span></div><div class="content">什么是观察者模式？观察者模式 (Observer Pattern) 是一种行为型设计模式，它定义了对象之间一种一对多的依赖关系。当一个对象（被称为“主题”或“可观察者”）的状态发生改变时，所有依赖于它的对象（被称为“观察者”）都会得到通知并自动更新。这种模式也被广法称为发布-订阅 (Publish-Subscribe) 模式。 通俗地讲，观察者模式就像订阅报笨或杂志。你（观察者）去报社（主题）订阅了报笨。当有新报笨出版时（主题状态改变），报社会主动将新报笨送到你家（通知观察者），而你无需每天都去报社查询。你也可以随时取消订阅，报社就不会再给你送报笨了。 模式结构观察者模式主要包含以下角色：  Subject (主题&#x2F;被观察者): 抽象主题，它维护了一个观察者列表，并提供用于添加、删除和通知观察者的方法。 ConcreteSubject (具体主题): 实现了抽象主题接口。当其内部状态发生改变时，它会通知所有已注册的观察者。 Observer (观察者): 抽象观察者，它定义了一个更新接口，当接受到主题的通知时，该接口将被调用。 ConcreteObserver (具体观...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/" title="设计模式-访问者模式">设计模式-访问者模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B/">设计模式-行为型</a></span></div><div class="content">什么是访问者模式？访问者模式 (Visitor Pattern) 是一种行为型设计模式，它的核心思想是将作用于数据结构中各种元素的操作分离出来，封装成独立的“访问者”对象。这使得你可以在不改变数据结构（元素类）的前提下，为这些元素定义新的操作。 通俗地讲，访问者模式就像一个保险推销员（访问者）去一个公司（对象结构）推销保险。公司里有工程师、经理、HR 等不同类型的员工（元素）。  对于工程师，推销员会说：“你们经常加班，猝死风险高，需要买意外险。” 对于经理，他会说：“您是公司中坚，身系家庭幸福，需要买高额寿险。” 对于 HR，他会说：“贵公司可以为员工统一购买团体险，提升福利。”  在这个过程中，员工（元素）的类没有改变，但保险推销员（访问者）为不同类型的员工提供了完全不同的操作（推销不同的话术）。如果公司需要法律顾问服务，只需派一个律师（另一个访问者）来，他会用另一套话术（操作）来和这些员工打交道。 模式结构访问者模式主要包含以下角色：  Visitor (访问者接口): 定义了对每个 Element (元素) 的访问操作，其方法名通常与被访问的元素类名相关，例如 visit...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/" title="设计模式-装饰器模式">设计模式-装饰器模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/">设计模式-结构型</a></span></div><div class="content">什么是装饰器模式？装饰器模式 (Decorator Pattern) 是一种结构型设计模式，它允许你通过将对象放入包含行为的特殊“包装”对象中，来为原对象动态地添加新的功能。这种模式在不改变原对象类定义的情况下，为其扩展功能，是继承关系的一个替代方案。 通俗地讲，装饰器模式就像给一个“素颜”的人化妆。这个人（原始对象）本身具有基本的功能（如吃饭、睡觉）。现在，我们可以给他“装饰”上不同的妆容（如晚宴妆、舞台妆），每种妆容都为他增添了新的外观和气质，但并没有改变他作为“人”的本质。你可以一层一层地化妆，比如先打底，再画眼影，再涂口红，每一层都是一个装饰器。 模式结构装饰器模式主要包含以下角色：  Component (组件): 定义了原始对象和装饰器对象的通用接口。 ConcreteComponent (具体组件): 实现了组件接口的原始对象，即被装饰的对象。 Decorator (装饰器): 抽象装饰器类，它实现了组件接口，并持有一个组件对象的引用。它的接口与组件接口完全一致，以便它可以透明地包装组件。 ConcreteDecorator (具体装饰器): 实现了抽象装饰器类，负...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/" title="设计模式-责任链模式">设计模式-责任链模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B/">设计模式-行为型</a></span></div><div class="content">什么是责任链模式？责任链模式 (Chain of Responsibility Pattern) 是一种行为型设计模式，它允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链中的下一个处理者。这种模式通过将请求的发送者和接收者解耦，使得多个对象都有机会处理这个请求。 通俗地讲，责任链模式就像公司的报销审批流程。你提交一个报销单（请求），首先由你的直属经理（处理者A）审批。如果金额在经理的权限范围内，他就直接批准了；如果超出他的权限，他不会拒绝，而是将报销单往上传递给部门总监（处理者B）。总监再根据自己的权限进行处理或继续向上传递。你作为申请人，无需关心这个请求最终由谁处理，你只需要把它提交到这个流程（责任链）的起点即可。 模式结构责任链模式主要包含以下角色：  Handler (处理者): 定义了一个处理请求的接口。它通常持有一个指向链中下一个处理者的引用。 ConcreteHandler (具体处理者): 实现了处理者接口。它负责处理它感兴趣的请求，如果它不能处理，则将请求转发给它的后继者。 Client (客户端): 创建处理者链，并将请...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" title="设计模式-适配器模式">设计模式-适配器模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/">设计模式-结构型</a></span></div><div class="content">什么是适配器模式？适配器模式 (Adapter Pattern) 是一种结构型设计模式，它充当两个不兼容接口之间的桥梁。适配器模式通过包装一个已有的类，使其接口符合客户端的期望，从而让原本因接口不匹配而无法协同工作的类能够一起工作。 通俗地讲，适配器模式就像一个转换插头。比如，你的笔记本电脑用的是三孔插头（客户端期望的接口），但墙上的插座是两孔的（已有的接口）。这时，你需要一个转换器（适配器），它一端是两孔插头，另一端是三孔插座，这样你的笔记本电脑就能正常工作了。 模式结构适配器模式主要包含以下角色：  Target (目标接口): 客户端所期待的接口。客户端通过这个接口与适配器进行交互。 Adaptee (被适配者): 需要被适配的类，它有一个已存在的接口，但这个接口不符合客户端的期望。 Adapter (适配器): 适配器类，它实现了目标接口，并持有一个被适配者类的实例。它负责将被适配者的接口转换成目标接口。 Client (客户端): 使用目标接口的类。  结构图 (对象适配器)对象适配器是适配器模式最常用的形式，它基于组合。      %%{init: {&#39;the...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/" title="设计模式-迭代器模式">设计模式-迭代器模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B/">设计模式-行为型</a></span></div><div class="content">什么是迭代器模式？迭代器模式 (Iterator Pattern) 是一种行为型设计模式，它提供了一种顺序访问聚合对象（如列表、集合、数组）中各个元素的方法，而又无需暴露该对象的内部表示（如它是用数组还是链表实现的）。 通俗地讲，迭代器模式就像电视机的遥控器。你（客户端）想看下一个频道，只需要按“下一个”按钮（调用 next() 方法），而不需要关心电视机内部是如何切换频道（聚合对象的内部结构）的。遥控器（迭代器）为你提供了一个统一的、简单的接口来遍历所有频道（元素）。 在 Java 中，迭代器模式是集合框架的基石。我们常用的 for-each 循环，其底层就是通过迭代器来实现的。 模式结构迭代器模式主要包含以下角色：  Iterator (迭代器接口): 定义了遍历元素所需的核心方法，如 hasNext() (检查是否存在下一个元素) 和 next() (返回下一个元素)。 ConcreteIterator (具体迭代器): 实现了迭代器接口。它负责跟踪遍历过程中的当前位置，并知道如何计算下一个元素。 Aggregate (聚合接口): 定义了创建迭代器对象的接口，通常包含一个...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/20/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98-DFS%E7%AF%87-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB/" title="Untitled">Untitled</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-20T02:04:41.730Z" title="Created 2025-10-20 10:04:41">2025-10-20</time></span></div><div class="content"> title: 算法实战-DFS篇-二叉树节点距离date: 2025-10-17 14:00:00categories:  算法与设计模式 算法实战tags: Java 数据结构 算法 DFS 二叉树 LeetCodehighlight_shrink: true   题目描述给定一棵二叉树的根节点 root 以及两个该树中的节点的值 p 和 q，你需要计算出 p 和 q 在该二叉树中对应的两个节点之间的距离，并将其返回。  定义：二叉树中两个节点间的距离就是从一个节点到另一个节点的路径上的边的数量。   解题思路解决这个问题的核心思想是利用最近公共祖先 (Lowest Common Ancestor, LCA)。 两个节点 p 和 q 之间的距离，可以被分解为它们各自到其最近公共祖先的距离之和。 距离(p, q) &#x3D; 距离(LCA, p) + 距离(LCA, q)      graph TD     subgraph &quot;距离计算&quot;         LCA((LCA))         LCA -- &quot;距离(LCA, p)&quot; --...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" title="设计模式-单例模式">设计模式-单例模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-17T08:00:00.000Z" title="Created 2025-10-17 16:00:00">2025-10-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B/">设计模式-创建型</a></span></div><div class="content">经典场景：唯一的配置管理器想象一下，在您的应用程序中，需要一个统一的配置管理器（ConfigManager），它负责从文件或数据库加载配置信息（如数据库URL、线程池大小等），并提供给系统的所有部分使用。 问题来了：如果系统中任何部分都可以随意 new ConfigManager()，会导致什么后果？  状态不一致：每个实例都可能持有不同的配置信息。 资源浪费：多次从文件或数据库加载配置，造成不必要的 I&#x2F;O 和内存开销。  因此，我们必须保证 ConfigManager 这个类在整个应用程序的生命周期中，只有一个实例。这就是单例模式的用武之地。  什么是单例模式 (Singleton Pattern)？ 单例模式是一种创建型设计模式，它确保一个类只有一个实例，并为该实例提供一个全局访问点。  核心要素要实现单例模式，一个类必须做到以下三点：  拥有一个私有的构造函数，以防止外部代码通过 new 操作符直接创建实例。 拥有一个私有的、静态的该类自身的引用变量，用于持有唯一的实例。 拥有一个公共的、静态的方法（通常命名为 getInstance()），用于获取这个唯一的实...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/10/17/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Graph/" title="Java数据结构-Graph">Java数据结构-Graph</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-10-17T02:00:00.000Z" title="Created 2025-10-17 10:00:00">2025-10-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">Java数据结构</a></span></div><div class="content">什么是图 (Graph)？在计算机科学中，图 (Graph) 是一种用于表示对象之间“连接”关系的数据结构。它由两种基本元素组成：  顶点 (Vertex &#x2F; Node): 代表一个对象或实体。 边 (Edge): 代表两个顶点之间的连接关系。  图结构非常强大，可以用来建模现实世界中的许多场景，例如社交网络（用户是顶点，好友关系是边）、地图（城市是顶点，道路是边）、计算机网络（设备是顶点，网络连接是边）等。      graph TD     A((A)) --- B((B))     A --- C((C))     B --- D((D))     C --- D     D --- E((E))      图的类型1. 无向图 (Undirected Graph)边没有方向。如果顶点 A 和顶点 B 之间有一条边，那么你可以从 A 到 B，也可以从 B 到 A。社交网络中的“好友关系”就是典型的无向图。      graph TD     A((A)) --- B((B))     B --- C((C))     2. 有向图 (Directed Graph ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/09/24/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98-%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/" title="算法实战-数组篇（一）">算法实战-数组篇（一）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-09-24T12:30:00.000Z" title="Created 2025-09-24 20:30:00">2025-09-24</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/">算法实战</a></span></div><div class="content">这是我们“算法与设计模式实战”系列的第一篇，主题是数组。数组是最基础、最重要的数据结构之一，我们将通过两道经典的算法题来深入理解它的应用。  题目一：最短路径1. 题目描述给定一个表示地图上坐标的 2D 数组 map，地图上只有值 0, 1, 2。  0 表示可以通过的路径。 1 表示不可通过的墙壁。 2 表示目标位置。  从坐标 [0, 0] 开始，每次只能上、下、左、右移动一格。请找出从起点到目标位置的最短路径，并返回路径的长度。如果无法到达，则返回 -1。 2. 解题思路分析这个问题本质上是在一个无权图 (Unweighted Graph) 中寻找两个节点之间的最短路径。对于这类问题，广度优先搜索 (Breadth-First Search, BFS) 是标准且最高效的解决方案。 BFS 的核心特性是逐层遍历。它从起点开始，先访问所有距离为 1 的节点，然后是所有距离为 2 的节点，以此类推。这种性质保证了当 BFS 第一次找到目标节点时，它所经过的路径必然是最短的。 3. Java 源码实现12345678910111213141516171819202122232425...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/09/24/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" title="算法实战-布隆过滤器">算法实战-布隆过滤器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-09-24T10:00:00.000Z" title="Created 2025-09-24 18:00:00">2025-09-24</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">算法与设计模式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/">算法实战</a></span></div><div class="content">1. 缘起：一个棘手的问题想象一个场景：黑客想要攻击我们的系统，他会故意请求缓存中绝对不存在的数据。由于缓存中没有，请求会直接打到数据库上。如果这类请求数量巨大，数据库的压力会骤增，甚至可能导致崩溃。这就是所谓的**“缓存穿透”**。 我们该如何高效地拦截这些“不存在”的请求，避免它们穿透到数据库呢？ 一个朴素的想法是，把所有合法的数据键（比如所有商品ID）都存入一个哈希集合（HashSet）中，每次请求先进来判断一下。但这在海量数据面前是不可行的，比如你有 1 亿个商品，每个 ID 占 8 字节，光是存储这些 ID 就需要将近 800MB 的内存，成本太高。 有没有一种方法，可以用极小的内存，来“大概”地判断一个元素是否存在呢？布隆过滤器 (Bloom Filter) 正是为此而生。  2. 核心原理：位数组与哈希函数布隆过滤器是一种巧妙的概率型数据结构，它的核心思想非常简洁，由两个基本部分组成：  一个很长的位数组 (Bit Array)：数组的每一位都只能是 0 或 1。 几个不同的哈希函数：这些哈希函数可以将同一个输入均匀地映射到不同的位置。  a. 添加元素 (add)...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/09/21/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Tree/" title="Java数据结构-Tree">Java数据结构-Tree</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-09-21T03:00:00.000Z" title="Created 2025-09-21 11:00:00">2025-09-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">Java数据结构</a></span></div><div class="content">什么是树形结构？在计算机科学中，**树（Tree）**是一种重要的非线性数据结构，它以分层的方式存储数据。树被用来表示具有层级关系的数据，例如文件系统中的目录结构、公司的组织架构图等。 一个树结构包含一系列带有父子关系的节点。每个节点都有一个父节点（除了顶部的根节点）和零个或多个子节点。 核心特性 根节点（Root）: 树顶部的节点，唯一没有父节点的节点。 子节点（Child）: 一个节点下面直接连接的节点。 父节点（Parent）: 一个节点上面直接连接的节点。 叶子节点（Leaf）: 没有任何子节点的节点。 深度（Depth）: 从根节点到某个节点的路径长度。 高度（Height）: 从某个节点到其最远叶子节点的路径长度。       graph TD     A((根节点 Root))     B((子节点 Child))     C((子节点 Child))     D((叶子节点 Leaf))     E((叶子节点 Leaf))     F((叶子节点 Leaf))      A --&gt; B     A --&gt; C     B --&gt; D     B...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/09/16/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Queue/" title="Java数据结构-Queue接口">Java数据结构-Queue接口</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-09-16T10:00:00.000Z" title="Created 2025-09-16 18:00:00">2025-09-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">Java数据结构</a></span></div><div class="content">Java 集合框架：Queue 接口详解在 Java 集合框架中，Queue (队列) 接口是一种特殊的线性数据结构，它遵循 先进先出 (FIFO - First-In, First-Out) 的原则。这意味着最先进入队列的元素将最先被移出。队列在计算机科学中应用广泛，常用于模拟排队、任务调度、广度优先搜索等场景。 1. Queue 接口的核心方法Queue 接口定义了一系列操作队列的方法，这些方法分为两组，其行为略有不同：一组在操作失败时会抛出异常，另一组则会返回特殊值（如 null 或 false）。    操作 抛出异常 返回特殊值 描述    入队 (Insert) add(e) offer(e) 将元素 e 添加到队尾。offer 在队列满时返回 false，add 则抛出异常。   出队 (Remove) remove() poll() 移除并返回队首的元素。poll 在队列为空时返回 null，remove 则抛出异常。   检查队首 (Examine) element() peek() 返回队首的元素，但不移除它。peek 在队列为空时返回 null，elemen...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/09/16/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Map/" title="Java数据结构-Map接口">Java数据结构-Map接口</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-09-16T08:00:00.000Z" title="Created 2025-09-16 16:00:00">2025-09-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">Java数据结构</a></span></div><div class="content">Java 集合框架：Map 接口详解在 Java 集合框架中，Map 接口代表了一种键值对 (key-value) 的映射关系。它与 Collection 接口不同，Map 存储的是两组成员：一组是唯一的键 (Key)，另一组是可重复的值 (Value)。每个键最多只能映射到一个值。 1. Map 接口的核心特性 键值对存储: Map 中的每个元素都包含一个键和一个值。 键的唯一性: Map 不允许有重复的键。如果你用一个已经存在的键去存入一个新的值，新的值会覆盖旧的值，put 方法会返回旧的值。 值的可重复性: Map 中的值可以重复。 非 Collection 子接口: Map 自身是一个顶层接口，它不继承自 Collection 接口。   2. HashMap：最常用的 Map 实现HashMap 是 Map 接口最核心和最常用的实现类，它提供了 O(1) 的平均时间复杂度的性能。 内部原理 (JDK 8+)HashMap 的成功关键在于其高效的哈希算法和精妙的存储结构。其底层结构可以概括为数组 + 链表 + 红黑树。 哈希算法与散列分布HashMap 如何为任意的 ke...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/09/10/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Set/" title="Java数据结构-Set接口">Java数据结构-Set接口</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-09-10T06:10:00.000Z" title="Created 2025-09-10 14:10:00">2025-09-10</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">Java数据结构</a></span></div><div class="content">Java 集合框架：Set 接口详解在 Java 集合框架中，Set 接口是另一个至关重要的组成部分。与 List 不同，Set 代表一个不包含重复元素的集合。它模拟了数学中“集合”的概念，强调元素的唯一性。 1. Set 接口的核心特性 唯一性 (Uniqueness): 这是 Set 最核心的特性。当你尝试向 Set 中添加一个已经存在的元素时，添加操作会失败，add() 方法会返回 false。元素的唯一性通常是通过元素的 equals() 和 hashCode() 方法来保证的。 无序性 (Unordered) (通常): 大多数 Set 的实现类（如 HashSet）不保证元素的存储和迭代顺序。这意味着元素的顺序可能会随着时间的推移而改变，你不能依赖于它们的顺序。但是，也有一些实现类（如 LinkedHashSet 和 TreeSet）可以维持特定的顺序。 非基于索引 (Not Index-based): 与 List 不同，你不能通过索引来访问 Set 中的元素。要访问 Set 中的元素，你必须遍历它。   2. HashSet：最常用的 Set 实现HashSet ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/09/04/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-List/" title="Java数据结构-List接口">Java数据结构-List接口</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-09-04T02:00:00.000Z" title="Created 2025-09-04 10:00:00">2025-09-04</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">Java数据结构</a></span></div><div class="content">Java 集合框架：List 接口详解在 Java 的集合框架 (Collections Framework) 中，List 是一个核心接口，它代表一个有序的集合，并且允许包含重复的元素。它是我们日常开发中最常打交道的集合类型之一。 1. List 接口的核心特性 有序性 (Ordered): List 会维护元素的插入顺序。你以什么顺序添加元素，遍历时就会得到什么顺序。 允许重复 (Allows Duplicates): 你可以向 List 中添加多个相同（通过 equals() 方法判断）的元素。 基于索引 (Index-based): List 中的每个元素都有一个唯一的、从 0 开始的整数索引，可以通过索引精确地访问、修改或删除元素。  常用方法List 接口提供了一系列基于索引的操作方法：  void add(int index, E element): 在指定索引处插入元素。 E get(int index): 获取指定索引处的元素。 E set(int index, E element): 替换指定索引处的元素。 E remove(int index): 移除指定索...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/09/02/Java%E5%9F%BA%E7%A1%80-Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="Java基础-Java开发环境搭建">Java基础-Java开发环境搭建</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-09-02T02:00:00.000Z" title="Created 2025-09-02 10:00:00">2025-09-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/Java%E5%9F%BA%E7%A1%80/">Java基础</a></span></div><div class="content">Java开发环境搭建搭建Java开发环境是学习Java的第一步，它包括安装JDK（Java Development Kit）和选择一个集成开发环境（IDE）。 1. JDK的安装与配置JDK是Java开发的核心，包含了Java运行时环境（JRE）和开发工具。 1.1 下载JDK访问Oracle官方网站或OpenJDK社区网站下载适合您操作系统的最新稳定版JDK。  Oracle JDK: https://www.oracle.com/java/technologies/downloads/ OpenJDK: https://openjdk.java.net/ (推荐，通常更开放和免费)  选择与您操作系统（Windows, macOS, Linux）和架构（x64, ARM64等）匹配的版本。 1.2 安装JDK Windows: 双击下载的.exe安装包，按照提示一步步完成安装。建议安装到默认路径，或者一个不包含空格和特殊字符的路径（例如 C:\Java\jdk-xx）。 macOS: 双击下载的.dmg文件，按照提示完成安装。 Linux: 通常可以通过包管理器（如apt f...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/09/01/Java%E5%9F%BA%E7%A1%80-Java%E6%A6%82%E8%BF%B0/" title="Java基础-Java概述">Java基础-Java概述</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-09-01T02:00:00.000Z" title="Created 2025-09-01 10:00:00">2025-09-01</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/">核心Java与JVM精通</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/Java%E5%9F%BA%E7%A1%80/">Java基础</a></span></div><div class="content">Java概述1. Java的历史与发展Java语言由Sun Microsystems公司（现已被Oracle收购）的詹姆斯·高斯林（James Gosling）等人于1991年开始开发，最初命名为Oak。其设计目标是“一次编写，到处运行”（Write Once, Run Anywhere, WORA）。  1995年： 正式发布Java 1.0版本，并迅速在互联网领域获得关注。 2000年代： 随着J2EE（后来的Java EE）的推出，Java在企业级应用开发中占据主导地位。 2006年： Sun公司将Java大部分源代码开放，成立OpenJDK社区。 2009年： Oracle收购Sun Microsystems，Java的所有权归Oracle所有。 至今： Java持续发展，定期发布新版本，不断引入新特性以适应现代软件开发的需求。  2. Java的特性Java之所以广受欢迎，得益于其一系列强大的特性：  简单性： 相较于C++，Java移除了指针、多重继承等复杂概念，使得学习和使用更加简单。 面向对象： Java是纯粹的面向对象语言，支持封装、继承和多态三大特性，有助于构...</div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">david</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">71</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">152</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/22/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" title="JVM-内存模型">JVM-内存模型</a><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/22/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" title="JVM-垃圾回收">JVM-垃圾回收</a><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/22/JVM-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/" title="JVM-性能调优">JVM-性能调优</a><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/22/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" title="JVM-类加载机制">JVM-类加载机制</a><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/22/JavaSE-%E5%85%A8%E9%9D%A2%E6%8E%8C%E6%8F%A1/" title="JavaSE-全面掌握">JavaSE-全面掌握</a><time datetime="2025-10-22T02:00:00.000Z" title="Created 2025-10-22 10:00:00">2025-10-22</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>Categories</span>
            <a class="card-more-btn" href="/categories/" title="View More">
      <i class="fas fa-angle-right"></i></a>
          </div>
          <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"><span class="card-category-list-name">学习计划</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/"><span class="card-category-list-name">核心Java与JVM精通</span><span class="card-category-list-count">43</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/JVM%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/"><span class="card-category-list-name">JVM内部原理</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/Java%E5%9F%BA%E7%A1%80/"><span class="card-category-list-name">Java基础</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="card-category-list-name">Java数据结构</span><span class="card-category-list-count">6</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"><span class="card-category-list-name">Java语言基础与高级特性</span><span class="card-category-list-count">11</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="card-category-list-name">并发编程与多线程</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%A0%B8%E5%BF%83Java%E4%B8%8EJVM%E7%B2%BE%E9%80%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><span class="card-category-list-name">计算机基础</span><span class="card-category-list-count">16</span></a></li></ul></li>
          </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>Tags</span></div><div class="card-tag-cloud"><a href="/tags/PriorityQueue/" style="font-size: 1.1em; color: #999">PriorityQueue</a> <a href="/tags/%E9%94%81/" style="font-size: 1.1em; color: #999">锁</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 1.1em; color: #999">面向对象</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 1.1em; color: #999">性能优化</a> <a href="/tags/%E6%95%B0%E7%BB%84/" style="font-size: 1.1em; color: #999">数组</a> <a href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 1.1em; color: #999">内存模型</a> <a href="/tags/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/" style="font-size: 1.23em; color: #999ea6">存储系统</a> <a href="/tags/JMM/" style="font-size: 1.1em; color: #999">JMM</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.1em; color: #999">面试</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.43em; color: #99a6b9">设计模式</a> <a href="/tags/TLS/" style="font-size: 1.1em; color: #999">TLS</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.1em; color: #999">操作系统</a> <a href="/tags/OSI/" style="font-size: 1.1em; color: #999">OSI</a> <a href="/tags/ZGC/" style="font-size: 1.1em; color: #999">ZGC</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 1.23em; color: #999ea6">并发编程</a> <a href="/tags/%E6%B3%9B%E5%9E%8B/" style="font-size: 1.1em; color: #999">泛型</a> <a href="/tags/Java/" style="font-size: 1.5em; color: #99a9bf">Java</a> <a href="/tags/%E4%B8%AD%E6%96%AD/" style="font-size: 1.1em; color: #999">中断</a> <a href="/tags/HTTP/" style="font-size: 1.17em; color: #999c9f">HTTP</a> <a href="/tags/ArrayDeque/" style="font-size: 1.1em; color: #999">ArrayDeque</a> <a href="/tags/%E5%85%83%E7%A9%BA%E9%97%B4/" style="font-size: 1.1em; color: #999">元空间</a> <a href="/tags/JDK/" style="font-size: 1.1em; color: #999">JDK</a> <a href="/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/" style="font-size: 1.1em; color: #999">浮点数</a> <a href="/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" style="font-size: 1.3em; color: #99a1ac">集合框架</a> <a href="/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" style="font-size: 1.1em; color: #999">异常处理</a> <a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 1.1em; color: #999">线程</a> <a href="/tags/%E8%BF%90%E7%AE%97%E5%99%A8/" style="font-size: 1.1em; color: #999">运算器</a> <a href="/tags/HashSet/" style="font-size: 1.1em; color: #999">HashSet</a> <a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 1.1em; color: #999">注解</a> <a href="/tags/%E9%9D%9E%E9%98%BB%E5%A1%9EIO/" style="font-size: 1.1em; color: #999">非阻塞IO</a> <a href="/tags/Servlet/" style="font-size: 1.1em; color: #999">Servlet</a> <a href="/tags/CMS/" style="font-size: 1.1em; color: #999">CMS</a> <a href="/tags/DRAM/" style="font-size: 1.1em; color: #999">DRAM</a> <a href="/tags/Filter/" style="font-size: 1.1em; color: #999">Filter</a> <a href="/tags/Map/" style="font-size: 1.17em; color: #999c9f">Map</a> <a href="/tags/Behavioral/" style="font-size: 1.37em; color: #99a4b2">Behavioral</a> <a href="/tags/LintCode/" style="font-size: 1.1em; color: #999">LintCode</a> <a href="/tags/TCP/" style="font-size: 1.1em; color: #999">TCP</a> <a href="/tags/%E5%86%85%E5%AD%98/" style="font-size: 1.17em; color: #999c9f">内存</a> <a href="/tags/GC/" style="font-size: 1.1em; color: #999">GC</a></div></div><div class="card-widget card-archives">
    <div class="item-headline">
      <i class="fas fa-archive"></i>
      <span>Archives</span>
      
    </div>
  
    <ul class="card-archive-list">
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/10/">
            <span class="card-archive-list-date">
              October 2025
            </span>
            <span class="card-archive-list-count">62</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/09/">
            <span class="card-archive-list-date">
              September 2025
            </span>
            <span class="card-archive-list-count">9</span>
          </a>
        </li>
      
    </ul>
  </div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>Website Info</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">Article Count :</div><div class="item-count">71</div></div><div class="webinfo-item"><div class="item-name">Unique Visitors :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">Page Views :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">Last Update :</div><div class="item-count" id="last-push-date" data-lastPushDate="2025-11-25T08:30:05.827Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By david</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>